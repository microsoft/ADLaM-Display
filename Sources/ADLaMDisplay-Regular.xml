<?xml version="1.0" encoding="UTF-8"?>
<ttFont ttVttLibVersion="1.0">
  <fpgm>
    <assembly>/* Font-program */
/* ACT generated Fri Jun 23 01:02:17 2023 */

FDEF[], 9

/* Set fv to X
       pv perpendicular to italic angle

   CALL[], 9 */

#BEGIN
#PUSHOFF
SVTCA[X]
#PUSH, 11, 10
RS[]
SWAP[]
RS[]
NEG[]
SPVFS[]
#PUSHON
#END
ENDF[]

FDEF[], 10

/* Set fv to italic angle
       pv to Y

   CALL[], 10 */

#BEGIN
#PUSHOFF
SVTCA[Y]
#PUSH, 10, 11
RS[]
SWAP[]
RS[]
SFVFS[]
#PUSHON
#END
ENDF[]

FDEF[], 16

/* Set fv to X
       pv perpendicular to adjusted italic angle

   CALL[], 16 */

#BEGIN
#PUSHOFF
SVTCA[X]
#PUSH, 6
RS[]
#PUSH, 7
RS[]
NEG[]
SPVFS[]
#PUSHON
#END
ENDF[]

FDEF[], 31

/* fn 31 equalizes two cvts below a given ppem size

   CALL[], &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;ppem size&gt;, 31 */

#BEGIN
#PUSHOFF

/* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;ppem size&gt; */

#PUSH, 79 /* #samples/pixel */
CALL[]
DUP[]
#PUSH, 64
LTEQ[]
IF[] /* #samples/pixel &lt;= 1 */

    /* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;ppem size&gt;, &lt;#samples/pixel&gt; */

    POP[] /* #samples/pixel not involved */
    MPPEM[]

    /* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;ppem size&gt;, &lt;act ppem size&gt; */

    GT[]
    IF[]
        RCVT[]
        WCVTP[]
    ELSE[]
        POP[]
        POP[]
    EIF[]

ELSE[] /* #samples/pixel &gt; 1 */

    /* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;ppem size&gt;, &lt;#samples/pixel&gt; */

    SWAP[]
    POP[] /* ppem Size not involved */
    #PUSH, 64

    /* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;#samples/pixel&gt;, &lt;1&gt; */

    #PUSH, 4 /* child cvt */
    CINDEX[]
    RCVT[]
    #PUSH, 4 /* parent cvt */
    CINDEX[]
    RCVT[]
    SUB[]
    ABS[]

    /* STACK: &lt;child cvt&gt;, &lt;parent cvt&gt;, &lt;#samples/pixel&gt;, &lt;1&gt;, &lt;|[child cvt] - [parent cvt]|&gt; */

    ROLL[]
    MUL[]
    GT[]
    IF[] /* 1 &gt; #samples/pixel * delta cvt */
        RCVT[]
        WCVTP[]
    ELSE[]
        POP[]
        POP[]
    EIF[]

EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 40

/* Set fv to adjusted italic angle
       pv to Y

   CALL[], 40 */

#BEGIN
#PUSHOFF
SVTCA[Y]
#PUSH, 7
RS[]
#PUSH, 6
RS[]
SFVFS[]
#PUSHON
#END
ENDF[]

FDEF[], 70

/* fn changes &lt;cvt&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem sizes &lt;low ppem&gt; to &lt;high ppem&gt; (inclusive)

   CALL[], &lt;amount&gt;, &lt;cvt&gt;, &lt;low ppem&gt;, &lt;high ppem&gt;, 70 */

#BEGIN
#PUSHOFF
MPPEM[]
GTEQ[]
SWAP[]
MPPEM[]
LTEQ[]
AND[]
IF[]
    DUP[]
    RCVT[]
    ROLL[]
    ADD[]
    WCVTP[]
ELSE[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 71

/* fn changes &lt;cvt&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem size &lt;ppem&gt;

   CALL[], &lt;amount&gt;, &lt;cvt&gt;, &lt;ppem&gt;, 71 */

#BEGIN
#PUSHOFF
MPPEM[]
EQ[]
IF[]
    DUP[]
    RCVT[]
    ROLL[]
    ADD[]
    WCVTP[]
ELSE[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 72

/* fn moves &lt;point&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem sizes &lt;low ppem&gt; to &lt;high ppem&gt; (inclusive)

   CALL[], &lt;point&gt;, &lt;amount&gt;, &lt;low ppem&gt;, &lt;high ppem&gt;, 72 */

#BEGIN
#PUSHOFF
MPPEM[]
GTEQ[]
SWAP[]
MPPEM[]
LTEQ[]
AND[]
IF[]
    SHPIX[]
ELSE[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 73

/* fn moves &lt;point&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem size &lt;ppem&gt;

   CALL[], &lt;point&gt;, &lt;amount&gt;, &lt;ppem&gt;, 73 */

#BEGIN
#PUSHOFF
MPPEM[]
EQ[]
IF[]
    SHPIX[]
ELSE[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 74

/* if &lt;flag&gt; = anti-aliasing in s[2] (set by fn 84)
   fn changes &lt;cvt&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem sizes &lt;low ppem&gt; to &lt;high ppem&gt; (inclusive)

   CALL[], &lt;amount&gt;, &lt;cvt&gt;, &lt;low ppem&gt;, &lt;high ppem&gt;, &lt;flag&gt;, 74 */

#BEGIN
#PUSHOFF
#PUSH, 2
RS[]
EQ[]
IF[]           /* if &lt;flag&gt; = s[2] then fwd to fn 70 */
    #PUSH, 70
    CALL[]
ELSE[]         /* else cleanup stack and bail out */
    POP[]
    POP[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 75

/* if &lt;flag&gt; = anti-aliasing in s[2] (set by fn 84)
   fn changes &lt;cvt&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem size &lt;ppem&gt;

   CALL[], &lt;amount&gt;, &lt;cvt&gt;, &lt;ppem&gt;, &lt;flag&gt;, 75 */

#BEGIN
#PUSHOFF
#PUSH, 2
RS[]
EQ[]
IF[]           /* if &lt;flag&gt; = s[2] then fwd to fn 71 */
    #PUSH, 71
    CALL[]
ELSE[]         /* else cleanup stack and bail out */
    POP[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 76

/* if &lt;flag&gt; = anti-aliasing in s[2] (set by fn 84)
   fn moves &lt;point&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem sizes &lt;low ppem&gt; to &lt;high ppem&gt; (inclusive)

   CALL[], &lt;point&gt;, &lt;amount&gt;, &lt;low ppem&gt;, &lt;high ppem&gt;, &lt;flag&gt;, 76 */

#BEGIN
#PUSHOFF
#PUSH, 2
RS[]
EQ[]
IF[]           /* if &lt;flag&gt; = s[2] then fwd to fn 72 */
    #PUSH, 72
    CALL[]
ELSE[]         /* else cleanup stack and bail out */
    POP[]
    POP[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 77

/* if &lt;flag&gt; = anti-aliasing in s[2] (set by fn 84)
   fn moves &lt;point&gt; by &lt;amount&gt; (in ±1/64 pixel) at
   ppem size &lt;ppem&gt;

   CALL[], &lt;point&gt;, &lt;amount&gt;, &lt;ppem&gt;, &lt;flag&gt;, 77 */

#BEGIN
#PUSHOFF
#PUSH, 2
RS[]
EQ[]
IF[]           /* if &lt;flag&gt; = s[2] then fwd to fn 73 */
    #PUSH, 73
    CALL[]
ELSE[]         /* else cleanup stack and bail out */
    POP[]
    POP[]
    POP[]
EIF[]
#PUSHON
#END
ENDF[]

FDEF[], 78

/* apply minimum distance and round &lt;dist&gt; depending on s[2], &lt;code&gt;, and pv
   code = 0: position
   code = 1: distance
   code = 2: delta distance (for fractional inheritance)

   CALL[], &lt;dist&gt;, &lt;code&gt;, 78

   returns with rounded distance on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;dist&gt;, &lt;code&gt; */

SWAP[]
DUP[]
#PUSH, 0
LT[]
ROLL[]
ROLL[]
ABS[]

/* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;|dist|&gt; */

#PUSH, 0, 3 /* code */
CINDEX[]
EQ[]
IF[] /* position */

    /* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;|dist|&gt; */

    #PUSH, 64

    /* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;|dist|&gt;, &lt;#samples/pixel&gt; */

ELSE[]

    /* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;|dist|&gt; */

    #PUSH, 1, 3 /* code */
    CINDEX[]
    EQ[]
    IF[] /* distance */
        #PUSH, 5 /* minimum distance */
        RS[]
        MAX[]
    EIF[]

    #PUSH, 79 /* #samples/pixel */
    CALL[]

    /* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;|dist|&gt;, &lt;#samples/pixel&gt; */

EIF[]

SWAP[]
#PUSH, 98 /* round to virtual grid */
CALL[]

/* STACK: &lt;negDist&gt;, &lt;code&gt;, &lt;[|dist|]&gt; */

SWAP[]
POP[]

/* STACK: &lt;negDist&gt;, &lt;[|dist|]&gt; */

SWAP[]
IF[]
    NEG[]
EIF[]

/* STACK: &lt;[dist]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 79

/* depending on rendering environment and pv determine #samples/pixel for rounding etc.

   notice that for PVs other than X or Y, this method will default to X, reflecting the
   bias inherent in the asymmetrical nature of ClearType

   CALL[], 79

   returns the #samples/pixel in 26.6 */

#BEGIN
#PUSHOFF

#PUSH, 8, 0
GPV[]
POP[]
EQ[]
ADD[]
RS[]

#PUSHON
#END
ENDF[]

FDEF[], 80

/* depending on rendering environment and pv determine actual stroke optimization method

   CALL[], 80

   returns with method on stack (see fn 112 for definition of method) */

#BEGIN
#PUSHOFF

#PUSH, 12, 0
GPV[]
POP[]
EQ[]
ADD[]
RS[]

#PUSHON
#END
ENDF[]

FDEF[], 81

   /* adjust advance width to compensate for rasterizer's rounding errors 

   CALL[], &lt;rsb&gt;, 81 */

#BEGIN
#PUSHOFF

/* STACK: &lt;rsb&gt; */

SVTCA[X]
DUP[]
GC[O]

/* STACK: &lt;rsb&gt;, &lt;rsb.x&gt; */
#PUSH, 2
RS[]
DUP[]
#PUSH, 4096 /* fract AW value in 26.6 */
DIV[]
#PUSH, 4096 /* 64 in 26.6 */
MUL[]
EVEN[] /* fract AW bit not set */
SWAP[]
#PUSH, 256 /* comp AW value in 26.6 */
DIV[]
#PUSH, 4096 /* 64 in 26.6 */
MUL[]
EVEN[] /* comp AW bit not set */
AND[]
IF[]
    #PUSH, 32
    ADD[]
    FLOOR[]
EIF[]

SCFS[]

#PUSHON
#END
ENDF[]

FDEF[], 83

/* CALL[], &lt;radicand&gt;, 83

   returns with square root of radicand on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;radicand&gt; */

#PUSH, 0, 2
CINDEX[]

/* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt; */

#WBeginLoop83:

    #PUSH, 2 /* low */
    CINDEX[]
    #PUSH, 2 /* high */
    CINDEX[]
    GTEQ[]
    #PUSH, WOffset83a
    SWAP[]
    JROT[], (WOffset83a=#WEndLoop83) /* while low &lt;= high */

    /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt; */

    #PUSH, 2 /* low */
    CINDEX[]
    #PUSH, 2 /* high */
    CINDEX[]
    ADD[]
    #PUSH, 32
    MUL[]

    /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt;, &lt;mid&gt; */

    DUP[]
    DUP[]
    #PUSH, 6 /* radicand */
    CINDEX[]
    SWAP[]
    DIV[]

    /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt;, &lt;mid&gt;, &lt;mid&gt;, &lt;radicand/mid&gt; */

    LT[]
    IF[]

        /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt;, &lt;mid&gt; */

        ROLL[]
        POP[]
        #PUSH, 1
        ADD[]
        SWAP[]

        /* STACK: &lt;radicand&gt;, &lt;mid+1&gt;, &lt;high&gt; */

    ELSE[]

        DUP[]
        DUP[]
        #PUSH, 6 /* radicand */
        CINDEX[]
        SWAP[]
        DIV[]

        GT[]
        IF[]

            /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt;, &lt;mid&gt; */

            SWAP[]
            POP[]
            #PUSH, 1
            SUB[]

            /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;mid-1&gt; */

        ELSE[]

            /* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt;, &lt;mid&gt; */

            ROLL[]
            POP[]
            SWAP[]
            POP[]
            DUP[]

            /* STACK: &lt;radicand&gt;, &lt;mid&gt;, &lt;mid&gt; */

        EIF[]

    EIF[]


    #PUSH, WOffset83b
    JMPR[], (WOffset83b=#WBeginLoop83)

#WEndLoop83:

/* STACK: &lt;radicand&gt;, &lt;low&gt;, &lt;high&gt; */

ADD[]
#PUSH, 32
MUL[]
SWAP[]
POP[]

/* STACK: &lt;mid&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 84

/* fn determines current rasterizing environment and stores it in s[2] as follows:
     bit 0 (value   1) = Grey-Scaling
     bit 1 (value   2) = ClearType(tm)
     bit 2 (value   4) = Compatible Width ClearType
     bit 3 (value   8) = Vertical Direction (horizontally striped) ClearType
     bit 4 (value  16) = BGR as opposed to RGB Devices
     bit 5 (value  32) = ClearType on Rapier CE Devices
     bit 6 (value  64) = ClearType with fractional advance widths
     bit 7 (value 128) = ClearType with non-ClearType direction anti-aliasing
     bit 8 (value 256) = ClearType with gray full-pixel

   s[2] is used e.g. in fns 74 through 77

   To test against any combination of these flags, add up the respective values.

   specific to the current rasterizing environment fn stores the following parameters
     s[5] = minimum distance
     s[8] = #samples/pixel in x-direction
     s[9] = #samples/pixel in y-direction
     s[12] = stroke optimization method in x-direction
     s[13] = stroke optimization method in y-direction

   CALL[], 84 */
   /* Version 2.1 20120101 */

#BEGIN
#PUSHOFF
#PUSH,2,0
WS[]            /* s[2] = grey scaling: off (by default) */
#PUSH,35,1      /* 35 = MS Rasterizer version 1.7 */
GETINFO[]       /* 1 = tell GETINFO to give us the rasterizer version */
LTEQ[]          /* 35 &lt;= version ? */
#PUSH,64,1      /* 64 = highest rasterizer version assigned to MS */
GETINFO[]       /* 1 = tell GETINFO to give us the rasterizer version */
GTEQ[]          /* 64 &gt;= version ? */
AND[]           /* 35 &lt;= version &amp;&amp; version &lt;= 64 ? */
IF[]            /* if so, we're running MS rasterizer version 1.7 or higher */
  #PUSH,4096,32 /* 4096 = flag returned by GETINFO if grey scaling bit is on */
  GETINFO[]     /* 32 = tell GETINFO to give us the grey scaling bit */
  EQ[]          /* 4096 == flag ? */
  IF[]          /* if so, we're running under grey scaling */
    #PUSH,2,1,2
    RS[]
    ADD[]
    WS[]        /* s[2] += grey scaling: on (by now) */
  EIF[]
  #PUSH,36,1      /* 36 = MS Rasterizer version 1.6+ (WinCE) or 1.8 (WinXP) */
  GETINFO[]       /* 1 = tell GETINFO to give us the rasterizer version */
  LTEQ[]          /* 36 &lt;= version ? (already tested version &lt;= 64) */
  IF[]            /* if so, we're running MS rasterizer version 1.6+ (WinCE) or 1.8 (WinXP) or higher */
    #PUSH,8192,64 /* 8192 = flag returned by GETINFO if ClearTypeTM bit is on */
    GETINFO[]     /* 64 = tell GETINFO to give us the ClearTypeTM bit */
    EQ[]          /* 8192 == flag ? */
    IF[]          /* if so, we're running under ClearTypeTM */
      #PUSH,2,2,2
      RS[]
      ADD[]
      WS[]        /* s[2] += ClearTypeTM: on (by now) */

      #PUSH,36,1    /* 36 = MS Rasterizer version 1.6+ (WinCE) */
      GETINFO[]
      EQ[]
      IF[] /***** we're running Rasterizer v1.6+ for WinCE with ClearType *****/

        #PUSH,2,32,2
        RS[]
        ADD[]
        WS[]        /* s[2] += Rapier CE: on (by now) */
        SVTCA[Y]
        MPPEM[]
        SVTCA[X]
        MPPEM[]
        GT[]
        IF[]
          #PUSH,2,8,2
          RS[]
          ADD[]
          WS[]
        EIF[]

      ELSE[] /***** we're running Rasterizer v1.8 (or higher) for WinXP with ClearType (or Win2k 2000 with ClearType patch) *****/

        #PUSH,16384,128 /* 16384 = flag returned by GETINFO if ClearTypeTM silly aw bit is on */
        GETINFO[]       /* 128 = tell GETINFO to give us the ClearTypeTM silly aw bit */
        EQ[]            /* 16384 == flag ? */
        IF[]            /* if so, we're running under ClearTypeTM silly aw */
          #PUSH,2,4,2
          RS[]
          ADD[]
          WS[]          /* s[2] += ClearTypeTM silly aw: on (by now) */
        EIF[]

        #PUSH,16384,128 /* 32768 = flag returned by GETINFO if ClearTypeTM in vertical direction bit is on */
        MUL[]           /* Assembler restriction: produce 32768 by multiplying 16384 by 2 (2 in F26.6 is 128) */
        #PUSH,256       /* 256 = tell GETINFO to give us the ClearTypeTM in vertical direction bit */
        GETINFO[]
        EQ[]            /* 32768 == flag ? */
        IF[]            /* if so, we're running ClearTypeTM in vertical direction */
        #PUSH,2,8,2
          RS[]
          ADD[]
          WS[]          /* s[2] += ClearTypeTM in vertical direction: on (by now) */
        EIF[]

        #PUSH,16384,256 /* 65536 = flag returned by GETINFO if ClearTypeTM in BGR order bit is on */
        MUL[]           /* Assembler restriction: produce 65536 by multiplying 16384 by 4 (4 in F26.6 is 256) */
        #PUSH,512       /* 512 = tell GETINFO to give us the ClearTypeTM in BGR order bit */
        GETINFO[]
        EQ[]            /* 65536 == flag ? */
        IF[]            /* if so, we're running under ClearTypeTM in BGR order */
          #PUSH,2,16,2
          RS[]
          ADD[]
          WS[]          /* s[2] += ClearTypeTM in BGR order: on (by now) */
        EIF[]

        #PUSH,38,1      /* 38 = MS Rasterizer version 1.9 */
        GETINFO[]       /* 1 = tell GETINFO to give us the rasterizer version */
        LTEQ[]          /* 38 &lt;= version ? (already tested version &lt;= 64) */
        IF[]            /* if so, we're running MS rasterizer version 1.9 (Windows Longhorn) or higher */

          #PUSH,16384,512  /* 131072 = flag returned by GETINFO if ClearTypeTM fractional advance widths bit is on */
          MUL[]            /* Assembler restriction: produce 131072 by multiplying 16384 by 8 (8 in F26.6 is 512) */
          #PUSH,1024       /* 1024 = tell GETINFO to give us the ClearTypeTM fractional advance widths bit */
          GETINFO[]
          EQ[]             /* 131072 == flag ? */
          IF[]             /* if so, we're running under ClearTypeTM fractional advance widths */
            #PUSH,2,64,2
            RS[]
            ADD[]
            WS[]           /* s[2] += ClearTypeTM fractional advance widths: on (by now) */
          EIF[]

          #PUSH,16384,1024 /* 262144 = flag returned by GETINFO if ClearTypeTM non-ClearType direction anti-aliasing bit is on */
          MUL[]            /* Assembler restriction: produce 262144 by multiplying 16384 by 16 (16 in F26.6 is 1024) */
          #PUSH,2048       /* 2048 = tell GETINFO to give us the ClearTypeTM non-ClearType direction anti-aliasing bit */
          GETINFO[]
          EQ[]             /* 262144 == flag ? */
          IF[]             /* if so, we're running under ClearTypeTM non-ClearType direction anti-aliasing */
            #PUSH,2,128,2
            RS[]
            ADD[]
            WS[]           /* s[2] += ClearTypeTM non-ClearType direction anti-aliasing: on (by now) */
          EIF[]

          #PUSH,40,1      /* 40 = Rasterizer v2.1 Windows 8, SubPixel */
          GETINFO[]       /* 1 = tell GETINFO to give us the rasterizer version */
          LTEQ[]          /* 40 &lt;= version ? (already tested version &lt;= 64) */
          IF[]            /* if so, we're running MS rasterizer version 2.1 (Windows 8) or higher */
            #PUSH,16384,2048 /* 524288 = flag returned by GETINFO if ClearTypeTM non-ClearType direction anti-aliasing bit is on */
            MUL[]            /* Assembler restriction: produce 524288 by multiplying 16384 by 32 (32 in F26.6 is 2048) */
            #PUSH,4096       /* 4096 = tell GETINFO to give us the ClearTypeTM gray full-pixel rendering bit */
            GETINFO[]
            EQ[]             /* 524288 == flag ? */
            IF[]             /* if so, we're running under ClearTypeTM gray full-pixel rendering */
            #PUSH,2,256,2
              RS[]
              ADD[]
              WS[]           /* s[2] += ClearTypeTM gray full-pixel rendering: on (by now) */
            EIF[]
          EIF[]

        EIF[] /* Vista or greater rasterizer */

      EIF[] /* Windows ClearType (Platt) */

    EIF[] /* ClearType Enabled */
  EIF[] /* ClearType enabled rasterizer */
EIF[] /* Microsoft Rasterizer */

/* store rasterizing environment specific parameters */

#PUSH, 0, 2
RS[]
EQ[]
IF[] /* for b&amp;w */
  #PUSH, 5, 64, 8, 64, 9, 64, 12, 2, 13, 2
ELSE[]
  #PUSH, 1, 2
  RS[]
  EQ[]
  IF[] /* for grey-scaling */
    #PUSH, 5, 64, 8, 256, 9, 256, 12, 1, 13, 1
  ELSE[]
    #PUSH, 128, 2
    RS[]
    GT[]
    IF[] /* for ClearType */
      #PUSH, 5, 64, 8, 384, 9, 64
    ELSE[] /* for y-anti-aliased ClearType */
      #PUSH, 256, 2
      RS[]
      GT[]
      IF[] /* Gray ClearType */
        #PUSH, 5, 64, 8, 384, 9, 320
      ELSE[] /* Gray ClearType */
        #PUSH, 384, 2
        RS[]
        GT[]
        IF[] /* Gray ClearType */
          #PUSH, 5, 64, 8, 512, 9, 64
        ELSE[] /* Gray ClearType y-anti-aliased */
          #PUSH, 5, 64, 8, 256, 9, 256
        EIF[]
      EIF[]
    EIF[]

    #PUSH,16384,128 /* b&amp;w aw? */
    GETINFO[]
    NEQ[]
    #PUSH,16384,512 /* fract aw? */
    MUL[]
    #PUSH,1024
    GETINFO[]
    NEQ[]
    AND[]
    IF[] /* natural widths */
      #PUSH, 12, 0, 13, 1
    ELSE[] /* compatible or fractional widths */
      #PUSH, 12, 0, 13, 1
    EIF[]

  EIF[]
EIF[]

WS[]
WS[]
WS[]
WS[]
WS[]

#PUSHON
#END
ENDF[]

FDEF[], 85

/* fn 85 equalizes double specified heights below a given ppem size

   CALL[], &lt;rel cvt&gt;, &lt;ppem size&gt;, &lt;abs cvt&gt;, 85 */
   /* Version 2.0 20141201 */

#BEGIN
#PUSHOFF

/* STACK: &lt;rel cvt&gt;, &lt;ppem size&gt;, &lt;abs cvt&gt; */

RCVT[] /* pick absolute (square) height */
#PUSH, 2, 78 /* 2 appears to work for heights and weights */
CALL[]
SWAP[]

/* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;ppem size&gt; */

#PUSH, 79 /* #samples/pixel */
CALL[]
DUP[]
#PUSH, 64
LTEQ[]
IF[] /* #samples/pixel = 1 (or less...) */

    /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;ppem size&gt;, &lt;#samples/pixel&gt; */

    POP[]
    MPPEM[]
    LTEQ[] /* specified ppem size &lt;= actual ppem size ? */
    IF[]

        /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt; */

        #PUSH, 2
        CINDEX[]
        RCVT[] /* pick relative height (overshoot) */
        #PUSH, 1, 78
        CALL[]
        ADD[] /* add overshoot to square height */

        /* STACK: &lt;rel cvt&gt;, &lt;[rel cvt] + [abs cvt]&gt; */

    EIF[]

ELSE[] /* #samples/pixel &gt; 1 */

    /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;ppem size&gt;, &lt;#samples/pixel&gt; */

    SWAP[]
    MPPEM[]
    LTEQ[] /* specified ppem size &lt;= actual ppem size */
    IF[]

      /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;#samples/pixel&gt; */

      #PUSH, 3 /* rel cvt */
      CINDEX[]
      RCVT[]
      DUP[]
      ABS[]
      ROLL[]
      MUL[]
      #PUSH, 64

      /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;[rel cvt]&gt;, &lt;|[rel cvt]| * #samples/pixel&gt;, &lt;1&gt; */

      GTEQ[] /* #samples/pixel greater than or equal to 1 pixel */
      IF[]

          /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;[rel cvt]&gt; */

          #PUSH, 2, 78
          CALL[]
          ADD[] /* add overshoot to square height */

          /* STACK: &lt;rel cvt&gt;, &lt;[rel cvt] + [abs cvt]&gt; */

      ELSE[]

          /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt;, &lt;[rel cvt]&gt; */

          POP[]

          /* STACK: &lt;rel cvt&gt;, &lt;[abs cvt]&gt; */

      EIF[]
    ELSE[]
          /* STACK: &lt;rel cvt&gt;,&lt;abs cvt&gt;,&lt;#samples/pixel&gt;*/
          POP[]
          /* STACK: &lt;rel cvt&gt;,&lt;abs cvt&gt;*/
    EIF[]

EIF[]

/* STACK: &lt;rel cvt&gt;, &lt;[act cvt]&gt; */

WCVTP[] /* make this the round height */
#PUSHON
#END
ENDF[]

FDEF[], 86

/* function to naturally space an accent above or below a base character

   CALL[], &lt;child&gt;, &lt;parent&gt;, &lt;roundMethod&gt;, &lt;minDist?&gt;, &lt;distance&gt;, 86

   convert distance (fUnits) to pixels, round, and space child from parent by result
   this essentially implements the functionality of an MDRP[m&gt;RWh] instrunction for
   composites which lack a suitable implementation of "original" coordinates.
   roundMethod 0, 1, 2, and 3 round down to, to, up to, and to half virtual grid
   function assumes cvt #20 is reserved and can be used temporarily in here... 
   storage 16 contains a threshold ppem size. if zero, ignore the threshold, otherwise
   if less than or equal to threshold, use 64 (26.6) #samples/pixel. */

#BEGIN
#PUSHOFF

/* extract the sign from distance */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;roundMethod&gt;, &lt;minDist?&gt;, &lt;distance&gt; */

DUP[]
#PUSH, 0
LT[]
DUP[]
IF[]
    SWAP[]
    NEG[]
ELSE[]
    SWAP[]
EIF[]

/* scale distance using reserved cvt */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;roundMethod&gt;, &lt;minDist?&gt;, &lt;negDist?&gt;, &lt;|distance|&gt; */

#PUSH, 20, 20 /* reserved cvt */
ROLL[]
WCVTF[]
RCVT[]

/* determine if we are using a size threshold */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;roundMethod&gt;, &lt;minDist?&gt;, &lt;negDist?&gt;, &lt;|distance|'&gt; */

#PUSH, 16, 16 /* reserved storage for threshold */
RS[]
MPPEM[]
ROLL[]
RS[]
LTEQ[]
AND[] /* threshold must not be zero and &lt;= ppem */
IF[]
    #PUSH, 64 /* #samples/pixel = 1 */
ELSE[]
/* round per round method and #samples/pixel in current pv */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;roundMethod&gt;, &lt;minDist?&gt;, &lt;negDist?&gt;, &lt;|distance|'&gt; */

#PUSH, 79 /* #samples/pixel */
CALL[]
EIF[]

SWAP[]
#PUSH, 97, 6 /* round to virtual grid, roundMethod */
MINDEX[]
ADD[]
CALL[] /* round to virtual grid */

/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;minDist?&gt;, &lt;negDist?&gt;, &lt;[|distance|']&gt; */

/* apply minimum distance, if applicable */
ROLL[]
IF[]
    #PUSH, 5 /* minimum distance */
    RS[]
    MAX[]
EIF[]

/* fold the sign back into distance */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;negDist?&gt; &lt;[|distance|']&gt; */

SWAP[]
IF[]
    NEG[]
EIF[]

/* move child by [distance'] */
/* STACK: &lt;child&gt;, &lt;parent&gt;, &lt;[distance']&gt; */

SWAP[]
SRP0[]
MSIRP[m]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 87

/* fn places an accent &lt;c0&gt; &lt;c1&gt; on top of a base character &lt;p0&gt; &lt;p1&gt;
   fn uses the same constraint model as fn 111 (interpolate median),
   except that for composites there is no concept of original coordinates,
   hence the respective values are provided by the caller as &lt;partialFactor&gt;

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, &lt;partialFactor&gt;, 87 */

#BEGIN
#PUSHOFF

/* partialFactor: ((c0 + c1)/2 - p0)/(p1 - p0)
   target median: ((c0 + c1)/2 - p0)*(p1' - p0')/(p1 - p0)&gt; + p0' = partialFactor*(p1' - p0')
   source median: (c0' + c1')/2
   primed coordinates are [N]ew, other coordinates are [O]riginal */

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;p0&gt;, &lt;partialFactor&gt;, &lt;p1&gt; */

#PUSH, 3 /* p0 */
CINDEX[]
MD[N]
MUL[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;p0&gt;, &lt;((c0 + c1)/2 - p0)*(p1' - p0')/(p1 - p0)&gt; */

SWAP[] /* p0 */
GC[N]
ADD[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;targetMedian&gt; */

#PUSH, 79 /* #samples/pixel */
CALL[]
SWAP[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;#samples/pixel&gt;, &lt;targetMedian&gt; */

#PUSH, 4 /* c0 */
CINDEX[]
#PUSH, 4 /* c1 */
CINDEX[]
MD[N]
#PUSH, 3 /* #samples/pixel */
CINDEX[]
MUL[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;#samples/pixel&gt;, &lt;targetMedian&gt;, &lt;numVirtualPixels&gt; */

ODD[]
DUP[]
ADD[]
#PUSH, 98
ADD[]
CALL[] /* round to (half) virtual grid */

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;[targetMedian]&gt; */

#PUSH, 3 /* c0 */
CINDEX[]
DUP[]
SRP0[]
GC[N]
ROLL[] /* c1 */
GC[N]
ADD[]
#PUSH, 32
MUL[]

/* STACK: &lt;c0&gt;, &lt;targetMedian&gt;, &lt;sourceMedian&gt; */

SUB[]

/* STACK: &lt;c0&gt;, &lt;offset&gt; */

MSIRP[m]

#PUSHON
#END
ENDF[]

FDEF[], 88

/* set up storage locations with the x and y components
   of the italic and adjusted italic angles as follows:

     s[ 6] = adjusted italic angle y
     s[ 7] = adjusted italic angle x
     s[10] = italic angle y
     s[11] = italic angle x

   while rendering in b&amp;w, determines the optimal phase
   for positioning italic strokes

     s[ 4] = optimal phase

   CALL[], &lt;riseCvt&gt;, &lt;runCvt&gt;, 88 */

#BEGIN
#PUSHOFF

/* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt; */

#PUSH, 0 /* Use twilight points to calculate stroke angles */
SZPS[]

#PUSH, 2, 3 /* riseCvt */
CINDEX[]
#PUSH, 1, 4 /* runCvt */
CINDEX[]

/* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt;, &lt;2&gt;, &lt;riseCvt&gt;, &lt;1&gt;, &lt;runCvt&gt; */

SVTCA[X] /* Set twilight point 1 with italic run cvt in x */
MIAP[r]

SVTCA[Y] /* Set twilight point 2 with italic rise cvt in y */
MIAP[r]

#PUSH, 1, 2 /* and let the rasterizer do the math */
SPVTL[r]
GPV[]

#PUSH, 10 /* store the x and y components of the italic angle */
SWAP[]
NEG[]     /* notice that since we're essentially setting the pv to a line  */
WS[]      /* from (runCvt,0) to (0,riseCvt), the calculcated pv will be    */
#PUSH, 11 /* proportional to (runCvt,0) - (0,riseCvt) = (runCvt,-riseCvt). */
SWAP[]    /* Hence we have to mirror the result at the base line, which is */
WS[]      /* done by flipping (negating) the sign of the y component here. */

/* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt; */

#PUSH, 2, 3 /* riseCvt */
CINDEX[]
#PUSH, 1, 4 /* runCvt */
CINDEX[]

SVTCA[X] /* same for the adjusted italic angle */
MIAP[R]  /* except to round the twilight point in x... */

SVTCA[Y]
MIAP[R]  /* ...and in y */

#PUSH, 1, 2
SPVTL[r]
GPV[]

#PUSH, 6
SWAP[]
NEG[]    /* same neg as above */
WS[]
#PUSH, 7
SWAP[]
WS[]

#PUSH, 1 /* restore graphics state */
SZPS[]

/* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt; */

#PUSH, 0, 2
RS[]
EQ[]
IF[] /* running b&amp;w? */

    /* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt; */
    /* determine adjusted run' = run*[rise]/rise */

    RCVT[]
    SWAP[]
    RCVT[]
    DUP[]
    RTG[]
    ROUND[Bl]
    ROLL[]
    MUL[]
    SWAP[]
    DIV[]

    /* STACK: &lt;run'&gt; */
    /* determine phase = (run' - [run'])/2 = half the rounding error */

    DUP[]
    DUP[]
    #PUSH, 64
    LT[]
    IF[]
        CEILING[] /* optimize for "minimum italic angle" */
    ELSE[]
        FLOOR[] /* optimize for minimal number of jaggies */
    EIF[]
    SUB[]
    #PUSH, 32
    MUL[]

    /* STACK: &lt;phase&gt; */
    /* for its use on bottom italic edge, determine complement to full pixel */

    #PUSH, 64
    SWAP[]
    SUB[]

    /* and store in s[4] */

    #PUSH, 4
    SWAP[]
    WS[]

    /* STACK: */

ELSE[]

    /* STACK: &lt;riseCvt&gt;, &lt;runCvt&gt; */

    #PUSH, 4, 0
    WS[]
    POP[]
    POP[]

    /* STACK: */

EIF[]

RTG[]
SVTCA[X]

#PUSHON
#END
ENDF[]

FDEF[], 89

/* function rounds &lt;cvt&gt; depending on rendering environment and pv

   CALL[], &lt;cvt&gt;, 89 */

#BEGIN
#PUSHOFF

DUP[]
RCVT[]
#PUSH, 0, 78 /* roundDist */
CALL[]
WCVTP[]

#PUSHON
#END
ENDF[]

FDEF[], 90

/* below &lt;ppem&gt;: make both children the same as the (averaged) parent cvt
   at and above: calculate child cvt &lt;ch0&gt; as &lt;fraction&gt; of child cvt &lt;ch1&gt;

   CALL[], &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;ch1&gt;, &lt;ppem&gt;, 90 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;ch1&gt;, &lt;ppem&gt; */

MPPEM[]
LTEQ[]
#PUSH, 64, 79 /* #samples/pixel */
CALL[]
LT[]
OR[]
IF[] /* at or above ppem limit or rounding to less than a pixel */ 

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;ch1&gt; */

    DUP[]
    RCVT[]
    #PUSH, 1, 78 /* roundDist */
    CALL[]
    DUP[]
    ROLL[]
    ROLL[]

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;[ch1]&gt;, &lt;ch1&gt;, &lt;[ch1]&gt; */

    WCVTP[]

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;[ch1]&gt; */

    DUP[]
    #PUSH, 64, 4
    MINDEX[]
    SUB[]
    MUL[]
    SUB[]
    #PUSH, 1, 78 /* roundDist */
    CALL[]

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;[ch1] - [ch1]*(1-fraction)&gt; */

    WCVTP[]
    POP[] /* parent not involved */

    /* STACK: */

ELSE[]

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;fraction&gt;, &lt;ch1&gt; */

    SWAP[]
    POP[] /* fraction not involved */

    /* STACK: &lt;p&gt;, &lt;ch0&gt;, &lt;ch1&gt; */

    ROLL[]
    RCVT[]
    #PUSH, 1, 78 /* roundDist */
    CALL[]

    /* STACK: &lt;ch0&gt;, &lt;ch1&gt;, &lt;[p]&gt; */

    DUP[]
    ROLL[]
    SWAP[]

    /* STACK: &lt;ch0&gt;, &lt;[p]&gt;, &lt;ch1&gt;, &lt;[p]&gt; */

    WCVTP[]
    WCVTP[]

    /* STACK: */

EIF[]

#PUSHON
#END
ENDF[]

FDEF[], 91

/* below &lt;ppem&gt;: make child cvt &lt;ch&gt; the same as parent cvt &lt;p&gt;
   at and above: calculate child cvt &lt;ch&gt; as &lt;fraction&gt; of parent cvt &lt;p&gt;

   CALL[], &lt;ch&gt;, &lt;fraction&gt;, &lt;p&gt;, &lt;ppem&gt;, 91 */

#BEGIN
#PUSHOFF

/* STACK: &lt;ch&gt;, &lt;fraction&gt;, &lt;p&gt;, &lt;ppem&gt; */

MPPEM[]
LTEQ[]
#PUSH, 64, 79 /* #samples/pixel */
CALL[]
LT[]
OR[]
IF[] /* at or above ppem limit or rounding to less than a pixel */ 

    /* STACK: &lt;ch&gt;, &lt;fraction&gt;, &lt;p&gt; */

    RCVT[]
    DUP[]
    ROLL[]

    /* STACK: &lt;ch&gt;, &lt;[p]&gt;, &lt;[p]&gt;, &lt;fraction&gt; */

    #PUSH, 64
    SUB[]
    MUL[]
    ADD[]

    /* STACK: &lt;ch&gt;, &lt;[p] + [p]*(fraction - 1)&gt; */

ELSE[]

    /* STACK: &lt;ch&gt;, &lt;fraction&gt;, &lt;p&gt; */

    SWAP[]
    POP[] /* fraction not involved */

    RCVT[]

    /* STACK: &lt;ch&gt;, [p] */

EIF[]

#PUSH, 1, 78 /* roundDist */
CALL[]
WCVTP[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 92

/* function to calculate a child cvt &lt;ch&gt;
   as a &lt;blend&gt; of two parent cvts &lt;p0&gt;, &lt;p1&gt;

   CALL[], &lt;ch&gt;, &lt;blend&gt;, &lt;p0&gt;, &lt;p1&gt;, 92 */

#BEGIN
#PUSHOFF

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;p0&gt;, &lt;p1&gt; */

SWAP[]
RCVT[]
DUP[]

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;p1&gt;, &lt;[p0]&gt;, &lt;[p0]&gt; */

ROLL[]
RCVT[]

SWAP[]
SUB[]

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt; */

DUP[]
ABS[]
#PUSH, 64
LTEQ[]

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;contrast &lt;= 1 pixel(s)?&gt; */

#PUSH, 4
CINDEX[]
DUP[]
#PUSH, 0
GTEQ[]
SWAP[]
#PUSH, 64
LTEQ[]
AND[]

AND[]

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;contrast &lt;= 1 pixel(s) &amp;&amp; blend &gt;= 0 &amp;&amp; blend &lt;= 64?&gt; */

#PUSH, 64, 79 /* #samples/pixel */
CALL[]
EQ[]

AND[]

/* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;contrast &lt;= 1 pixel(s) &amp;&amp; blend &gt;= 0 &amp;&amp; blend &lt;= 64 &amp;&amp; rounding to full pixel?&gt; */

IF[]

    /* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt; */

    ROLL[]
    GPV[]
    ABS[]
    SWAP[]
    ABS[]
    SWAP[]

    /* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend&gt;, &lt;|pv.x|&gt;, &lt;|pv.y|&gt; */

    GTEQ[] /* pv closer to x? */
    IF[]

        /* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend&gt; */
        /* bias towards p1: blend' := 1 - (1 - blend)² */

        #PUSH, 64, 64
        ROLL[]
        SUB[]
        DUP[]
        MUL[]
        SUB[]

        /* &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;1 - (1 - blend)²&gt; */

    ELSE[]

        /* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend&gt; */
        /* bias towards p0: blend' := blend² */

        DUP[]
        MUL[]

    /* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend²&gt; */

    EIF[]

ELSE[]

    /* STACK: &lt;ch&gt;, &lt;blend&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt; */
    /* use unbiased blend */

    ROLL[]

    /* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend&gt; */

EIF[]

/* STACK: &lt;ch&gt;, &lt;[p0]&gt;, &lt;[p1] - [p0]&gt;, &lt;blend&gt; */

MUL[]
#PUSH, 2, 78 /* roundDist */
CALL[]
ADD[]

/* STACK: &lt;ch&gt;, &lt;[ch]&gt; */

WCVTP[]

#PUSHON
#END
ENDF[]

FDEF[], 93

/* fn sets vectors to X (used in calculated calls)

   CALL[], 93 */

#BEGIN
#PUSHOFF
SVTCA[X]
#PUSHON
#END
ENDF[]

FDEF[], 94

/* fn sets vectors to Y (used in calculated calls)

   CALL[], 94 */

#BEGIN
#PUSHOFF
SVTCA[Y]
#PUSHON
#END
ENDF[]

FDEF[], 95

/* Set fv to X, pv perpendicular to italic angle (used in calculated calls)

   CALL[], 95 */

#BEGIN
#PUSHOFF
SFVTCA[X]
#PUSH, 11, 10
RS[]
SWAP[]
RS[]
NEG[]
SPVFS[]
#PUSHON
#END
ENDF[]

FDEF[], 96

/* Set fv to italic angle, pv to Y (used in calculated calls)

   CALL[], 96 */

#BEGIN
#PUSHOFF
#PUSH, 10, 11
RS[]
SWAP[]
RS[]
SFVFS[]
SPVTCA[Y]
#PUSHON
#END
ENDF[]

FDEF[], 97

/* round down to virtual grid

   CALL[], &lt;#samples/pixel&gt;, &lt;argument&gt;, 97

   returns with rounded argument on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;#samples/pixel&gt;, &lt;argument&gt; */
/* upscale argument by #samples/pixel */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
MUL[]

/* do the rounding in upscaled domain */

FLOOR[] /* round down to super grid */

/* Downscaling uses a DIV[] operation, which is implemented as floor(numerator/denominator).
   For round(numerator/denominator) instead, add ½ denominator to numerator before dividing.
   But since the division in 26.6 has to multiply the numerator by 2^6 (64) before dividing,
   we have to divide said ½ denominator by 64 before adding, hence the 8192 (= 128 in 26.6). */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
#PUSH, 8192
DIV[]
ADD[]

/* downscale rounded and adjusted argument */

SWAP[] /* #samples/pixel */
DIV[]

/* STACK: &lt;[argument]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 98

/* round to virtual grid

   CALL[], &lt;#samples/pixel&gt;, &lt;argument&gt;, 98

   returns with rounded argument on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;#samples/pixel&gt;, &lt;argument&gt; */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
MUL[]

/* do the rounding in upscaled domain */

#PUSH, 32 /* round to super grid */
ADD[]
FLOOR[]

/* see above for adjustments below */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
#PUSH, 8192
DIV[]
ADD[]

/* downscale rounded and adjusted argument */

SWAP[] /* #samples/pixel */
DIV[]

/* STACK: &lt;[argument]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 99

/* round up to virtual grid

   CALL[], &lt;#samples/pixel&gt;, &lt;argument&gt;, 99

   returns with rounded argument on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;#samples/pixel&gt;, &lt;argument&gt; */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
MUL[]

/* do the rounding in upscaled domain */

CEILING[] /* round up to super grid */

/* see above for adjustments below */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
#PUSH, 8192
DIV[]
ADD[]

/* downscale rounded and adjusted argument */

SWAP[] /* #samples/pixel */
DIV[]

/* STACK: &lt;[argument]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 100

/* round to half virtual grid

   CALL[], &lt;#samples/pixel&gt;, &lt;argument&gt;, 100

   returns with rounded argument on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;#samples/pixel&gt;, &lt;argument&gt; */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
MUL[]

/* do the rounding in upscaled domain */

FLOOR[]
#PUSH, 32 /* round to half super grid */
ADD[]

/* see above for adjustments below */

#PUSH, 2 /* #samples/pixel */
CINDEX[]
#PUSH, 8192
DIV[]
ADD[]

/* downscale rounded and adjusted argument */

SWAP[] /* #samples/pixel */
DIV[]

/* STACK: &lt;[argument]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 101

/* determine actual distance to be used for emulating MDRP[&lt;]
   instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, 101

   returns with rounded distance on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt; */

SWAP[]
MD[O]

/* round without minDist */

#PUSH, 2, 78 /* roundDist */
CALL[]

/* STACK: &lt;[w]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 102

/* determine actual distance to be used for emulating MDRP[&gt;]
   instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, 102

   returns with rounded distance on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt; */

SWAP[]
MD[O]

/* round with minDist */

#PUSH, 1, 78 /* roundDist */
CALL[]

/* STACK: &lt;[w]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 103

/* determine actual distance to be used for emulating MIRP[&lt;]
   instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, 103

   returns with rounded distance on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt; */

SWAP[] /* c */
ROLL[] /* p */
MD[O]
SWAP[] /* cvt */

/* STACK: &lt;wNat&gt;, &lt;cvt&gt; */
/* do cvt cut-in test */

RCVT[]
ABS[]
#PUSH, 2
CINDEX[]
ABS[]
#PUSH, 2
CINDEX[]
SUB[]
ABS[]
#PUSH, 3 /* cvt cut-in */
RS[]

/* STACK: &lt;wNat&gt;, &lt;|wCvt|&gt;, &lt;||wNat| - |wCvt||&gt;, &lt;cvt cut-in&gt; */

GT[]
IF[]

    /* STACK: &lt;wNat&gt;, &lt;|wCvt|&gt; */
    /* cvt cut-in test failed */

    POP[]
    DUP[]
    ABS[]

    /* else cvt cut-in test succeeded */

EIF[]

/* STACK: &lt;wNat&gt;, &lt;|w|&gt; */
/* round without minDist */

#PUSH, 2, 78 /* roundDist */
CALL[]

/* STACK: &lt;wNat&gt;, &lt;[w]&gt; */
/* inherit sign from wNat */

SWAP[]
#PUSH, 0
LT[]
IF[]
    NEG[]
EIF[]

/* STACK: &lt;[w]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 104

/* determine actual distance to be used for emulating MIRP[&gt;]
   instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, 104

   returns with rounded distance on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt; */

SWAP[] /* c */
ROLL[] /* p */
MD[O]
SWAP[] /* cvt */

/* STACK: &lt;wNat&gt;, &lt;cvt&gt; */
/* do cvt cut-in test */

RCVT[]
ABS[]
#PUSH, 2
CINDEX[]
ABS[]
#PUSH, 2
CINDEX[]
SUB[]
ABS[]
#PUSH, 3 /* cvt cut-in */
RS[]

/* STACK: &lt;wNat&gt;, &lt;|wCvt|&gt;, &lt;||wNat| - |wCvt||&gt;, &lt;cvt cut-in&gt; */

GT[]
IF[]

    /* STACK: &lt;wNat&gt;, &lt;|wCvt|&gt; */
    /* cvt cut-in test failed */

    POP[]
    DUP[]
    ABS[]

    /* else cvt cut-in test succeeded */

EIF[]

/* STACK: &lt;wNat&gt;, &lt;|w|&gt; */
/* round with minDist */

#PUSH, 1, 78 /* roundDist */
CALL[]

/* STACK: &lt;wNat&gt;, &lt;[w]&gt; */
/* inherit sign from wNat */

SWAP[]
#PUSH, 0
LT[]
IF[]
    NEG[]
EIF[]

/* STACK: &lt;[w]&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 105

/* emulate MDRP[&lt;] instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, 105 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt; */

DUP[] /* c */
#PUSH, 3 /* p */
CINDEX[]
MD[O]
#PUSH, 2, 78 /* roundDist */
CALL[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;[dist]&gt; */

ROLL[]
SRP0[]
MSIRP[M]

#PUSHON
#END
ENDF[]

FDEF[], 106

/* emulate MDRP[&gt;] instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, 106 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt; */

DUP[] /* c */
#PUSH, 3 /* p */
CINDEX[]
MD[O]
#PUSH, 1, 78 /* roundDist */
CALL[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;[dist]&gt; */

ROLL[]
SRP0[]
MSIRP[M]

#PUSHON
#END
ENDF[]

FDEF[], 107

/* emulate MIRP[&lt;] instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, 107 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt; */

#PUSH, 3 /* p */
CINDEX[]
#PUSH, 3 /* c */
CINDEX[]
ROLL[] /* cvt */
#PUSH, 103 /* resActDist, cvt, noMinDist */
CALL[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;[dist]&gt; */

ROLL[]
SRP0[]
MSIRP[M]

#PUSHON
#END
ENDF[]

FDEF[], 108

/* emulate MIRP[&gt;] instruction with rendering environment specific rounding

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, 108 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt; */

#PUSH, 3 /* p */
CINDEX[]
#PUSH, 3 /* c */
CINDEX[]
ROLL[] /* cvt */
#PUSH, 104 /* resActDist, cvt, minDist */
CALL[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;[dist]&gt; */

ROLL[]
SRP0[]
MSIRP[M]

#PUSHON
#END
ENDF[]

FDEF[], 109

/* fn symmetrically constrains a stroke &lt;p&gt;, &lt;c&gt; with &lt;cvt&gt;

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, 109 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt; */
/* determine old median */

#PUSH, 3 /* &lt;p&gt; */
CINDEX[]
GC[N]
#PUSH, 3 /* &lt;c&gt; */
CINDEX[]
GC[N]
ADD[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, &lt;2*median&gt; */
/* lock parent */

#PUSH, 4 /* p */
CINDEX[]
MDAP[r]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, &lt;2*median&gt; */
/* link child */

#PUSH, 4 /* p */
CINDEX[]
#PUSH, 4 /* c */
CINDEX[]
#PUSH, 4 /* cvt */
MINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 106 /* resMIRP, noCvt, minDist */
ELSE[]
    #PUSH, 108 /* resMIRP, cvt, minDist */
EIF[]
CALL[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;2*median&gt; */
/* determine new median */

#PUSH, 3 /* &lt;p&gt; */
CINDEX[]
GC[N]
#PUSH, 3 /* &lt;c&gt; */
CINDEX[]
GC[N]
ADD[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;2*median&gt;, &lt;2*median'&gt; */

SUB[]
#PUSH, 128
DIV[] /* floor to 1/64 for now */

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;deltaMedian&gt; */

DUP[]
ROLL[]
DUP[]
SRP0[]
SWAP[]
MSIRP[m]
SWAP[]
DUP[]
SRP0[]
SWAP[]
MSIRP[m]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 110

/* calculate offset for emulation of interpolation of median of
   &lt;c0&gt; and &lt;c1&gt; between parents &lt;p0&gt; and &lt;p1&gt; using current pv and fv

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, 110

   returns with offset on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt; */

#PUSH, 3 /* c0 */
CINDEX[]
GC[O]
#PUSH, 3 /* c1 */
CINDEX[]
GC[O]
ADD[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, &lt;c0 + c1&gt; */

#PUSH, 5 /* p0 */
CINDEX[]
GC[O]
#PUSH, 128
MUL[]
SUB[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, &lt;c0 + c1 - 2*p0&gt; */

#PUSH, 2 /* p1 */
CINDEX[]
#PUSH, 6 /* p0 */
CINDEX[]
MD[N]
MUL[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, &lt;(c0 + c1 - 2*p0)*(p1' - p0')&gt; */

SWAP[] /* p1 */
#PUSH, 5 /* p0 */
CINDEX[]
MD[O]
#PUSH, 128
MUL[]

/* prevent inadvertent divide-by-zero e.g. on non-spacing glyphs */
DUP[]
IF[]
    DIV[]
ELSE[]
    POP[]
EIF[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;(c0 + c1 - 2*p0)*(p1' - p0')/(2*(p1 - p0))&gt; */

#PUSH, 4 /* p0 */
MINDEX[]
GC[N]
ADD[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;(c0'' + c1'')/2&gt; */

ROLL[] /* c0 */
GC[N]
ROLL[] /* c1 */
GC[N]
ADD[]
#PUSH, 32
MUL[]

/* STACK: &lt;(c0'' + c1'')/2&gt;, &lt;(c0' + c1')/2&gt; */

SUB[]

/* STACK: &lt;offset&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 111

/* emulate interpolation of median of &lt;c0&gt; and &lt;c1&gt;
   between parents &lt;p0&gt; and &lt;p1&gt; using current pv and fv

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt;, 111 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;p1&gt; */

#PUSH, 4 /* p0 */
MINDEX[]
#PUSH, 4 /* c0 */
CINDEX[]
#PUSH, 4 /* c1 */
CINDEX[]
#PUSH, 4 /* p1 */
MINDEX[]
#PUSH, 110 /* calc offset for interpolation of median */
CALL[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;offset&gt; */

DUP[]

/* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;offset&gt;, &lt;offset&gt; */

ROLL[]
DUP[]
SRP0[]
SWAP[]

/* STACK: &lt;c0&gt;, &lt;offset&gt;, &lt;c1&gt;, &lt;offset&gt; */

MSIRP[m]

SWAP[]
DUP[]
SRP0[]
SWAP[]

/* STACK: &lt;c0&gt;, &lt;offset&gt; */

MSIRP[m]

#PUSHON
#END
ENDF[]

FDEF[], 112


/* adjust (unrounded) stroke phase to target phase according to &lt;method&gt;

   method 0: round to nearest virtual pixel
   method 1: apply method 2 below 2 pixel wide strokes else method 0
   method 2: optimize for max #black pixels
   method 3: optimize for one edge aligned

   right?: boolean indicating a left (false) or right (true) stroke)

   CALL[], &lt;phase&gt;, &lt;weight&gt;, &lt;method&gt;, &lt;right?&gt;, 112

   returns with (rounded) adjusted phase on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;phase&gt;, &lt;weight&gt;, &lt;method&gt;, &lt;right?&gt; */

SWAP[]

DUP[]
#PUSH, 1
EQ[]
IF[]

    /* STACK: &lt;phase&gt;, &lt;weight&gt;, &lt;right?&gt;, &lt;method&gt; */
    /* replace method depending on stroke weight */

    POP[]
    #PUSH, 2 /* weight */
    CINDEX[]
    #PUSH, 2, 78 /* roundDist */
    CALL[]
    #PUSH, 128
    LT[]
    DUP[]
    ADD[]
EIF[]

DUP[]
ADD[]
ADD[]

/* STACK: &lt;phase&gt;, &lt;weight&gt;, &lt;method' = 2*method + right&gt; */

DUP[]
#PUSH, 1
LTEQ[]
IF[] /* just round to nearest virtual pixel */

    POP[]
    POP[]

    /* STACK: &lt;phase&gt; */

ELSE[]
    DUP[]
    #PUSH, 5
    LTEQ[]
    IF[] /* optimize for max #black pixels */

        POP[]

        /* STACK: &lt;phase&gt;, &lt;weight&gt; */

        DUP[]
        FLOOR[]
        SUB[]

        /* STACK: &lt;phase&gt;, &lt;fractWeight&gt; */

        #PUSH, 64
        SWAP[]
        SUB[]

        /* STACK: &lt;phase&gt;, &lt;1-fractWeight&gt; */

        #PUSH, 0, 3 /* phase */
        CINDEX[]
        LT[]
        #PUSH, 3 /* phase */
        CINDEX[]
        #PUSH, 3 /* 1-fractWeight */
        CINDEX[]
        LT[]
        AND[]
        IF[] /* if 0 &lt; phase &lt; 1-fractWeight then need to adjust phase */

            /* STACK: &lt;phase&gt;, &lt;1-fractWeight&gt; */

            DUP[]
            #PUSH, 3
            CINDEX[]
            SUB[]

            /* STACK: &lt;phase&gt;, &lt;1-fractWeight&gt;, &lt;1-fractWeight-phase&gt; */

            ROLL[]
            GTEQ[]
            IF[] /* error from phase to 1-fractWeight &gt;= error from 0 to phase */
                POP[]
                #PUSH, 0 /* target 0 as phase */
            EIF[]
            /* else target 1-fractWeight as phase, which is what's left on stack */

        ELSE[]

            /* STACK: &lt;phase&gt;, &lt;1-fractWeight&gt; */

            POP[]

        EIF[]

    ELSE[] /* optimize for one edge aligned */

        /* STACK: &lt;phase&gt;, &lt;weight&gt;, &lt;method'&gt; */

        #PUSH, 7
        EQ[]
        IF[] /* right flush */

            /* STACK: &lt;phase&gt;, &lt;weight&gt; */

            DUP[]
            FLOOR[]
            SUB[]

            /* STACK: &lt;phase&gt;, &lt;fractWeight&gt; */

            NEG[]
            SWAP[]
            POP[]

        ELSE[] /* left flush (and default) */

            /* STACK: &lt;phase&gt;, &lt;weight&gt; */

            POP[]
            POP[]
            #PUSH, 0

        EIF[]

    EIF[]

EIF[]

#PUSH, 2, 78 /* roundDist */
CALL[]

/* STACK: phase */

#PUSHON
#END
ENDF[]

FDEF[], 113

/* fn calculates delta phase for optimal position of
   stroke bordered by &lt;p&gt; and &lt;c&gt; according to &lt;method&gt;
   (see fn 112 for definition of method)

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;method&gt;, 113

   returns with delta phase in interval ]-½,+½] on stack */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;method&gt; */

    /* use sequence of parameters &lt;p&gt; and &lt;c&gt; to determine if this is
       a "left" stroke (in which case we may add grey to the right), or
       a "right" stroke (in which case we may add grey to the left) */

#PUSH, 2 /* c */
CINDEX[]
#PUSH, 4 /* p */
CINDEX[]
MD[O]
#PUSH, 0
GTEQ[]
IF[]
    #PUSH, 0 /* "left" stroke */
ELSE[]
    ROLL[]
    ROLL[]
    SWAP[]
    ROLL[]
    #PUSH, 1 /* "right" stroke */
EIF[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;method&gt;, &lt;right?&gt; */

#PUSH, 4 /* p */
CINDEX[]
GC[N]
DUP[]
FLOOR[]
SUB[]
DUP[]

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;method&gt;, &lt;right?&gt;, &lt;source phase&gt;, &lt;source phase&gt; */

#PUSH, 5 /* c */
MINDEX[]
#PUSH, 6 /* p */
MINDEX[]
MD[N]

/* STACK: &lt;method&gt;, &lt;right?&gt;, &lt;source phase&gt;, &lt;source phase&gt;, &lt;weight&gt; */

#PUSH, 5 /* method */
MINDEX[]
#PUSH, 5 /* right? */
MINDEX[]
#PUSH, 112 /* adjust to target stroke phase */
CALL[]

/* STACK: &lt;source phase&gt;, &lt;target phase&gt; */

SWAP[]
SUB[]

/* STACK: &lt;delta phase&gt; */
/* minimze phase into interval ]-½,+½] */

NEG[]
#PUSH, 32
ADD[]
DUP[]
FLOOR[]
SUB[]
#PUSH, 32
SUB[]
NEG[]

#PUSHON
#END
ENDF[]

FDEF[], 114

/* emulate MIAP instruction with rendering environment specific rounding

   CALL[], &lt;c&gt;, &lt;cvt&gt;, 114 */

#BEGIN
#PUSHOFF

/* STACK: &lt;c&gt;, &lt;cvt&gt; */

#PUSH, 2 /* c */
CINDEX[]
GC[N]
DUP[]

/* STACK: &lt;c&gt;, &lt;cvt&gt;, &lt;wNat&gt;, &lt;wNat&gt; */

ROLL[]
DUP[]
#PUSH, 0
LT[]
IF[]

    /* STACK: &lt;c&gt;, &lt;wNat&gt;, &lt;wNat&gt;, &lt;cvt&gt; */

    POP[]

    /* cvt &lt; 0 (no cvt used) =&gt; w = wNat */
    /* STACK: &lt;c&gt;, &lt;wNat&gt;, &lt;w&gt; */

    #PUSH, 2, 78 /* roundDist */
    CALL[]

ELSE[]

    RCVT[]

    /* STACK: &lt;c&gt;, &lt;wNat&gt;, &lt;wNat&gt;, &lt;wCvt&gt; */
    /* no cvt cut-in test (for eventual support of automatic small caps, superiors, and inferiors), pop wNat to use wCvt */

    SWAP[]
    POP[]

    /* leave value as rounded by cpgm */
    /* STACK: &lt;c&gt;, &lt;wNat&gt;, &lt;w&gt; */

EIF[]

SUB[]
NEG[]

/* STACK: &lt;c&gt;, &lt;wDelta&gt; */

#PUSH, 2
CINDEX[]
SRP0[]

MSIRP[M]

#PUSHON
#END
ENDF[]

FDEF[], 115

/* interpolates a point &lt;p&gt; in &lt;dirFlag&gt; between points &lt;lsb&gt; and &lt;rsb&gt;
   dirFlag: postRoundFlag*8 + dir
   dir: X = 0, Y = 1, X/ = 2, Y/ = 3, ...

   depending on rendering environment and pv may optimise point position

   CALL[], &lt;dirFlag&gt;, &lt;p0&gt;, &lt;c&gt;, &lt;p1&gt;, 115 */

#BEGIN
#PUSHOFF

/* STACK: &lt;dirFlag&gt;, &lt;p0&gt;, &lt;p&gt;, &lt;p1&gt; */
/* separate postRoundFlag from dir */

#PUSH, 4 /* dirFlag */
MINDEX[]
DUP[]
#PUSH, 512
DIV[]
DUP[]
#PUSH, 512
MUL[]
ROLL[]
SWAP[]
SUB[]

/* STACK:, &lt;p0&gt;, &lt;p&gt;, &lt;p1&gt;, &lt;postRoundFlag&gt;, &lt;dir&gt; */

DUP[]
#PUSH, 93 /* setV */
ADD[]
CALL[]

/* STACK: &lt;p0&gt;, &lt;p&gt;, &lt;p1&gt;, &lt;postRoundFlag&gt;, &lt;dir&gt; */

#PUSH, 5 /* p0 */
CINDEX[]
SRP1[]
ROLL[] /* p1 */
SRP2[]
ROLL[] /* p */
DUP[]
IP[]

/* STACK: &lt;p0&gt;, &lt;postRoundFlag&gt;, &lt;dir&gt;, &lt;p&gt; */

ROLL[] /* postRoundFlag */
IF[]

    /* STACK: &lt;p0&gt;, &lt;dir&gt;, &lt;p&gt; */

    #PUSH, 93, 4096, 4 /* setV, 64, dir */
    MINDEX[]
    MUL[]
    ODD[]
    ADD[]
    CALL[]

    /* STACK: &lt;p0&gt;, &lt;p&gt; */

    SWAP[]
    POP[]
    DUP[] /* p */
    SRP0[]
    DUP[]
    GC[N]
    DUP[]
    #PUSH, 2, 78 /* roundDist */
    CALL[]
    SWAP[]
    SUB[]

    /* STACK: &lt;p&gt;, &lt;[p.c]-p.c&gt; */

ELSE[]

    /* STACK: &lt;p0&gt;, &lt;dir&gt;, &lt;p&gt; */

    SWAP[]
    POP[]

    /* STACK: &lt;p0&gt;, &lt;p&gt; */

    DUP[]
    ROLL[]
    DUP[] /* p0 */
    SRP0[]
    MD[N]

    #PUSH, 2, 78 /* roundDist */
    CALL[]

    /* STACK: &lt;p&gt;, &lt;[p.dist]&gt; */

EIF[]

MSIRP[M]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 116

/* constrains a stroke in &lt;dir&gt;, defined by parent &lt;p&gt; and child &lt;c&gt;,
   and by cvt &lt;cvt&gt;, and interpolates it between points &lt;gp0&gt; and &lt;gp1&gt;
   dir: X = 0, Y = 1, X/ = 2
   sof: (stroke optimization flags ||, |&lt;, and &gt;| ) don't = 0, do = 1, leftBias = 2, rightBias = 3

   CALL[], &lt;dir&gt;, &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, &lt;gp1&gt;, &lt;sof&gt;, 116 */

#BEGIN
#PUSHOFF

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;cvt&gt;, &lt;gp1&gt;, &lt;sof&gt; */

#PUSH, 93, 4096, 9 /* setV, 64, dir */
CINDEX[]
MUL[]
ODD[]
ADD[]
CALL[]

/* constrain stroke */

#PUSH, 5 /* p */
CINDEX[]
#PUSH, 5 /* c */
CINDEX[]
#PUSH, 5 /* cvt */
MINDEX[]
#PUSH, 109 /* symDist */
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */

#PUSH, 93, 7 /* setV, dir */
CINDEX[]
ADD[]
CALL[]

#PUSH, 5 /* gp0 */
CINDEX[]
#PUSH, 5 /* p */
CINDEX[]
#PUSH, 5 /* c */
CINDEX[]
#PUSH, 5 /* gp1 */
CINDEX[]
#PUSH, 111 /* interpolate median */
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */

#PUSH, 93, 4096, 8 /* setV, 64, dir */
MINDEX[]
MUL[]
ODD[]
ADD[]
CALL[]

/* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */

DUP[]
#PUSH, 0
GT[]
IF[] /* optimize stroke position */

    #PUSH, 80
    CALL[]

    /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt;, &lt;som&gt; */

    #PUSH, 5 /* p */
    CINDEX[]
    #PUSH, 5 /* c */
    CINDEX[]
    #PUSH, 7 /* p */
    CINDEX[]
    #PUSH, 7 /* c */
    CINDEX[]
    #PUSH, 5 /* som */
    CINDEX[]
    #PUSH, 113 /* get delta phase for optimal stroke position */
    CALL[]
    #PUSH, 2
    SLOOP[]
    SHPIX[]

    /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt;, &lt;som&gt; */

    #PUSH, 0
    GT[]
    #PUSH, 2 /* sof */
    CINDEX[]
    #PUSH, 1
    GT[]
    AND[]
    IF[]

        /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */
        /* determine total side-bearing space to see if we need to bias the black body */

        #PUSH, 4 /* p */
        CINDEX[]
        #PUSH, 6 /* gp0 */
        CINDEX[]
        MD[N]
        #PUSH, 3 /* gp1 */
        CINDEX[]
        #PUSH, 5 /* c */
        CINDEX[]
        MD[N]
        ADD[]
        DUP[]
        #PUSH, 64
        GT[]
        IF[]

            /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt;, &lt;totSBS&gt; */
            /* enough total side-bearing space left, leave it alone */
            POP[]

        ELSE[]

            /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt;, &lt;totSBS&gt; */
            /* 1 pixel or less total side-bearing space left */

            #PUSH, 0
            GT[]
            IF[]

                /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */
                /* any total side-bearing space left at all */

                DUP[]
                #PUSH, 2
                EQ[]
                IF[]

                    /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */
                    /* move stroke flush left */

                    #PUSH, 4 /* p */
                    CINDEX[]
                    #PUSH, 4 /* c */
                    CINDEX[]
                    #PUSH, 7 /* gp0 */
                    CINDEX[]
                    #PUSH, 7 /* p */
                    CINDEX[]
                    MD[N]
                    #PUSH, 2
                    SLOOP[]
                    SHPIX[]

                ELSE[]

                    /* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */
                    /* move stroke flush left */

                    #PUSH, 4 /* p */
                    CINDEX[]
                    #PUSH, 4 /* c */
                    CINDEX[]
                    #PUSH, 4 /* gp1 */
                    CINDEX[]
                    #PUSH, 6 /* c */
                    CINDEX[]
                    MD[N]
                    #PUSH, 2
                    SLOOP[]
                    SHPIX[]

                EIF[]

            EIF[]

        EIF[]

    EIF[]

EIF[]

/* STACK: &lt;gp0&gt;, &lt;p&gt;, &lt;c&gt;, &lt;gp1&gt;, &lt;sof&gt; */

POP[]
POP[]
POP[]
POP[]
POP[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 117

/* fn tries to place and constrain two strokes &lt;p0,c0,cvt0&gt; and &lt;p1,c1,cvt1&gt;
   between grandparents &lt;gp0&gt; and &lt;gp1&gt; in direction &lt;dir&gt;
   dir: X = 0, Y = 1, X/ = 2
   X/ (italic) is not yet implemented; to do so properly will need to factor
   the italic phase optimization part out of fn 131 and make it available to
   this fn.   

   CALL[], &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, 117 */

#BEGIN
#PUSHOFF

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt; */

#PUSH, 93, 4096, 11 /* setV, dir */
CINDEX[]
MUL[]
ODD[]
ADD[]
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt; */
/* interpolate black body */

#PUSH, 7 /* p0 */
CINDEX[]
#PUSH, 7 /* c0 */
CINDEX[]
#PUSH, 6 /* p1 */
CINDEX[]
#PUSH, 6 /* c1 */
CINDEX[]
#PUSH, 12 /* gp0 */
CINDEX[]
#PUSH, 12 /* p0 */
CINDEX[]
#PUSH, 9 /* c1 */
CINDEX[]
#PUSH, 8 /* gp1 */
CINDEX[]
#PUSH, 110 /* calc offset for interpolation of median */
CALL[]
#PUSH, 4
SLOOP[]
SHPIX[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt; */
/* constrain stroke0 */

#PUSH, 7 /* p0 */
CINDEX[]
#PUSH, 7 /* c0 */
CINDEX[]
#PUSH, 7 /* cvt0 */
MINDEX[]
#PUSH, 109 /* symDist */
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt; */
/* constrain stroke1 */

#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 4 /* c1 */
CINDEX[]
#PUSH, 4 /* cvt1 */
MINDEX[]
#PUSH, 109 /* symDist */
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt; */

#PUSH, 80
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
/* determine phase0 for optimal position of stroke0 */

#PUSH, 6 /* p0 */
CINDEX[]
#PUSH, 6 /* c0 */
CINDEX[]
#PUSH, 3 /* som */
CINDEX[]
#PUSH, 113 /* get delta phase for optimal stroke position */
CALL[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt; */
/* forward to stroke1 position */

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 5 /* c1 */
CINDEX[]
#PUSH, 3 /* phase0 */
CINDEX[]
#PUSH, 2
SLOOP[]
SHPIX[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt; */
/* determine phase1 for optimal position of stroke1 */

DUP[]
#PUSH, 6 /* p1 */
CINDEX[]
#PUSH, 6 /* c1 */
CINDEX[]
#PUSH, 5 /* som */
CINDEX[]
#PUSH, 113 /* get delta phase for optimal stroke position */
CALL[]
ADD[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt; */
/* undo forwarding to stroke1 position */

#PUSH, 6 /* p1 */
CINDEX[]
#PUSH, 6 /* c1 */
CINDEX[]
#PUSH, 4 /* phase0 */
CINDEX[]
NEG[]
#PUSH, 2
SLOOP[]
SHPIX[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt; */
/* determine double average phase error */

#PUSH, 2 /* phase0 */
CINDEX[]
#PUSH, 2 /* phase1 */
CINDEX[]
ADD[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt;, &lt;2*phaseError&gt; */

DUP[]
#PUSH, 64
GTEQ[]
IF[]

    /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt;, &lt;2*phaseError&gt; */
    /* double average phase error &gt;= 1 pixel, correct to the left */

    POP[]
    #PUSH, 64
    SUB[]
    SWAP[]
    #PUSH, 64
    SUB[]
    SWAP[]

ELSE[]

    /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt;, &lt;2*phaseError&gt; */

    #PUSH, -64
    LT[]
    IF[]

        /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt;, &lt;2*phaseError&gt; */
        /* double average phase error &lt; -1 pixel, correct to the right */

        #PUSH, 64
        ADD[]
        SWAP[]
        #PUSH, 64
        ADD[]
        SWAP[]

    EIF[]

EIF[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase0&gt;, &lt;phase1&gt; */
/* apply corrected optimal phase0 to stroke0 */

#PUSH, 8 /* p0 */
CINDEX[]
#PUSH, 8 /* c0 */
CINDEX[]
#PUSH, 4 /* phase0 */
MINDEX[]
#PUSH, 2
SLOOP[]
SHPIX[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt;, &lt;phase1&gt; */
/* apply corrected optimal phase1 to stroke1 */

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 5 /* c1 */
CINDEX[]
ROLL[] /* phase1 */
#PUSH, 2
SLOOP[]
SHPIX[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */

DUP[]
#PUSH, 0
GT[]
IF[]

    /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
    /* determine total side-bearing space to see if we need to bias the black body */

    #PUSH, 6 /* p0 */
    CINDEX[]
    #PUSH, 8 /* gp0 */
    CINDEX[]
    MD[N]
    #PUSH, 3 /* gp1 */
    CINDEX[]
    #PUSH, 5 /* c1 */
    CINDEX[]
    MD[N]
    ADD[]
    DUP[]
    #PUSH, 64
    GT[]
    IF[]

        /* enough total side-bearing space left, leave it alone */
        POP[]

    ELSE[]

        /* 1 pixel or less total side-bearing space left */
        #PUSH, 0
        GT[]
        IF[]

            /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
            /* any total side-bearing space left at all, move black-body flush left and start over */

            #PUSH, 6 /* p0 */
            CINDEX[]
            #PUSH, 6 /* c0 */
            CINDEX[]
            #PUSH, 6 /* p1 */
            CINDEX[]
            #PUSH, 6 /* c1 */
            CINDEX[]
            #PUSH, 11 /* gp0 */
            CINDEX[]
            #PUSH, 11 /* p0 */
            CINDEX[]
            MD[N]
            #PUSH, 4
            SLOOP[]
            SHPIX[]

            /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
            /* optimize position of stroke0 forwarding phase0 to stroke1 */

            #PUSH, 6 /* p0 */
            CINDEX[]
            #PUSH, 6 /* c0 */
            CINDEX[]
            #PUSH, 6 /* p1 */
            CINDEX[]
            #PUSH, 6 /* c1 */
            CINDEX[]
            #PUSH, 10 /* p0 */
            CINDEX[]
            #PUSH, 10 /* c0 */
            CINDEX[]
            #PUSH, 7 /* som */
            CINDEX[]
            #PUSH, 113 /* get delta phase for optimal stroke position */
            CALL[]
            #PUSH, 4 /* apply to both strokes */
            SLOOP[]
            SHPIX[]

            /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
            /* optimize position of stroke1 */

            #PUSH, 4 /* p1 */
            CINDEX[]
            #PUSH, 4 /* c1 */
            CINDEX[]
            #PUSH, 5 /* c1 */
            CINDEX[]
            #PUSH, 7 /* p1 */
            CINDEX[]
            #PUSH, 5 /* som */
            CINDEX[]
            #PUSH, 113 /* get delta phase for optimal stroke position */
            CALL[]
            #PUSH, 2 /* apply to second stroke only */
            SLOOP[]
            SHPIX[]

        ELSE[]

            /* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */
            /* no total side-bearing space left, move stroke1 left by 1 pixel */

            #PUSH, 4 /* p1 */
            CINDEX[]
            #PUSH, 4 /* c1 */
            CINDEX[]
            #PUSH, -64, 2
            SLOOP[]
            SHPIX[]

        EIF[]

    EIF[]

EIF[]

/* STACK: &lt;dir&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;gp1&gt;, &lt;som&gt; */

POP[]
POP[]
POP[]
POP[]
POP[]
POP[]
POP[]
POP[]

#PUSHON
#END
ENDF[]

FDEF[], 118

/* fn to set pv perpendicular to p1 and c0' such that distance
   c0'&lt;---p0 measures cvt or natural distance if cvt = -1.
   used as support to ResX|YDDist and ResX|YDLink

   CALL[], &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt&gt;, 118 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt&gt; */

#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 3 /* c0 */
CINDEX[]
SDPVTL[R]
#PUSH, 3 /* p0 */
CINDEX[]
#PUSH, 3 /* c0 */
CINDEX[]
ROLL[] /* cvt */
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 101 /* resActDist, noCvt, noMinDist */
ELSE[]
    #PUSH, 104 /* resActDist, cvt, minDist */
EIF[]
CALL[]
ABS[]

/* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt; */

#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 4 /* p0 */
CINDEX[]
SPVTL[r]
#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 4 /* p0 */
CINDEX[]
MD[N]

/* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d&gt; */
/* test if solution exists at all */

DUP[]
DUP[]
MUL[]
#PUSH, 3 /* w */
CINDEX[]
DUP[]
MUL[]
LTEQ[]
#PUSH, 0, 3 /* d */
CINDEX[]
EQ[]
OR[]

/* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d&gt;, &lt;d² &lt;= w² or d = 0?&gt; */

IF[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d&gt; */
    /* solution doesn't exist, hence prepare to bail out */

    POP[]
    POP[]
    SWAP[]
    POP[]
    SPVTL[R]

ELSE[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d&gt; */
    /* solution exists, hence continue computation */

    DUP[]
    MUL[]
    #PUSH, 2 /* w */
    CINDEX[]
    DUP[]
    MUL[]
    SUB[]
    DUP[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d² - w²&gt;, &lt;d² - w²&gt; */

    #PUSH, 83 /* sqrt */
    CALL[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;w&gt;, &lt;d² - w²&gt;, &lt;sqrt(d² - w²)&gt; */

    ROLL[] /* w */
    MUL[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;d² - w² =: dx&gt;, &lt;w·sqrt(d² - w²) =: dy&gt; */

    #PUSH, 5 /* p1 */
    CINDEX[]
    #PUSH, 5 /* p0 */
    CINDEX[]
    SDPVTL[R]
    #PUSH, 4 /* p0 */
    CINDEX[]
    #PUSH, 4 /* c0 */
    MINDEX[]
    MD[O]

    #PUSH, 0
    LT[]
    IF[]
        NEG[] /* dy */
    EIF[]

    /* STACK: &lt;p1&gt;, &lt;p0&gt;, &lt;dx&gt;, &lt;dy&gt; */

    #PUSH, 4 /* p1 */
    MINDEX[]
    DUP[]
    SVTCA[X]
    GC[N]
    SWAP[]
    SVTCA[Y]
    GC[N]

    /* STACK: &lt;p0&gt;, &lt;dx&gt;, &lt;dy&gt;, &lt;p1.x&gt;, &lt;p1.y&gt; */

    #PUSH, 5 /* p0 */
    MINDEX[]
    DUP[]
    SVTCA[X]
    GC[N]
    SWAP[]
    SVTCA[Y]
    GC[N]

    /* STACK: &lt;dx&gt;, &lt;dy&gt;, &lt;p1.x&gt;, &lt;p1.y&gt;, &lt;p0.x&gt;, &lt;p0.y&gt; */

    #PUSH, 0 /* enter twilight zone */
    SZPS[]

    SVTCA[Y]
    #PUSH, 0
    SWAP[]
    SCFS[]
    SVTCA[X]
    #PUSH, 0
    SWAP[]
    SCFS[]

    /* STACK: &lt;dx&gt;, &lt;dy&gt;, &lt;p1.x&gt;, &lt;p1.y&gt; */

    SVTCA[Y]
    DUP[]
    #PUSH, 1
    SWAP[]
    SCFS[]
    #PUSH, 2
    SWAP[]
    SCFS[]
    SVTCA[X]
    DUP[]
    #PUSH, 1
    SWAP[]
    SCFS[]
    #PUSH, 2
    SWAP[]
    SCFS[]

    /* STACK: &lt;dx&gt;, &lt;dy&gt; */

    SWAP[]

    /* STACK: &lt;dy&gt;, &lt;dx&gt; */

    #PUSH, 2, 0, 1
    SFVTL[r]
    SWAP[]
    SHPIX[]

    /* STACK: &lt;dy&gt; */

    #PUSH, 2, 0, 1
    SFVTL[R]
    SWAP[]
    SHPIX[]

    /* STACK: */

    #PUSH, 2, 1
    SPVTL[R]

    #PUSH, 1 /* leave twilight zone */
    SZPS[]

EIF[]

#PUSHON
#END
ENDF[]

FDEF[], 119

/* align c with p unless fv is perpendicular to pv
   fv and pv assumed to be set prior to calling fn 119
   used as support to ResX|YDDist and ResX|YDLink

   CALL[], &lt;p&gt;, &lt;c&gt;, 119 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt; */

SWAP[]
SRP0[]

/* STACK: &lt;c&gt; */

GFV[]
GPV[]

/* STACK: &lt;c&gt;, &lt;fv.x&gt;, &lt;fv.y&gt;, &lt;pv.x&gt;, &lt;pv.y&gt; */

ROLL[]
MUL[]
SWAP[]
ROLL[]
MUL[]
ADD[]
ABS[]

/* STACK: &lt;c&gt;, &lt;|pv.y*fv.y + pv.x*fv.x|&gt; */

#PUSH, 16384, 1024
MUL[]

/* the above dot product multiplies two 2.14 numbers in 26.6 arithmetic yielding a 2.22 number (2^14 * 2^14 / 2^6 = 2^22)
   like the rasterizer, we're comparing this number to 1/16: |fv1·pv| &lt; 1/16 means fv1 is within ±arcsin(1/16) or ±3.5833° perpendicular to pv
   in 2.22 format 1/16 is 2^18, but since the assembler won't allow us to push 2^18 = 262144, we make up this number as a multiplication
   the multiplication, in turn, is again done in 26.6 format, hence we multiply 16384 with 1024 (2^14 * 2^10 / 2^6 = 2^18) */

LT[]
IF[]

    /* fv is approximately perpendicular to pv which by itself is perpendicular
       to a line from p to c' (with c' the twilight point 2 computed in fn 118),
       i.e. fv is approximately parallel to line from p to c'. Given the usage
       of fn 119 this means that fv is approximately coincident with said line,
       or c is approximately aligned already, hence simply touch the point, but
       without involving the pv */

    /* STACK: &lt;c&gt; */

    #PUSH, 0
    SHPIX[]

ELSE[]

    /* STACK: &lt;c&gt; */

    ALIGNRP[]

EIF[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 120

/* support to ResX|YDDist and ResX|YDLink where fv0 and fv1 are x or y

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1&gt;, 120 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1&gt; */

#PUSH, 6 /* p1 */
CINDEX[]
#PUSH, 9 /* p0 */
CINDEX[]
#PUSH, 9 /* c0 */
CINDEX[]
#PUSH, 7 /* cvt0 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1&gt; */

SWAP[]
#PUSH, 0 /* x? */
EQ[]
IF[]
  SFVTCA[X]
ELSE[]
  SFVTCA[Y]
EIF[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1&gt; */

#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 6 /* c0 */
MINDEX[]
#PUSH, 119
CALL[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1&gt; */

#PUSH, 5 /* p0 */
CINDEX[]
#PUSH, 5 /* p1 */
MINDEX[]
#PUSH, 5 /* c1 */
CINDEX[]
#PUSH, 5 /* cvt1 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c1&gt;, &lt;fv1&gt; */

#PUSH, 0 /* x? */
EQ[]
IF[]
  SFVTCA[X]
ELSE[]
  SFVTCA[Y]
EIF[]

/* STACK: &lt;p0&gt;, &lt;c1&gt; */

#PUSH, 119
CALL[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 121

/* support to ResX|YDDist and ResX|YDLink where fv0 is x or y while fv1 is to-line

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt;, 121 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 7 /* p1 */
CINDEX[]
#PUSH, 10 /* p0 */
CINDEX[]
#PUSH, 10 /* c0 */
CINDEX[]
#PUSH, 8 /* cvt0 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

ROLL[]
#PUSH, 0 /* x? */
EQ[]
IF[]
  SFVTCA[X]
ELSE[]
  SFVTCA[Y]
EIF[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 7 /* c0 */
MINDEX[]
#PUSH, 119
CALL[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 6 /* p0 */
CINDEX[]
#PUSH, 6 /* p1 */
MINDEX[]
#PUSH, 6 /* c1 */
CINDEX[]
#PUSH, 6 /* cvt1 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

SFVTL[r]

/* STACK: &lt;p0&gt;, &lt;c1&gt; */

#PUSH, 119
CALL[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 122

/* support to ResX|YDDist and ResX|YDLink where fv0 is to-line while fv1 is x or y

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1&gt;, 122 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1&gt; */

#PUSH, 7 /* p1 */
CINDEX[]
#PUSH, 10 /* p0 */
CINDEX[]
#PUSH, 10 /* c0 */
CINDEX[]
#PUSH, 8 /* cvt0 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1&gt; */

ROLL[]
ROLL[]
SFVTL[r]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1&gt; */

#PUSH, 4 /* p1 */
CINDEX[]
#PUSH, 6 /* c0 */
MINDEX[]
#PUSH, 119
CALL[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1&gt; */

#PUSH, 5 /* p0 */
CINDEX[]
#PUSH, 5 /* p1 */
MINDEX[]
#PUSH, 5 /* c1 */
CINDEX[]
#PUSH, 5 /* cvt1 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c1&gt;, &lt;fv1&gt; */

#PUSH, 0 /* x? */
EQ[]
IF[]
  SFVTCA[X]
ELSE[]
  SFVTCA[Y]
EIF[]

/* STACK: &lt;p0&gt;, &lt;c1&gt; */

#PUSH, 119
CALL[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 123

/* support to ResX|YDDist and ResX|YDLink where both fv0 and fv1 are to-line

   CALL[], &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt;, 123 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 8 /* p1 */
CINDEX[]
#PUSH, 11 /* p0 */
CINDEX[]
#PUSH, 11 /* c0 */
CINDEX[]
#PUSH, 9 /* cvt0 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.p0&gt;, &lt;fv0.p1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 4 /* fv0.p0 */
MINDEX[]
#PUSH, 4 /* fv0.p1 */
MINDEX[]
SFVTL[r]

/* STACK: &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 7 /* c0 */
MINDEX[]
#PUSH, 119
CALL[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

#PUSH, 6 /* p0 */
CINDEX[]
#PUSH, 6 /* p1 */
MINDEX[]
#PUSH, 6 /* c1 */
CINDEX[]
#PUSH, 6 /* cvt1 */
MINDEX[]
#PUSH, 118
CALL[]

/* STACK: &lt;p0&gt;, &lt;c1&gt;, &lt;fv1.p0&gt;, &lt;fv1.p1&gt; */

SFVTL[r]

/* STACK: &lt;p0&gt;, &lt;c1&gt; */

#PUSH, 119
CALL[]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 124

/* determine on which side of edge p0-&gt;p1 is c
   by calculating vector product (c - p0) ^ (p1 - p0)

   CALL[], &lt;p0&gt;, &lt;c&gt;, &lt;p1&gt;, 124

   returns with vector product on stack
   if vector product &lt; 0 then c is on the left of p0-&gt;p1
   if vector product &gt; 0 then c is on the right of p0-&gt;p1
   else c is exactly on p0-&gt;p1 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;c&gt;, &lt;p1&gt; */

SPVTCA[X]
#PUSH, 3 /* p0 */
CINDEX[]
#PUSH, 3 /* c */
CINDEX[]
MD[O]
#PUSH, 4 /* p0 */
CINDEX[]
#PUSH, 3 /* p1 */
CINDEX[]
MD[O]

/* STACK: &lt;p0&gt;, &lt;c&gt;, &lt;p1&gt;, &lt;a.x&gt;, &lt;b.x&gt; */

SPVTCA[Y]
#PUSH, 5 /* p0 */
CINDEX[]
#PUSH, 5 /* c */
MINDEX[]
MD[O]
#PUSH, 5 /* p0 */
MINDEX[]
#PUSH, 5 /* p1 */
MINDEX[]
MD[O]

/* STACK: &lt;a.x&gt;, &lt;b.x&gt;, &lt;a.y&gt;, &lt;b.y&gt; */

#PUSH, 4 /* a.x */
MINDEX[]
MUL[]

ROLL[] /* b.x */
ROLL[] /* a.y */
MUL[]

SUB[]

/* STACK: &lt;b.y*a.x - b.x*a.y&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 125

/* fn interpolates a pair of diagonal links between grand-parents gp0 and gp1 along pv
   pv: X = 0, Y = 1, X/ = 2; fv0 and fv1: x and y components in 2.14

   CALL[], &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt;, 125 */

#BEGIN
#PUSHOFF

/* interpolate parents between grand-parents along pv */
/* STACK: &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

#PUSH, 93, 14 /* pv */
CINDEX[]
ADD[]
CALL[]

#PUSH, 12 /* gp0 */
MINDEX[]
SRP1[]
#PUSH, 5 /* gp1 */
MINDEX[]
SRP2[]

#PUSH, 10 /* p0 */
CINDEX[]
IP[]
#PUSH, 7 /* p1 */
CINDEX[]
IP[]

/* determine if this is a crisscrossed stroke */
/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

#PUSH, 10 /* p0 */
CINDEX[]
#PUSH, 10 /* c0 */
CINDEX[]
#PUSH, 9 /* p1 */
CINDEX[]
#PUSH, 124 /* c0 on which side of edge p0-&gt;p1? */
CALL[]
#PUSH, 0
LT[]

#PUSH, 11 /* p0 */
CINDEX[]
#PUSH, 8 /* c1 */
CINDEX[]
#PUSH, 10 /* p1 */
CINDEX[]
#PUSH, 124 /* c1 on which side of edge p0-&gt;p1? */
CALL[]
#PUSH, 0
LT[]

EQ[]
IF[]

    /* both childern on same side of parent edge p0&gt;-&gt;p1
       hence re-align children with parents perp to dpv. */
    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 7 /* p1 */
    CINDEX[]
    #PUSH, 11 /* p0 */
    CINDEX[]
    SDPVTL[R]

    #PUSH, 4 /* fv0.x */
    CINDEX[]
    #PUSH, 4 /* fv0.y */
    CINDEX[]
    SFVFS[]

    #PUSH, 10 /* p0 */
    CINDEX[]
    SRP0[]
    #PUSH, 9 /* c0 */
    CINDEX[]
    MDRP[m&lt;rBl]

    #PUSH, 2 /* fv1.x */
    CINDEX[]
    #PUSH, 2 /* fv1.y */
    CINDEX[]
    SFVFS[]

    #PUSH, 7 /* p1 */
    CINDEX[]
    SRP0[]
    #PUSH, 6 /* c1 */
    CINDEX[]
    MDRP[m&lt;rBl]

ELSE[]

    /* childern on opposite sides of "parent edge" p0&gt;-&gt;p1
       hence re-align children with parents per method for crisscrossed strokes */
    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 7 /* p1 */
    CINDEX[]
    #PUSH, 11 /* p0 */
    CINDEX[]
    #PUSH, 11 /* c0 */
    CINDEX[]
    #PUSH, -1, 118 /* no cvt0, no minDist */
    CALL[]

    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 4 /* fv0.x */
    CINDEX[]
    #PUSH, 4 /* fv0.y */
    CINDEX[]
    SFVFS[]

    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 7 /* p1 */
    CINDEX[]
    #PUSH, 10 /* c0 */
    CINDEX[]
    #PUSH, 119
    CALL[]

    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 10 /* p0 */
    CINDEX[]
    #PUSH, 8 /* p1 */
    CINDEX[]
    #PUSH, 8 /* c1 */
    CINDEX[]
    #PUSH, -1, 118 /* no cvt1, no minDist */
    CALL[]

    /* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

    #PUSH, 2 /* fv1.x */
    CINDEX[]
    #PUSH, 2 /* fv1.y */
    CINDEX[]
    SFVFS[]

    /* STACK: &lt;p0&gt;, &lt;c1&gt; */

    #PUSH, 10 /* p0 */
    CINDEX[]
    #PUSH, 7 /* c1 */
    CINDEX[]
    #PUSH, 119
    CALL[]

EIF[]

/* determine pre-link medians, measuring perpendicularly to p0-&gt;p1 */
/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt; */

#PUSH, 10 /* p0 */
CINDEX[]
GC[N]
#PUSH, 10 /* c0 */
CINDEX[]
GC[N]
ADD[]

#PUSH, 8 /* p1 */
CINDEX[]
GC[N]
#PUSH, 8 /* c1 */
CINDEX[]
GC[N]
ADD[]

/* links */
/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt;, &lt;median0&gt;, &lt;median1&gt; */

#PUSH, 6 /* fv0.x */
CINDEX[]
#PUSH, 6 /* fv0.y */
CINDEX[]
SFVFS[]

#PUSH, 12 /* p0 */
CINDEX[]
#PUSH, 12 /* c0 */
CINDEX[]
#PUSH, 12 /* cvt0 */
MINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 106 /* resMIRP, noCvt, minDist */
ELSE[]
    #PUSH, 108 /* resMIRP, cvt, minDist */
EIF[]
CALL[]

/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt;, &lt;median0&gt;, &lt;median1&gt; */

#PUSH, 4 /* fv1.x */
CINDEX[]
#PUSH, 4 /* fv1.y */
CINDEX[]
SFVFS[]

#PUSH, 9 /* p1 */
CINDEX[]
#PUSH, 9 /* c1 */
CINDEX[]
#PUSH, 9 /* cvt1 */
MINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 106 /* resMIRP, noCvt, minDist */
ELSE[]
    #PUSH, 108 /* resMIRP, cvt, minDist */
EIF[]
CALL[]

/* subtract post-link medians from pre-link ones */
/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt;, &lt;median0&gt;, &lt;median1&gt; */

SWAP[]

#PUSH, 10 /* p0 */
CINDEX[]
GC[N]
#PUSH, 10 /* c0 */
CINDEX[]
GC[N]
ADD[]

SUB[]
#PUSH, 32
MUL[]

SWAP[]

#PUSH, 8 /* p1 */
CINDEX[]
GC[N]
#PUSH, 8 /* c1 */
CINDEX[]
GC[N]
ADD[]

SUB[]
#PUSH, 32
MUL[]

/* finally move points by respective deltas */
/* STACK: &lt;pv&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;fv0.x&gt;, &lt;fv0.y&gt;, &lt;fv1.x&gt;, fv1.y&gt;, &lt;delta0&gt;, &lt;delta1&gt; */

#PUSH, 1, 12 /* pv */
CINDEX[]
EQ[]
IF[]
    SFVTCA[Y]
ELSE[]
    SFVTCA[X]
EIF[]

#PUSH, 10 /* p0 */
MINDEX[]
DUP[]
SRP0[]
#PUSH, 3 /* delta0 */
CINDEX[]
MSIRP[m]

#PUSH, 6 /* fv0.x */
MINDEX[]
#PUSH, 6 /* fv0.y */
MINDEX[]
SFVFS[]

#PUSH, 7 /* c0 */
MINDEX[]
DUP[]
SRP0[]
ROLL[] /* delta0 */
MSIRP[m]

/* STACK: &lt;pv&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;fv1.x&gt;, fv1.y&gt;, &lt;delta1&gt; */

#PUSH, 1, 7 /* pv */
MINDEX[]
EQ[]
IF[]
    SFVTCA[Y]
ELSE[]
    SFVTCA[X]
EIF[]

#PUSH, 5 /* p1 */
MINDEX[]
DUP[]
SRP0[]
#PUSH, 2 /* delta1 */
CINDEX[]
MSIRP[m]

ROLL[] /* fv0.x */
ROLL[] /* fv0.y */
SFVFS[]

SWAP[] /* c1 */
DUP[]
SRP0[]
SWAP[] /* delta1 */
MSIRP[m]

/* STACK: */

#PUSHON
#END
ENDF[]

FDEF[], 126

/* glue code to fn 125 where both fv0 and fv1 are x or y

   CALL[], &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0&gt;, &lt;fv1&gt;, 126 */

#BEGIN
#PUSHOFF

/* STACK: &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0&gt;, &lt;fv1&gt; */

SWAP[] /* fv0 */
#PUSH, 1
EQ[]
IF[]
    #PUSH, 0, 16384
ELSE[]
    #PUSH, 16384, 0
EIF[]

ROLL[] /* fv1 */
#PUSH, 1
EQ[]
IF[]
    #PUSH, 0, 16384
ELSE[]
    #PUSH, 16384, 0
EIF[]

#PUSH, 125 /* resIPDDLink */
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 127

/* glue code to fn 125 where fv0 is to line and fv1 is x or y

   CALL[], &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.0&gt;, &lt;fv0.1&gt;, &lt;fv1&gt;, 127 */

#BEGIN
#PUSHOFF

/* STACK: &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.0&gt;, &lt;fv0.1&gt;, &lt;fv1&gt; */

ROLL[] /* fv0.0 */
ROLL[] /* fv0.1 */
SFVTL[r]
GFV[]

ROLL[] /* fv1 */
#PUSH, 1
EQ[]
IF[]
    #PUSH, 0, 16384
ELSE[]
    #PUSH, 16384, 0
EIF[]

#PUSH, 125 /* resIPDDLink */
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 128

/* glue code to fn 125 where fv0 is x or y and fv1 is to line

   CALL[], &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0&gt;, &lt;fv1.0&gt;, &lt;fv1.1&gt;, 128 */

#BEGIN
#PUSHOFF

/* STACK: &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0&gt;, &lt;fv1.0&gt;, &lt;fv1.1&gt; */

SFVTL[r]

#PUSH, 1
EQ[]
IF[]
    #PUSH, 0, 16384
ELSE[]
    #PUSH, 16384, 0
EIF[]

GFV[]

#PUSH, 125 /* resIPDDLink */
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 129

/* glue code to fn 125 where both fv0 and fv1 are to line

   CALL[], &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.0&gt;, &lt;fv0.1&gt;, &lt;fv1.0&gt;, &lt;fv1.1&gt;, 129 */

#BEGIN
#PUSHOFF

/* STACK: &lt;pv&gt;, &lt;gp0&gt;, &lt;p0&gt;, &lt;c0&gt;, &lt;cvt0&gt;, &lt;p1&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;gp1&gt;, &lt;fv0.0&gt;, &lt;fv0.1&gt;, &lt;fv1.0&gt;, &lt;fv1.1&gt; */

#PUSH, 4 /* fv0.0 */
MINDEX[]
#PUSH, 4 /* fv0.1 */
MINDEX[]
SFVTL[r]
GFV[]
#PUSH, 4 /* fv1.0 */
MINDEX[]
#PUSH, 4 /* fv1.1 */
MINDEX[]
SFVTL[r]
GFV[]
#PUSH, 125 /* resIPDDLink */
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 130

/* extrapolate x-coordinate of &lt;p&gt; to base line along italic angle
   returns with extrapolated x-coordinate on stack

   CALL[], &lt;p&gt;, 130 */

#BEGIN
#PUSHOFF

DUP[]
SVTCA[X]
GC[N]
SWAP[]
SVTCA[Y]
GC[N]

/* STACK: &lt;p.x&gt;, &lt;p.y&gt; */

#PUSH, 10 /* rise */
RS[]
#PUSH, 11 /* run */
RS[]

/* STACK: &lt;p.x&gt;, &lt;p.y&gt;, &lt;rise&gt;, &lt;run&gt; */

ROLL[]
MUL[]
SWAP[]
DIV[]
SUB[]

/* STACK: &lt;p.x - p.y*run/rise&gt; */

#PUSHON
#END
ENDF[]

FDEF[], 131

/* constrains an italic stroke, defined by parents &lt;p0&gt; and &lt;p1&gt;, by
   children &lt;c0&gt; and &lt;c1&gt;, and by cvts &lt;cvt0&gt; and &lt;cvt1&gt;, and inter-
   polates it between points &lt;lsb&gt; and &lt;rsb&gt;

   for b&amp;w stroke additionally optimizes the resulting pixel pattern

   CALL[], &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt;, 131 */

#BEGIN
#PUSHOFF

/* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt; */

#PUSH, 9 /* pv perp italic, fv X */
CALL[]

/* lock parent edge */

#PUSH, 6 /* p0 */
CINDEX[]
MDAP[r]

#PUSH, 5 /* p1 */
CINDEX[]
RDTG[]
MDRP[m&lt;RBl]

/* link child edge */

#PUSH, 6 /* p0 */
CINDEX[]
#PUSH, 5 /* c0 */
CINDEX[]
#PUSH, 4 /* cvt0 */
CINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 106 /* resMIRP, noCvt, minDist */
ELSE[]
    #PUSH, 108 /* resMIRP, cvt, minDist */
EIF[]
CALL[]

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 4 /* c1 */
CINDEX[]
#PUSH, 3 /* cvt1 */
CINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 106 /* resMIRP, noCvt, minDist */
ELSE[]
    #PUSH, 108 /* resMIRP, cvt, minDist */
EIF[]
CALL[]

RTG[]

/* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt; */
/* interpolate median of p0 and c0 between lsb and rsb */

#PUSH, 8 /* lsb */
CINDEX[]
#PUSH, 7 /* p0 */
CINDEX[]
#PUSH, 6 /* c0 */
CINDEX[]
#PUSH, 10 /* rsb */
CINDEX[]
#PUSH, 111 /* interpolate median */
CALL[]

/* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;cvt0&gt;, &lt;cvt1&gt; */
/* if the two actual parent-&gt;child distances round to the same stroke weight */

#PUSH, 6 /* p0 */
CINDEX[]
#PUSH, 5 /* c0 */
CINDEX[]
#PUSH, 4 /* cvt0 */
MINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 102 /* resActDist, noCvt, minDist */
ELSE[]
    #PUSH, 104 /* resActDist, cvt, minDist */
EIF[]
CALL[]

/* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;cvt1&gt;, &lt;[dist0]&gt; */

#PUSH, 5 /* p1 */
CINDEX[]
#PUSH, 4 /* c1 */
CINDEX[]
#PUSH, 4 /* cvt1 */
MINDEX[]
DUP[]
#PUSH, 0
LT[]
IF[]
    POP[]
    #PUSH, 102 /* resActDist, noCvt, minDist */
ELSE[]
    #PUSH, 104 /* resActDist, cvt, minDist */
EIF[]
CALL[]

/* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;[dist0]&gt;, &lt;[dist1]&gt; */

EQ[]
IF[]

    /* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */
    /* adjust median of p1 and c1 in parallel */

    RDTG[]
    #PUSH, 4 /* p0 */
    CINDEX[]
    SRP0[]
    #PUSH, 3 /* p1 */
    CINDEX[]
    MDRP[m&lt;RBl]

    #PUSH, 2 /* c0 */
    CINDEX[]
    SRP0[]
    #PUSH, 1 /* c1 */
    CINDEX[]
    MDRP[m&lt;RBl]

    #PUSH, 5 /* rsb */
    MINDEX[]
    POP[]
    #PUSH, 5 /* lsb */
    MINDEX[]
    POP[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */

ELSE[]

    /* STACK: &lt;lsb&gt;, &lt;rsb&gt;, &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */
    /* interpolate median of p1 and c1 between lsb and rsb independently */

    #PUSH, 6 /* lsb */
    MINDEX[]
    #PUSH, 4 /* p1 */
    CINDEX[]
    #PUSH, 3 /* c1 */
    CINDEX[]
    #PUSH, 8 /* rsb */
    MINDEX[]
    #PUSH, 111 /* interpolate median */
    CALL[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */

EIF[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */
/* for b&amp;w only optimize pixel pattern */

#PUSH, 0, 2
RS[]
EQ[]
IF[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */
    /* extrapolate c0 to base line */

    RDTG[]
    #PUSH, 2 /* c0 */
    CINDEX[]
    #PUSH, 130
    CALL[]

    /* extrapolate p0 to base line */

    #PUSH, 5 /* p0 */
    CINDEX[]
    #PUSH, 130
    CALL[]

    /* get parentPhase from extrapolated x-coordinate */

    DUP[]
    DUP[]
    ROUND[Bl]
    SUB[]

    #PUSH, 4 /* targetPhase */
    RS[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;c0.x'&gt;, &lt;p0.x'&gt;, &lt;parentPhase&gt;, &lt;targetPhase&gt; */
    /* shifting parent edge by deltaPhase optimizes stepping pattern on parent edge */

    SVTCA[X]
    SWAP[]
    SUB[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;c0.x'&gt;, &lt;p0.x'&gt;, &lt;deltaPhase&gt; */
    /* minimize the positioning error by mapping deltaPhase from [-63,63] to [-32,31] */

    #PUSH, 96
    ADD[]
    DUP[]
    ROUND[Bl]
    SUB[]
    #PUSH, 32
    SUB[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt;, &lt;c0.x'&gt;, &lt;p0.x'&gt;, &lt;deltaPhase&gt; */
    /* save minimized deltaPhase for child edge and shift parent edge */

    DUP[]
    #PUSH, 8 /* p0 */
    MINDEX[]
    #PUSH, 8 /* p1 */
    MINDEX[]
    ROLL[]
    #PUSH, 2
    SLOOP[]
    SHPIX[]

    /* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;c0.x'&gt;, &lt;p0.x'&gt;, &lt;deltaPhase&gt; */
    /* since child edge is linked perpendicular to italic angle,
       the resulting stroke would include unnecessary pixels,
       hence determine phase of distance between extrapolated
       x-coordinates (deltaDeltaPhase) */

    ROLL[]
    ROLL[]
    SUB[]
    DUP[]
    ROUND[Bl]
    SUB[]

    /* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;deltaPhase&gt;, &lt;deltaDeltaPhase&gt; */
    /* subtract from deltaPhase (don't shift quite as far...) */

    SUB[]

    /* STACK: &lt;c0&gt;, &lt;c1&gt;, &lt;deltaPhase'&gt; */
    /* shift parent edge */

    #PUSH, 2
    SLOOP[]
    SHPIX[]

    /* STACK: */

ELSE[]

    /* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;c0&gt;, &lt;c1&gt; */

    POP[]
    POP[]
    POP[]
    POP[]

    /* STACK: */

EIF[]

RTG[]

#PUSHON
#END
ENDF[]

FDEF[], 132

/* for monochrome only: stack points &lt;p&gt; through &lt;c&gt; on top of &lt;p&gt; below &lt;ppem&gt;

   CALL[], &lt;p&gt;, &lt;c&gt;, &lt;ppem&gt;, 132 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p&gt;, &lt;c&gt;, &lt;ppem&gt; */

MPPEM[]
GT[]
#PUSH, 1, 2
RS[]
GTEQ[]
AND[]
IF[]

    /* STACK: &lt;p&gt;, &lt;c&gt; */

    SWAP[]
    SRP0[]
    DUP[]
    SVTCA[X]
    ALIGNRP[]
    SVTCA[Y]
    ALIGNRP[]

ELSE[]

    /* STACK: &lt;p&gt;, &lt;c&gt; */

    POP[]
    POP[]
EIF[]

#PUSHON
#END
ENDF[]

FDEF[], 133

/* support fn for fns 134 and 135

   CALL[], &lt;align?&gt;, &lt;from&gt;, &lt;to&gt;, 133 */

#BEGIN
#PUSHOFF

SWAP[]

/* STACK: &lt;align?&gt;, &lt;to&gt;, &lt;from&gt; */

#WBeginLoop133:

#PUSH, 2 /* to */
CINDEX[]
#PUSH, 2 /* from */
CINDEX[]
GTEQ[]
IF[]

    /* STACK: &lt;align?&gt;, &lt;to&gt;, &lt;from&gt; */

    DUP[]
    #PUSH, 4 /* align? */
    CINDEX[]
    IF[]
        ALIGNRP[]
    ELSE[]
        IP[]
    EIF[]

    #PUSH, 1
    ADD[]

    #PUSH, WOffset133
    JMPR[], (WOffset133=#WBeginLoop133)

EIF[]

/* STACK: &lt;align?&gt;, &lt;to&gt;, &lt;from&gt; */

POP[]
POP[]
POP[]

#PUSHON
#END
ENDF[]

FDEF[], 134

/* support fn for italic IUP[?]
   assume pv and fv are set externally

   CALL[], &lt;p0&gt;, &lt;p1&gt;, 134 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;p1&gt; */

#PUSH, 2 /* p0 */
CINDEX[]
GC[O]
#PUSH, 2 /* p1 */
CINDEX[]
GC[O]
EQ[]

/* STACK: &lt;p0&gt;, &lt;p1&gt;, &lt;eq?&gt; */

ROLL[] /* p0 */
DUP[]
DUP[]
SRP0[]
SRP1[]
#PUSH, 1
ADD[]
ROLL[] /* p1 */
DUP[]
SRP2[]
#PUSH, 1
SUB[]

/* STACK: &lt;eq?&gt;, &lt;from&gt;, &lt;to&gt; */

#PUSH, 133
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 135

/* support fn for italic IUP[?]
   assume pv and fv are set externally

   CALL[], &lt;p0&gt;, &lt;end&gt;, &lt;start&gt;, &lt;p1&gt;, 135 */

#BEGIN
#PUSHOFF

/* STACK: &lt;p0&gt;, &lt;end&gt;, &lt;start&gt;, &lt;p1&gt; */

#PUSH, 4 /* p0 */
CINDEX[]
GC[O]
#PUSH, 2 /* p1 */
CINDEX[]
GC[O]
EQ[]

/* STACK: &lt;p0&gt;, &lt;end&gt;, &lt;start&gt;, &lt;p1&gt;, &lt;eq?&gt; */

SWAP[]
DUP[]
SRP2[]
#PUSH, 1
SUB[]
SWAP[]
DUP[]

#PUSH, 6 /* p0 */
MINDEX[]
DUP[]
DUP[]
SRP0[]
SRP1[]
#PUSH, 1
ADD[]
#PUSH, 6 /* end */
MINDEX[]

/* STACK: &lt;start&gt;, &lt;to&gt;, &lt;eq?&gt;, &lt;eq?&gt;, &lt;from&gt;, &lt;end&gt; */

#PUSH, 133
CALL[]

ROLL[]
ROLL[]
#PUSH, 133
CALL[]

#PUSHON
#END
ENDF[]

FDEF[], 150
/* Function 150 takes 5 arguments */
/* VERSION 1.0 20120420 */

/* This function moves a point between a PPEM range */
/* for the given rasterizer mode (in Store 2) ClearType */
/* CALL[],&lt;point&gt;,&lt;amount&gt;,&lt;low PPEM&gt;,&lt;high PPEM&gt;, &lt;rasterizer mode&gt;, 150 */
/* &lt;low ppem&gt; Lowest PPEM range to be modified (inclusive) */
/* &lt;high ppem&gt; Highest PPEM range to be modified (inclusive) */
/* &lt;Point&gt; point to be modified */
/* &lt;amount&gt; Amount to move point, in ± 64ths */
/* &lt;rasterizer mode&gt; value in store 2 */
/* 150 Function number */
#BEGIN
#PUSHOFF
#PUSH, 2
RS[] /* read store 2 */
EQ[] /* is it = to the last arg? */
IF[] /* if so . . . */
    GPV[] /* Save current PV on stack to restore */
    SPVTCA[Y] /* We should only MPPEM with Y PV */
    ROLL[]
    MPPEM[] /* check cur. size against high ppem */
    GTEQ[]
    #PUSH, 4
    MINDEX[]
    MPPEM[] /* and low ppem */
    LTEQ[]
    AND[]
    IF[] /* if it's between, then */
        SPVFS[] /* Restore orig PV */
        SHPIX[] /* move the point by the amount */
    ELSE[]
       SPVFS[] /* Restore orig PV */
       POP[] /* otherwise remove the remaining arguments */
       POP[]
    EIF[]

ELSE[]
    POP[] /* remove the remaining arguments if the first test fails */
    POP[]
    POP[]
    POP[]
EIF[]
#END
#PUSHON
ENDF[]

FDEF[], 151
/* Function 151 takes 5 arguments */
/* VERSION 1.0 20120420 */

/* This function moves a point between a PPEM range */
/* for the given set of rasterizer flags (in Store 2) */
/* CALL[],&lt;point&gt;,&lt;amount&gt;,&lt;low PPEM&gt;,&lt;high PPEM&gt;, &lt;rasterizer mode&gt;, 151 */
/* &lt;low ppem&gt; Lowest PPEM range to be modified (inclusive) */
/* &lt;high ppem&gt; Highest PPEM range to be modified (inclusive) */
/* &lt;Point&gt; point to be modified */
/* &lt;amount&gt; Amount to move point, in ± 64ths */
/* &lt;rasterizer flag&gt; bit of a value in store 2 */
/* Function 151 differs from Function 150 in that instead of requiring an */
/* exact match with the value in store 2, a given set of flags (or bit values) */
/* can be referenced. For example, if the function should execute */
/* in any situation where ClearType with fractional AWs is enabled, */
/* (c.f. Function 84) irrespective of other flags (e.g. BGR as opposed */
/* to RGB Devices or non-ClearType direction anti-aliasing) then one */
/* would use a &lt;rasterizer flag&gt; value of 64. (c.f. Function 84.) */
/* The rasterizer values for &lt;rasterizer mode&gt; are defined in the function */
/* 84 header. */
/* EXAMPLE: */
/* If one wanted the move to occur if either subpixel positioned or full gray pixel */
/* then one would take the 64 (from subpixel positioned) and the 256 (from */
/* gray full-pixel) and add them to get 320. With a value of 320, the point will */
/* get moved if either subpixel positioned or full gray pixel is enabled. */
/* If one wanted to move to occur always if ClearType was on, independent of */
/* any subtype or spacing flag, one would set the rasterizer mode to 2. */

/* 151 Function number */
#BEGIN
#PUSHOFF
#PUSH, 152 /* Call function 152 with the rasterizer mode on the top of stack */
CALL[]
IF[] /* if so . . . */
    GPV[] /* Save current PV on stack to restore */
    SPVTCA[Y] /* We should only MPPEM with Y PV */
    ROLL[]
    MPPEM[] /* check cur. size against high ppem */
    GTEQ[]
    #PUSH, 4
    MINDEX[]
    MPPEM[] /* and low ppem */
    LTEQ[]
    AND[]
    IF[] /* if it's between, then */
        SPVFS[] /* Restore orig PV */
        SHPIX[] /* move the point by the amount */
    ELSE[]
        SPVFS[] /* Restore orig PV */
        POP[] /* otherwise remove the remaining arguments */
        POP[]
    EIF[]

ELSE[]
    POP[] /* remove the remaining arguments if the first test fails */
    POP[]
    POP[]
    POP[]
EIF[]
#END
#PUSHON
ENDF[]

FDEF[], 152
/* Function 152 takes 1 argument, a "bitfield" flag. */
/* VERSION 1.0 20111117 */
/*
Function 152 is intended to take a set of one or more bits as input and do an AND (e.g. mask) of those
bits with the set of flags returned by Function 84. Then determine if there is at least one
of these resultant bits that are set.

Function 152 returns TRUE if the match is successful, and FALSE if it is not successful.

If the parameter is zero, indicating no flags, then the function returns FALSE.

This function takes a maxiumum of 32 bit flags.

USES: Storage 2 (FN 84)
RETURNS: 0 or 1
*/

#BEGIN
#PUSHOFF
/* Input parameter is a set of one or more flags */

DUP[]
#PUSH, 2     /* Read FN 84 flags */
RS[]
EQ[]         /* If a simple match, return TRUE */
#PUSH, 1
SWAP[]

#PUSH, BEcln
SWAP[]
JROT[], (BEcln=#LEndClear)  /* Jump to end and clean up stack. */
POP[]
#PUSH, 0, 2
RS[]         /* Read FN 84 flags */
#PUSH, BEclr /* If no FN 84 flags, return FALSE */
SWAP[]

JROF[], (BEclr=#LEndClear)

POP[]
#PUSH, 2
RS[]
SWAP[]
#PUSH, 32   /* Maximum number of bits to loop through */
/* TopLoop: */
#LTopLoop:
   /* STACK
   Loop Iteration Count
   Updated (shifted) Input Value
   Updated (shifted) FN 84 Flag
   */
  DUP[]
  NOT[]
  IF[]    /* Exit the loop when done */
    POP[]
    POP[]
    POP[]
    #PUSH, 0, BDEnd /* 73  End */

    JMPR[], (BDEnd=#LEndFn)

  EIF[]
  ROLL[]
  ROLL[]
  DUP[]
  ROLL[]
  DUP[]
  ROLL[]
  SWAP[]
  /* STACK
  Updated (shifted) FN 84 Flag
  Updated (shifted) Input Value
  Updated (shifted) FN 84 Flag
  Updated (Shifted) Input Value
  Loop Interation Count
  */

  /* Check to see if the lower-order bit is set in the FN 84 Flag */
  #PUSH, 4096 /* Convert to 26.6 by multiply by 64 x 64 */
  MUL[]
  ODD[]
  IF[]
    /* Check to see if the lower-order bit is set in the Input Value */
    #PUSH, 4096
    MUL[]
    ODD[]
    IF[]
      /* We can early out here once we find our first match */
      POP[]
      POP[]
      POP[]
      #PUSH, 1, BTEnd  /* 1 is the TRUE return code */
      JMPR[], (BTEnd=#LEndFn)
    EIF[]
  ELSE[]
    POP[]
  EIF[]
  /* STACK
  Updated (shifted) FN 84 Flag
  Updated (shifted) Input Value
  Loop Interation Count
  */
  /* Shift both the Input Value and the FN 84 Flag each one bit right */
  #PUSH, 128  /* 2 in 26.6 */
  DIV[]
  DUP[]
  NOT[]
  IF[]
    POP[]
    POP[]
    POP[]
    #PUSH, 0, BPEnd /* 0 is end condition of FALSE */

    JMPR[], (BPEnd=#LEndFn)

  EIF[]
  SWAP[]
  #PUSH, 128  /* 2 in 26.6 */
  DIV[]
  DUP[]
  NOT[]
  IF[]
    POP[]
    POP[]
    POP[]
    #PUSH, 0, BZEnd /* End */

    JMPR[], (BZEnd=#LEndFn) 

  EIF[]
  ROLL[]
  #PUSH, 1
  SUB[]
  #PUSH, WReLoop  /* -77 TopLoop */

JMPR[], (WReLoop=#LTopLoop)

/* EndClear: */
#LEndClear:
SWAP[]
POP[]
#LEndFn:
/* End: */
#END
#PUSHON
ENDF[]

FDEF[], 153
/* Function 153 takes 1 argument, a "bitfield" flag. */
/* VERSION 1.0 20111117 */
/*
Function 153 is intended to take a set of one or more bits as input and do an AND (e.g. mask) of those
bits with the set of flags returned by Function 84. Then determine if ALL
of these resultant bits from the mask are set.

Function 153 returns TRUE if the match is successful, and FALSE if it is not successful.

If the parameter is zero, indicating no flags, then the function returns FALSE.

This function takes a maxiumum of 32 flags.

USES: Storage 2 (FN 84)
RETURNS: 0 or 1
*/

#BEGIN
#PUSHOFF
/* Input parameter is a set of one or more flags */

DUP[]
#PUSH, 2     /* Read FN 84 flags */
RS[]
EQ[]         /* If a simple match, return TRUE */
#PUSH, 1
SWAP[]

#PUSH, BEcln
SWAP[]
JROT[], (BEcln=#LEndClear)  /* Jump to end and clean up stack. */
POP[]
#PUSH, 0, 2
RS[]         /* Read FN 84 flags */
#PUSH, BEclr /* If no FN 84 flags, return FALSE */
SWAP[]

JROF[], (BEclr=#LEndClear)

POP[]
#PUSH, 0, 2   /* 0 is the boolean tracking success, start off with FALSE */
RS[]
ROLL[]
#PUSH, 32   /* Maximum number of bits to loop through */
/* TopLoop: */
#LTopLoop:
   /* STACK
   Loop Iteration Count
   Updated (shifted) Input Value
   Updated (shifted) FN 84 Flag
   Conditional boolean tracking success
   */
  DUP[]
  NOT[]
  IF[]    /* Exit the loop when done */
    POP[]
    POP[]
    POP[]
    #PUSH, BDEnd /* 73  End */

    JMPR[], (BDEnd=#LEndFn)

  EIF[]
  ROLL[]
  ROLL[]
  DUP[]
  ROLL[]
  DUP[]
  ROLL[]
  SWAP[]
  /* STACK
  Updated (shifted) FN 84 Flag
  Updated (shifted) Input Value
  Updated (shifted) FN 84 Flag
  Updated (Shifted) Input Value
  Loop Interation Count
  Conditional boolean tracking success
  */

  /* Check to see if the lower-order bit is set in the FN 84 Flag */
  #PUSH, 4096 /* Convert to 26.6 by multiply by 64 x 64 */
  MUL[]
  ODD[]
  IF[]
    /* Check to see if the lower-order bit is set in the Input Value */
    #PUSH, 4096
    MUL[]
    ODD[]
    IF[]
      #PUSH, 4
      MINDEX[]
      #PUSH, 1  /* Set TRUE return code */
      OR[]      /* We OR this because we will immediately exit if we fail this test */
      #PUSH, 4
      MINDEX[]
      #PUSH, 4
      MINDEX[]
      #PUSH, 4
      MINDEX[]
    ELSE[]
      POP[]
      POP[]
      POP[]
      POP[]
      #PUSH, BTEnd , 0  /* 0 is the FALSE return code */
      SWAP[]
      JMPR[], (BTEnd=#LEndFn)

    EIF[]
  ELSE[]
    POP[]
  EIF[]
  #PUSH, 4 /* Can this be cleaned up and integrated with the code below? */
  MINDEX[]
  SWAP[]
  /* STACK
  Updated (shifted) FN 84 Flag
  Conditional boolean tracking success
  Updated (shifted) Input Value
  Loop Interation Count
  */
  /* Shift both the Input Value and the FN 84 Flag each one bit right */
  #PUSH, 128  /* 2 in 26.6 */
  DIV[]
  DUP[]
  NOT[]
  IF[]
    ROLL[]
    NOT[]
    ROLL[]
    AND[]
    SWAP[]
    POP[]
    SWAP[]
    POP[]
    #PUSH, BPEnd /* 29  End */

    JMPR[], (BPEnd=#LEndFn)

  EIF[]
  ROLL[]
  #PUSH, 128  /* 2 in 26.6 */
  DIV[]
  DUP[]
  NOT[]
  IF[]
    POP[]
    POP[]
    SWAP[]
    POP[]
    #PUSH, BZEnd /* End */

    JMPR[], (BZEnd=#LEndFn)

  EIF[]
  #PUSH, 4
  MINDEX[]
  #PUSH, 1
  SUB[]
  #PUSH, WReLoop  /* -77 TopLoop */

JMPR[], (WReLoop=#LTopLoop)

/* EndClear: */
#LEndClear:
SWAP[]
POP[]
#LEndFn:
/* End: */
#END
#PUSHON
ENDF[]


</assembly>
  </fpgm>
  <prep>
    <assembly>/* auto-generated pre-program */
/* VTT 6.35 compiler Fri Jun 23 16:48:57 2023 */

/* Grey scaling? */
CALL[], 84

/* InstructionsOn */
#PUSHOFF
MPPEM[]
#PUSH, 2047
GT[]
MPPEM[]
#PUSH, 8
LT[]
OR[]
#PUSH, 1
GETINFO[]
#PUSH, 37
GTEQ[]
#PUSH, 1
GETINFO[]
#PUSH, 64
LTEQ[]
AND[]
#PUSH, 6
GETINFO[]
#PUSH, 0
NEQ[]
AND[]
OR[]
IF[]
    #PUSH, 1, 1
    INSTCTRL[]
EIF[]
#PUSHON

/* DropOutCtrlOff */
SCANCTRL[], 400

SCANTYPE[], 1
SCANTYPE[], 5

/* CvtCutIn */
SVTCA[Y]
SCVTCI[], 64
WS[], 3, 64
#PUSHOFF
MPPEM[]
#PUSH, 144
GTEQ[]
IF[]
#PUSH, 3, 0, 0
SCVTCI[]
WS[]
EIF[]
#PUSHON

/* ClearTypeCtrl */
#PUSHOFF
#PUSH, 2, 2
RS[]
LTEQ[]
IF[]
    #PUSH, 4, 3
    INSTCTRL[]
EIF[]
#PUSHON

WS[], 16, 0
/* LinearAdvanceWidths */
SVTCA[Y]
CALL[], 2, 89
SVTCA[Y]
CALL[], 8, 89
CALL[], 3, 41, 2, 85
CALL[], 9, 41, 8, 85
SVTCA[Y]
CALL[], 0, 89
SVTCA[Y]
CALL[], 6, 89
SVTCA[Y]
CALL[], 10, 89
SVTCA[Y]
CALL[], 14, 89
CALL[], 1, 32, 0, 85
CALL[], 7, 41, 6, 85
CALL[], 11, 41, 10, 85
CALL[], 15, 38, 14, 85
SVTCA[Y]
CALL[], 4, 89
SVTCA[Y]
CALL[], 12, 89
CALL[], 5, 41, 4, 85
CALL[], 13, 41, 12, 85
SVTCA[Y]
CALL[], 16, 89
SVTCA[Y]
CALL[], 18, 89
CALL[], 17, 41, 2, 85
CALL[], 19, 52, 18, 85
SVTCA[X]
CALL[], 21, 25, 62, 22, 149, 90
SVTCA[X]
CALL[], 23, 52, 22, 16, 91
SVTCA[X]
CALL[], 26, 47, 25, 10, 91
SVTCA[X]
CALL[], 24, 52, 22, 16, 91
SVTCA[X]
CALL[], 27, 47, 25, 10, 91
SVTCA[X]
CALL[], 28, 22, 255, 31
CALL[], 29, 28, 114, 31
CALL[], 30, 22, 61, 31
SVTCA[Y]
CALL[], 31, 23, 74, 31
CALL[], 32, 23, 255, 31
CALL[], 33, 32, 147, 31
SVTCA[X]
CALL[], 34, 23, 24, 22, 92
CALL[], 35, 34, 38, 31
CALL[], 36, 34, 86, 31
CALL[], 37, 34, 64, 31
CALL[], 38, 22, 64, 31
SVTCA[X]
CALL[], 39, 25, 255, 31
CALL[], 40, 39, 147, 31
SVTCA[Y]
CALL[], 41, 6, 26, 25, 92
SVTCA[Y]
CALL[], 42, 41, 49, 31
SVTCA[Y]
CALL[], 43, 16, 26, 25, 92
CALL[], 44, 27, 79, 31
CALL[], 45, 44, 34, 31
CALL[], 46, 44, 205, 31
CALL[], 47, 46, 74, 31
SVTCA[X]
CALL[], 48, 60, 27, 25, 92
CALL[], 49, 48, 24, 31
SVTCA[X]
CALL[], 52, 51, 25, 31
SVTCA[Y]
CALL[], 54, 53, 103, 31
CALL[], 56, 55, 49, 31
SVTCA[X]
CALL[], 59, 58, 47, 31
CALL[], 60, 59, 54, 31
CALL[], 61, 58, 18, 31
CALL[], 62, 61, 43, 31
SVTCA[Y]
CALL[], 65, 64, 40, 31
CALL[], 68, 67, 41, 31
CALL[], 69, 67, 21, 31
CALL[], 71, 70, 114, 31
SVTCA[X]
CALL[], 72, 28, 29, 31
CALL[], 73, 29, 114, 31
CALL[], 74, 29, 255, 31
CALL[], 75, 28, 255, 31
CALL[], 76, 30, 255, 31
SVTCA[Y]
CALL[], 77, 31, 94, 31
CALL[], 78, 31, 255, 31
CALL[], 79, 32, 255, 31
CALL[], 80, 33, 255, 31
CALL[], 81, 33, 128, 31
CALL[], 82, 35, 103, 31
CALL[], 83, 35, 255, 31
CALL[], 84, 36, 255, 31
CALL[], 85, 34, 255, 31
CALL[], 86, 34, 128, 31
CALL[], 87, 37, 205, 31
CALL[], 88, 37, 255, 31
CALL[], 89, 34, 32, 31
CALL[], 90, 38, 255, 31
CALL[], 91, 38, 79, 31
SVTCA[X]
CALL[], 92, 39, 45, 31
CALL[], 93, 40, 255, 31
CALL[], 94, 39, 255, 31
CALL[], 95, 39, 128, 31
SVTCA[Y]
CALL[], 96, 41, 28, 31
CALL[], 97, 42, 128, 31
CALL[], 98, 42, 255, 31
CALL[], 99, 42, 205, 31
CALL[], 100, 41, 114, 31
CALL[], 101, 41, 255, 31
CALL[], 102, 43, 255, 31
CALL[], 103, 43, 57, 31
CALL[], 104, 45, 255, 31
CALL[], 105, 46, 255, 31
CALL[], 106, 47, 255, 31
CALL[], 107, 49, 255, 31
CALL[], 108, 49, 147, 31
CALL[], 109, 48, 114, 31
CALL[], 110, 48, 255, 31
CALL[], 111, 48, 171, 31
SVTCA[X]
CALL[], 112, 50, 255, 31
CALL[], 113, 52, 255, 31
CALL[], 114, 52, 128, 31
CALL[], 115, 51, 171, 31
CALL[], 116, 51, 255, 31
SVTCA[Y]
CALL[], 117, 54, 128, 31
CALL[], 118, 54, 255, 31
CALL[], 119, 53, 255, 31
CALL[], 120, 53, 103, 31
CALL[], 121, 56, 255, 31
CALL[], 122, 55, 255, 31
CALL[], 123, 55, 74, 31
CALL[], 124, 57, 205, 31
CALL[], 125, 57, 255, 31
SVTCA[X]
CALL[], 126, 58, 103, 31
CALL[], 127, 58, 255, 31
CALL[], 128, 59, 94, 31
CALL[], 129, 59, 255, 31
CALL[], 130, 60, 128, 31
CALL[], 131, 60, 255, 31
CALL[], 132, 61, 128, 31
CALL[], 133, 61, 255, 31
CALL[], 134, 62, 255, 31
CALL[], 135, 63, 255, 31
SVTCA[Y]
CALL[], 136, 64, 52, 31
CALL[], 137, 64, 128, 31
CALL[], 138, 64, 255, 31
CALL[], 139, 64, 103, 31
CALL[], 140, 65, 255, 31
CALL[], 141, 65, 128, 31
CALL[], 142, 65, 57, 31
CALL[], 143, 66, 147, 31
CALL[], 144, 66, 171, 31
CALL[], 145, 67, 103, 31
CALL[], 146, 67, 205, 31
CALL[], 147, 67, 255, 31
CALL[], 148, 67, 147, 31
CALL[], 149, 67, 86, 31
CALL[], 150, 68, 171, 31
CALL[], 151, 68, 255, 31
CALL[], 152, 68, 128, 31
CALL[], 153, 69, 255, 31
CALL[], 154, 69, 52, 31
CALL[], 155, 71, 255, 31
CALL[], 156, 70, 255, 31
CALL[], 158, 41, 157, 85
RTG[]
</assembly>
  </prep>
  <cvt>
    <talk>/* Control Program */
/* ACT generated Fri Jun 23 01:02:17 2023 */

CATEGORY Stroke
CATEGORY StrokeInheritance

InstructionsOn @8..2047

DropOutCtrlOff @144

CvtCutIn = 1, 0@144 /* 1 pixel cut-in for over- and undershoots */

ClearTypeCtrl = 1

ASM("WS[], 16, 0") /* &lt;== S[16] = threshold ppem that less than or equal is no RES */

LinearAdvanceWidths = 0

/***** Height CVTs *****/
UpperCase
  Grey
  Y
  SquareHeight
      2:  1433 /* cap height */
ASM("SVTCA[Y]")
ASM("CALL[], 2, 89")
      8:     0 /* base line */
ASM("SVTCA[Y]")
ASM("CALL[], 8, 89")
  RoundHeight
      3:    25 ~   2 @ 41 /* cap height overshoot */
      9:   -25 ~   8 @ 41 /* base line undershoot */

LowerCase
  SquareHeight
      0:  1572 /* lc ascender */
ASM("SVTCA[Y]")
ASM("CALL[], 0, 89")
      6:  1049 /* x height */
ASM("SVTCA[Y]")
ASM("CALL[], 6, 89")
     10:     0 /* base line */
ASM("SVTCA[Y]")
ASM("CALL[], 10, 89")
     14:  -508 /* lc descender */
ASM("SVTCA[Y]")
ASM("CALL[], 14, 89")
  RoundHeight
      1:   -32 ~   0 @ 32 /* lc ascender overshoot */
      7:     8 ~   6 @ 41 /* x height overshoot */
     11:   -25 ~  10 @ 41 /* base line undershoot */
     15:    27 ~  14 @ 38 /* lc descender undershoot */

Figure
  SquareHeight
      4:  1434 /* figure height */
ASM("SVTCA[Y]")
ASM("CALL[], 4, 89")
     12:     0 /* base line */
ASM("SVTCA[Y]")
ASM("CALL[], 12, 89")
  RoundHeight
      5:    25 ~   4 @ 41 /* figure height overshoot */
     13:   -25 ~  12 @ 41 /* base line undershoot */

Other
  SquareHeight
     16:  1433 /* other height */
ASM("SVTCA[Y]")
ASM("CALL[], 16, 89")
     18:     1024 /* base line */
ASM("SVTCA[Y]")
ASM("CALL[], 18, 89")
  RoundHeight
     17:    35 ~  2 @ 41 /* other height overshoot */
     19:   -20 ~  18 @ 52 /* base line undershoot */

/***** Reserved CVTs *****/
AnyGroup
  AnyColor
  AnyDirection
  AnyCategory
     20:     0 /* DO NOT USE!!! */

/***** Grand-Parent CVT *****/
AnyGroup
  Black
  X
  StrokeInheritance
     21:   320 /* 49x */

/***** Parent CVTs *****/
UpperCase
  Black
  X
  StrokeInheritance
     22:   323 /* 25x */
LowerCase
  Black
  X
  StrokeInheritance
     25:   316 /* 24x */
ASM("SVTCA[X]")
ASM("CALL[], 21, 25, 62, 22, 149, 90")

UpperCase
  Black
  Y
  StrokeInheritance
     23:   263 /* 12x */
ASM("SVTCA[X]")
ASM("CALL[], 23, 52, 22, 16, 91")
LowerCase
  Black
  Y
  StrokeInheritance
     26:   233 /* 5x */
ASM("SVTCA[X]")
ASM("CALL[], 26, 47, 25, 10, 91")

UpperCase
  Black
  Diag
  StrokeInheritance
     24:   263 /* 12x */
ASM("SVTCA[X]")
ASM("CALL[], 24, 52, 22, 16, 91")
LowerCase
  Black
  Diag
  StrokeInheritance
     27:   233 /* 5x */
ASM("SVTCA[X]")
ASM("CALL[], 27, 47, 25, 10, 91")

/***** StrokeInheritance CVTs *****/
UpperCase
  Black
  X
  StrokeInheritance
     28:   323 =  22 @255 /* 26x */
     29:   314 =  28 @114 /* 6x */
     30:   340 =  22 @ 61 /* 12x */
  Y
  StrokeInheritance
     31:   249 =  23 @ 74 /* 6x */
     32:   263 =  23 @255 /* 22x */
     33:   270 =  32 @147 /* 9x */
  Diag
  StrokeInheritance
     34:   285 /* 26x */
ASM("SVTCA[X]")
ASM("CALL[], 34, 23, 24, 22, 92")
     35:   258 =  34 @ 38 /* 6x */
     36:   271 =  34 @ 86 /* 4x */
     37:   300 =  34 @ 64 /* 6x */
     38:   339 =  22 @ 64 /* 2x */

LowerCase
  Black
  X
  StrokeInheritance
     39:   316 =  25 @255 /* 37x */
     40:   309 =  39 @147 /* 4x */
  Y
  StrokeInheritance
     41:   241 /* 22x */
ASM("SVTCA[Y]")
ASM("CALL[], 41, 6, 26, 25, 92")
     42:   221 =  41 @ 49 /* 3x */
     43:   254 /* 12x */
ASM("SVTCA[Y]")
ASM("CALL[], 43, 16, 26, 25, 92")
  Diag
  StrokeInheritance
     44:   220 =  27 @ 79 /* 6x */
     45:   189 =  44 @ 34 /* 2x */
     46:   215 =  44 @205 /* 4x */
     47:   229 =  46 @ 74 /* 2x */
     48:   312 /* 14x */
ASM("SVTCA[X]")
ASM("CALL[], 48, 60, 27, 25, 92")
     49:   268 =  48 @ 24 /* 4x */

Figure
  Black
  X
  StrokeInheritance
     50:   146 /* 1x */
     51:   322 /* 16x */
     52:   280 =  51 @ 25 /* 3x */
  Y
  StrokeInheritance
     53:   252 /* 21x */
     54:   242 =  53 @103 /* 6x */
  Diag
  StrokeInheritance
     55:   258 /* 10x */
     56:   237 =  55 @ 49 /* 2x */
     57:   320 /* 2x */

Other
  Black
  X
  StrokeInheritance
     58:   236 /* 22x */
     59:   257 =  58 @ 47 /* 9x */
     60:   276 =  59 @ 54 /* 3x */
     61:   294 =  58 @ 18 /* 6x */
     62:   318 =  61 @ 43 /* 2x */
     63:   408 /* 2x */
  Y
  StrokeInheritance
     64:   197 /* 24x */
     65:   223 =  64 @ 40 /* 8x */
     66:   269 /* 2x */
  Diag
  StrokeInheritance
     67:   210 /* 30x */
     68:   235 =  67 @ 41 /* 8x */
     69:   259 =  67 @ 21 /* 7x */
     70:   341 /* 24x */
     71:   332 =  70 @114 /* 12x */

/***** Stroke CVTs *****/
UpperCase
  Black
  X
  Stroke
     72:   287 =  28 @ 29 /* 1x */
     73:   305 =  29 @114 /* 2x */
     74:   313 =  29 @255 /* 4x */
     75:   323 =  28 @255 /* 19x */
     76:   340 =  30 @255 /* 12x */
  Y
  Stroke
     77:   238 =  31 @ 94 /* 2x */
     78:   248 =  31 @255 /* 4x */
     79:   263 =  32 @255 /* 13x */
     80:   270 =  33 @255 /* 8x */
     81:   278 =  33 @128 /* 1x */
  Diag
  Stroke
     82:   248 =  35 @103 /* 1x */
     83:   258 =  35 @255 /* 5x */
     84:   272 =  36 @255 /* 4x */
     85:   281 =  34 @255 /* 5x */
     86:   289 =  34 @128 /* 4x */
     87:   295 =  37 @205 /* 2x */
     88:   300 =  37 @255 /* 4x */
     89:   316 =  34 @ 32 /* 1x */
     90:   337 =  38 @255 /* 1x */
     91:   352 =  38 @ 79 /* 1x */

LowerCase
  Black
  X
  Stroke
     92:   293 =  39 @ 45 /* 1x */
     93:   308 =  40 @255 /* 4x */
     94:   316 =  39 @255 /* 24x */
     95:   324 =  39 @128 /* 8x */
  Y
  Stroke
     96:   204 =  41 @ 28 /* 2x */
     97:   213 =  42 @128 /* 1x */
     98:   220 =  42 @255 /* 2x */
     99:   225 =  42 @205 /* 1x */
    100:   233 =  41 @114 /* 6x */
    101:   242 =  41 @255 /* 10x */
    102:   255 =  43 @255 /* 10x */
    103:   272 =  43 @ 57 /* 2x */
  Diag
  Stroke
    104:   189 =  45 @255 /* 2x */
    105:   213 =  46 @255 /* 2x */
    106:   229 =  47 @255 /* 2x */
    107:   268 =  49 @255 /* 3x */
    108:   275 =  49 @147 /* 1x */
    109:   302 =  48 @114 /* 1x */
    110:   311 =  48 @255 /* 5x */
    111:   317 =  48 @171 /* 4x */

Figure
  Black
  X
  Stroke
    112:   146 =  50 @255 /* 1x */
    113:   280 =  52 @255 /* 2x */
    114:   288 =  52 @128 /* 1x */
    115:   316 =  51 @171 /* 1x */
    116:   322 =  51 @255 /* 12x */
  Y
  Stroke
    117:   234 =  54 @128 /* 3x */
    118:   242 =  54 @255 /* 4x */
    119:   252 =  53 @255 /* 11x */
    120:   262 =  53 @103 /* 3x */
  Diag
  Stroke
    121:   237 =  56 @255 /* 2x */
    122:   257 =  55 @255 /* 6x */
    123:   271 =  55 @ 74 /* 2x */
    124:   315 =  57 @205 /* 1x */
    125:   324 =  57 @255 /* 1x */

Other
  Black
  X
  Stroke
    126:   222 =  58 @103 /* 1x */
    127:   233 =  58 @255 /* 6x */
    128:   246 =  59 @ 94 /* 1x */
    129:   257 =  59 @255 /* 5x */
    130:   268 =  60 @128 /* 1x */
    131:   276 =  60 @255 /* 2x */
    132:   290 =  61 @128 /* 1x */
    133:   297 =  61 @255 /* 3x */
    134:   318 =  62 @255 /* 2x */
    135:   408 =  63 @255 /* 2x */
  Y
  Stroke
    136:   178 =  64 @ 52 /* 1x */
    137:   192 =  64 @128 /* 6x */
    138:   201 =  64 @255 /* 8x */
    139:   210 =  64 @103 /* 1x */
    140:   223 =  65 @255 /* 5x */
    141:   231 =  65 @128 /* 1x */
    142:   241 =  65 @ 57 /* 2x */
    143:   262 =  66 @147 /* 1x */
    144:   275 =  66 @171 /* 1x */
  Diag
  Stroke
    145:   200 =  67 @103 /* 2x */
    146:   205 =  67 @205 /* 4x */
    147:   211 =  67 @255 /* 5x */
    148:   217 =  67 @147 /* 3x */
    149:   222 =  67 @ 86 /* 1x */
    150:   229 =  68 @171 /* 1x */
    151:   236 =  68 @255 /* 4x */
    152:   243 =  68 @128 /* 3x */
    153:   259 =  69 @255 /* 5x */
    154:   279 =  69 @ 52 /* 2x */
    155:   333 =  71 @255 /* 12x */
    156:   342 =  70 @255 /* 12x */

/***** Additional CVTs *****/
    157:   1141
    158:     8 ~   157 @ 41
    159:   1331
    160:   1118
</talk>
  </cvt>
  <glyf>
    <TTGlyph ID="0">
      <instructions>
        <talk>/* VTTTalk Unicode 0xffff */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 18  DISABLED for a NON-LATIN glyph */
/* CVT 1 17  DISABLED for a NON-LATIN glyph */
/* Min and Max */
YAnchor(0)	/* min */
YAnchor(1)	/* max */

/* YDir: Stroke #0 */
ResYDist(1,7) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
ResYDist(0,4) /*perpendicular to the stroke*/

Smooth()

</talk>
        <assembly>
/* TT glyph 0, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
MDAP[R], 0
MDAP[R], 1
CALL[], 1, 7, 106
CALL[], 0, 4, 106
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="1">
      <instructions>
        <talk>/* VTTTalk glyph 1, char 0x41 (A) */
/* GUI generated Fri Jun 23 01:03:41 2023 */

/* Y direction */
ResYAnchor(19,8)
YShift(19,9)
ResYAnchor(31,2)
YIPAnchor(31,14,19)
YInterpolate(31,35,14)
ResYDist(14,38)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 1, char 0x41 (A) */
/* VTT 6.35 compiler Fri Jun 23 01:03:41 2023 */
SVTCA[Y]
CALL[], 19, 8, 114
SHP[2], 9
CALL[], 31, 2, 114
SRP1[], 19
IP[], 14
MDAP[R], 14
IP[], 35
CALL[], 14, 38, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="2">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc1 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 1, 0, 0
OFFSET[R], 353, 1155, 59
SVTCA[Y]
MDAP[R], 31
MDRP[m&gt;RWh], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="3">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc2 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 1, 0, 0
OFFSET[R], 355, 1125, 59
SVTCA[Y]
MDAP[R], 31
MDRP[m&gt;RWh], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="4">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc4 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 1, 0, 0
OFFSET[R], 350, 1149, 59
SVTCA[Y]
MDAP[R], 31
MDRP[m&gt;RWh], 55
MDRP[m&gt;RWh], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="5">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc0 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 1, 0, 0
OFFSET[R], 352, 1101, 59
SVTCA[Y]
MDAP[R], 31
MDRP[m&gt;RWh], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="6">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc5 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 358, 1026, -9
USEMYMETRICS[]
OFFSET[R], 1, 0, 0
SVTCA[Y]
MDAP[R], 55
MDRP[m&gt;RWh], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="7">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc3 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 1, 0, 0
OFFSET[R], 359, 1135, 59
SVTCA[Y]
MDAP[R], 31
MDRP[m&gt;RWh], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="8">
      <instructions>
        <talk>/* VTTTalk glyph 8, char 0xc6 */
/* GUI generated Fri Jun 23 01:04:09 2023 */

/* Y direction */
ResYAnchor(4,8)
YShift(4,72)
ResYDist(72,56)
ResYAnchor(19,2)
ResYDist(19,35)
YShift(35,81)
YIPAnchor(19,52,78,4)
ResYDist(52,36)
ResYDist(78,86)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 8, char 0xc6 */
/* VTT 6.35 compiler Fri Jun 23 01:04:09 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
SHP[2], 72
CALL[], 72, 56, 106
CALL[], 19, 2, 114
CALL[], 19, 35, 106
SHP[2], 81
SRP2[], 4
IP[], 52
IP[], 78
MDAP[R], 52
MDAP[R], 78
CALL[], 52, 36, 106
CALL[], 78, 86, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="9">
      <instructions>
        <talk>/* VTTTalk glyph 9, char 0x42 (B) */
/* GUI generated Fri Jun 23 01:06:21 2023 */

/* Y direction */
ResYAnchor(0,8)
ResYDist(0,30)
ResYAnchor(9,2)
ResYDist(9,60)
YIPAnchor(0,38,9)
ResYDist(38,52)
YInterpolate(52,17,18,38)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 9, char 0x42 (B) */
/* VTT 6.35 compiler Fri Jun 23 01:06:21 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 0, 30, 106
CALL[], 9, 2, 114
CALL[], 9, 60, 106
SRP2[], 0
IP[], 38
MDAP[R], 38
CALL[], 38, 52, 106
IP[], 17
IP[], 18
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="10">
      <instructions>
        <talk>/* VTTTalk Unicode 0x43 (C) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 27 9 */
/* CVT 36 3 */
/* Min and Max */
ResYAnchor(27,9)	/* min, CVT */
ResYAnchor(36,3)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(36,60) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
ResYDist(27,0) /*perpendicular to the stroke*/

Smooth()
</talk>
        <assembly>
/* TT glyph 10, char 0x43 (C) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 27, 9, 114
CALL[], 36, 3, 114
CALL[], 36, 60, 106
CALL[], 27, 0, 106
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="11">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc7 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 10, 0, 0
OFFSET[R], 362, 1087, -15</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="12">
      <instructions>
        <talk>/* VTTTalk Unicode 0x44 (D) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 8 */
/* CVT 9 2 */
/* Min and Max */
ResYAnchor(0,8)	/* min, CVT */
ResYAnchor(9,2)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(9,19) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
ResYDist(0,26) /*perpendicular to the stroke*/

Smooth()

</talk>
        <assembly>
/* TT glyph 12, char 0x44 (D) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 9, 2, 114
CALL[], 9, 19, 106
CALL[], 0, 26, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="13">
      <instructions>
        <talk>/* VTTTalk Unicode 0xd0 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 8 */
/* CVT 13 2 */
/* Min and Max */
ResYAnchor(0,8)	/* min, CVT */
ResYAnchor(13,2)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(13,23) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
YInterpolate(13,41,0)
YAnchor(41)
ResYDist(41,27) /*perpendicular to the stroke*/
YShift(41,6) /*along bottom edge*/
YShift(27,7) /*along top edge*/

/* YDir: Stroke #2 */
ResYDist(0,45) /*perpendicular to the stroke*/

Smooth()
</talk>
        <assembly>
/* TT glyph 13, char 0xd0 */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 13, 2, 114
CALL[], 13, 23, 106
SRP2[], 0
IP[], 41
MDAP[R], 41
CALL[], 41, 27, 106
SHP[1], 6
SHP[2], 7
CALL[], 0, 45, 106
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="14">
      <instructions>
        <talk>/* VTTTalk glyph 14, char 0x45 (E) */
/* GUI generated Fri Jun 23 01:06:53 2023 */

/* Y direction */
ResYAnchor(0,8)
ResYDist(0,49)
ResYAnchor(9,2)
ResYDist(9,25)
YIPAnchor(9,45,0)
ResYDist(45,29)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 14, char 0x45 (E) */
/* VTT 6.35 compiler Fri Jun 23 01:06:53 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 0, 49, 106
CALL[], 9, 2, 114
CALL[], 9, 25, 106
SRP2[], 0
IP[], 45
MDAP[R], 45
CALL[], 45, 29, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="15">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc9 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 14, 0, 0
OFFSET[R], 353, 1016, 59
SVTCA[Y]
CALL[], 65, 9, 1, 1, 109, 86
SHC[2], 1</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="16">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xca */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 14, 0, 0
OFFSET[R], 355, 986, 59
SVTCA[Y]
CALL[], 65, 9, 1, 1, 116, 86
SHC[2], 1</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="17">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xcb */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 14, 0, 0
OFFSET[R], 350, 1010, 59
SVTCA[Y]
MDAP[R], 9
MDRP[m&gt;RWh], 77
MDRP[m&gt;RWh], 65
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="18">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xc8 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 14, 0, 0
OFFSET[R], 352, 962, 59
SVTCA[Y]
CALL[], 65, 9, 1, 1, 125, 86
SHC[2], 1</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="19">
      <instructions>
        <talk>/* VTTTalk glyph 19, char 0x46 (F) */
/* GUI generated Fri Jun 23 01:07:03 2023 */

/* Y direction */
ResYAnchor(22,8)
ResYAnchor(30,2)
ResYDist(30,46)
YIPAnchor(30,17,22)
ResYDist(17,1)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 19, char 0x46 (F) */
/* VTT 6.35 compiler Fri Jun 23 01:07:03 2023 */
SVTCA[Y]
CALL[], 22, 8, 114
CALL[], 30, 2, 114
CALL[], 30, 46, 106
SRP2[], 22
IP[], 17
MDAP[R], 17
CALL[], 17, 1, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="20">
      <instructions>
        <talk>/* VTTTalk glyph 20, char 0x47 (G) */
/* GUI generated Fri Jun 23 01:30:57 2023 */

/* Y direction */
ResYAnchor(4,9)
YShift(4,0)
ResYDist(4,42)
YShift(42,45)
ResYAnchor(11,3)
ResYDist(11,36)
YIPAnchor(42,52,36)
YInterpolate(52,29,36)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 20, char 0x47 (G) */
/* VTT 6.35 compiler Fri Jun 23 01:30:57 2023 */
SVTCA[Y]
CALL[], 4, 9, 114
SHP[2], 0
CALL[], 4, 42, 106
SHP[2], 45
CALL[], 11, 3, 114
CALL[], 11, 36, 106
SRP1[], 42
IP[], 52
MDAP[R], 52
IP[], 29
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="21">
      <instructions>
        <talk>/* VTTTalk glyph 21, char 0x48 (H) */
/* GUI generated Fri Jun 23 01:18:25 2023 */

/* Y direction */
YAnchor(6,17)
ResYAnchor(28,8)
YShift(28,18)
ResYAnchor(35,2)
YIPAnchor(28,23,35)
ResYDist(23,40)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 21, char 0x48 (H) */
/* VTT 6.35 compiler Fri Jun 23 01:18:25 2023 */
SVTCA[Y]
MIAP[R], 6, 17
CALL[], 28, 8, 114
SHP[2], 18
CALL[], 35, 2, 114
SRP2[], 28
IP[], 23
MDAP[R], 23
CALL[], 23, 40, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="22">
      <instructions>
        <talk>/* VTTTalk glyph 22, char 0x49 (I) */
/* GUI generated Fri Jun 23 01:18:17 2023 */

/* Y direction */
ResYAnchor(4,8)
ResYAnchor(14,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 22, char 0x49 (I) */
/* VTT 6.35 compiler Fri Jun 23 01:18:17 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
CALL[], 14, 17, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="23">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xcd */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 22, 0, 0
OFFSET[R], 353, 761, 59
SVTCA[Y]
MDAP[R], 14
MDRP[m&gt;RWh], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="24">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xce */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 22, 0, 0
OFFSET[R], 355, 731, 59
SVTCA[Y]
MDAP[R], 14
MDRP[m&gt;RWh], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="25">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xcf */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 22, 0, 0
OFFSET[R], 350, 755, 59
SVTCA[Y]
MDAP[R], 14
MDRP[m&gt;RWh], 34
MDRP[m&gt;RWh], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="26">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xcc */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 22, 0, 0
OFFSET[R], 352, 707, 59
SVTCA[Y]
MDAP[R], 14
MDRP[m&gt;RWh], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="27">
      <instructions>
        <talk>/* VTTTalk glyph 27, char 0x4a (J) */
/* GUI generated Fri Jun 23 02:14:23 2023 */

/* Y direction */
YAnchor(7)
YShift(7,14)
ResYAnchor(25,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 27, char 0x4a (J) */
/* VTT 6.35 compiler Fri Jun 23 02:14:23 2023 */
SVTCA[Y]
MDAP[R], 7
SHP[1], 14
CALL[], 25, 17, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="28">
      <instructions>
        <talk>/* VTTTalk glyph 28, char 0x4b (K) */
/* GUI generated Fri Jun 23 01:18:35 2023 */

/* Y direction */
ResYAnchor(4,8)
YShift(4,61)
ResYAnchor(14,17)
YShift(14,12)
YShift(14,16)
YShift(14,35)
YIPAnchor(14,69,4)
ResYDist(69,22)
YInterpolate(69,49,48,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 28, char 0x4b (K) */
/* VTT 6.35 compiler Fri Jun 23 01:18:35 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
SHP[2], 61
CALL[], 14, 17, 114
SHP[2], 12
SHP[2], 16
SHP[2], 35
SRP1[], 4
IP[], 69
MDAP[R], 69
CALL[], 69, 22, 106
IP[], 49
IP[], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="29">
      <instructions>
        <talk>/* VTTTalk glyph 29, char 0x4c (L) */
/* GUI generated Fri Jun 23 01:18:38 2023 */

/* Y direction */
ResYAnchor(0,8)
ResYDist(0,22)
ResYAnchor(11,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 29, char 0x4c (L) */
/* VTT 6.35 compiler Fri Jun 23 01:18:38 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 0, 22, 106
CALL[], 11, 17, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="30">
      <instructions>
        <talk>/* VTTTalk glyph 30, char 0x4d (M) */
/* GUI generated Fri Jun 23 01:15:03 2023 */

/* Y direction */
ResYAnchor(59,8)
YShift(59,24)
ResYAnchor(68,2)
YShift(68,12)
YIPAnchor(59,42,68)
YInterpolate(42,0,33,50,68)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 30, char 0x4d (M) */
/* VTT 6.35 compiler Fri Jun 23 01:15:03 2023 */
SVTCA[Y]
CALL[], 59, 8, 114
SHP[2], 24
CALL[], 68, 2, 114
SHP[2], 12
SRP2[], 59
IP[], 42
MDAP[R], 42
SRP2[], 68
SLOOP[], 3
IP[], 0, 33, 50
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="31">
      <instructions>
        <talk>/* VTTTalk glyph 31, char 0x4e (N) */
/* GUI generated Fri Jun 23 01:15:34 2023 */

/* Y direction */
ResYAnchor(4,8)
YShift(4,41)
ResYAnchor(11,2)
YInterpolate(4,22,51,11)
ResYAnchor(29,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 31, char 0x4e (N) */
/* VTT 6.35 compiler Fri Jun 23 01:15:34 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
SHP[2], 41
CALL[], 11, 2, 114
SRP2[], 4
IP[], 22
IP[], 51
CALL[], 29, 16, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="32">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd1 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 31, 0, 0
OFFSET[R], 359, 1233, 59
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 62
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="33">
      <instructions>
        <talk>/* VTTTalk Unicode 0x4f (O) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 9 */
/* CVT 7 3 */
/* Min and Max */
ResYAnchor(0,9)	/* min, CVT */
ResYAnchor(7,3)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(7,20) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
ResYDist(0,14) /*perpendicular to the stroke*/

Smooth()

</talk>
        <assembly>
/* TT glyph 33, char 0x4f (O) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 0, 9, 114
CALL[], 7, 3, 114
CALL[], 7, 20, 106
CALL[], 0, 14, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="34">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd3 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 33, 0, 0
OFFSET[R], 353, 1221, 59
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="35">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd4 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 33, 0, 0
OFFSET[R], 355, 1191, 59
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="36">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd6 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 33, 0, 0
OFFSET[R], 350, 1215, 59
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 37
MDRP[m&gt;RWh], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="37">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd2 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 33, 0, 0
OFFSET[R], 352, 1167, 59
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="38">
      <instructions>
        <talk>/* VTTTalk glyph 38, char 0xd8 */
/* GUI generated Fri Jun 23 01:19:18 2023 */

/* Y direction */
ResYAnchor(0,3)
ResYDist(0,25)
YDist(0,3)
YShift(3,4)
ResYAnchor(12,9)
ResYDist(12,40)
YInterpolate(12,15,18,37,31,36,32,5,2,0)
YDist(12,16)
YShift(16,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 38, char 0xd8 */
/* VTT 6.35 compiler Fri Jun 23 01:19:18 2023 */
SVTCA[Y]
CALL[], 0, 3, 114
CALL[], 0, 25, 106
SRP0[], 0
MDRP[m&lt;RWh], 3
SHP[2], 4
CALL[], 12, 9, 114
CALL[], 12, 40, 106
SRP2[], 0
SLOOP[], 8
IP[], 15, 18, 37, 31, 36, 32, 5, 2
SRP0[], 12
MDRP[m&lt;RWh], 16
SHP[2], 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="39">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd5 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 33, 0, 0
OFFSET[R], 359, 1201, 59
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="40">
      <instructions>
        <talk>/* VTTTalk glyph 40, char 0x152 */
/* GUI generated Fri Jun 23 01:19:29 2023 */

/* Y direction */
ResYAnchor(0,8)
ResYDist(0,58)
YShift(58,42)
ResYAnchor(8,2)
YIPAnchor(8,41,0)
ResYDist(41,25)
ResYDist(8,61)
YShift(61,24)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 40, char 0x152 */
/* VTT 6.35 compiler Fri Jun 23 01:19:29 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 0, 58, 106
SHP[2], 42
CALL[], 8, 2, 114
SRP1[], 0
IP[], 41
MDAP[R], 41
CALL[], 41, 25, 106
CALL[], 8, 61, 106
SHP[2], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="41">
      <instructions>
        <talk>/* VTTTalk glyph 41, char 0x50 (P) */
/* GUI generated Fri Jun 23 01:19:57 2023 */

/* Y direction */
ResYAnchor(28,8)
ResYAnchor(36,2)
ResYDist(36,20)
YIPAnchor(28,0,36)
ResYDist(0,13)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 41, char 0x50 (P) */
/* VTT 6.35 compiler Fri Jun 23 01:19:57 2023 */
SVTCA[Y]
CALL[], 28, 8, 114
CALL[], 36, 2, 114
CALL[], 36, 20, 106
SRP2[], 28
IP[], 0
MDAP[R], 0
CALL[], 0, 13, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="42">
      <instructions>
        <talk>/* VTTTalk glyph 42, char 0xde */
/* GUI generated Fri Jun 23 01:20:09 2023 */

/* Y direction */
ResYAnchor(4,8)
ResYAnchor(14,17)
YIPAnchor(14,22,31,4)
ResYDist(22,39)
ResYDist(31,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 42, char 0xde */
/* VTT 6.35 compiler Fri Jun 23 01:20:09 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
CALL[], 14, 17, 114
SRP1[], 4
IP[], 22
IP[], 31
MDAP[R], 22
MDAP[R], 31
CALL[], 22, 39, 106
CALL[], 31, 32, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="43">
      <instructions>
        <talk>/* VTTTalk glyph 43, char 0x51 (Q) */
/* GUI generated Fri Jun 23 01:20:38 2023 */

/* Y direction */
YAnchor(2)
ResYDist(2,21)
YAnchor(6,9)
YShift(6,18)
ResYDist(6,33)
ResYAnchor(12,3)
ResYDist(12,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 43, char 0x51 (Q) */
/* VTT 6.35 compiler Fri Jun 23 01:20:38 2023 */
SVTCA[Y]
MDAP[R], 2
CALL[], 2, 21, 106
MIAP[R], 6, 9
SHP[1], 18
CALL[], 6, 33, 106
CALL[], 12, 3, 114
CALL[], 12, 39, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="44">
      <instructions>
        <talk>/* VTTTalk glyph 44, char 0x52 (R) */
/* GUI generated Fri Jun 23 01:22:31 2023 */

/* Y direction */
ResYAnchor(4,8)
YShift(4,32)
ResYAnchor(12,2)
ResYDist(12,55)
YIPAnchor(4,48,12)
ResYDist(48,38)
YInterpolate(38,20,19,48)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 44, char 0x52 (R) */
/* VTT 6.35 compiler Fri Jun 23 01:22:31 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
SHP[2], 32
CALL[], 12, 2, 114
CALL[], 12, 55, 106
SRP2[], 4
IP[], 48
MDAP[R], 48
CALL[], 48, 38, 106
IP[], 20
IP[], 19
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="45">
      <instructions>
        <talk>/* VTTTalk glyph 45, char 0x53 (S) */
/* GUI generated Fri Jun 23 16:51:52 2023 */

/* Y direction */
ResYAnchor(0,9)
ResYDist(0,26)
ResYAnchor(40,3)
ResYDist(40,62)
YInterpolate(0,33,62)
YInterpolate(26,68,40)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 45, char 0x53 (S) */
/* VTT 6.35 compiler Fri Jun 23 16:51:52 2023 */
SVTCA[Y]
CALL[], 0, 9, 114
CALL[], 0, 26, 106
CALL[], 40, 3, 114
CALL[], 40, 62, 106
SRP1[], 0
IP[], 33
SRP1[], 26
SRP2[], 40
IP[], 68
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="46">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x160 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 45, 0, 0
OFFSET[R], 356, 1045, 59
SVTCA[Y]
MDAP[R], 40
MDRP[m&gt;RWh], 81
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="47">
      <instructions>
        <talk>/* VTTTalk glyph 47, char 0x54 (T) */
/* GUI generated Fri Jun 23 01:23:01 2023 */

/* Y direction */
ResYAnchor(4,8)
ResYAnchor(23,2)
YShift(23,21)
ResYDist(23,9)
YShift(9,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 47, char 0x54 (T) */
/* VTT 6.35 compiler Fri Jun 23 01:23:01 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
CALL[], 23, 2, 114
SHP[2], 21
CALL[], 23, 9, 106
SHP[2], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="48">
      <instructions>
        <talk>/* VTTTalk glyph 48, char 0x55 (U) */
/* GUI generated Fri Jun 23 01:23:14 2023 */

/* Y direction */
ResYAnchor(0,9)
ResYDist(0,23)
ResYAnchor(11,17)
YShift(11,34)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 48, char 0x55 (U) */
/* VTT 6.35 compiler Fri Jun 23 01:23:14 2023 */
SVTCA[Y]
CALL[], 0, 9, 114
CALL[], 0, 23, 106
CALL[], 11, 17, 114
SHP[2], 34
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="49">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xda */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 48, 0, 0
OFFSET[R], 353, 1169, 59
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 46
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="50">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xdb */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 48, 0, 0
OFFSET[R], 355, 1139, 59
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 46
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="51">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xdc */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 48, 0, 0
OFFSET[R], 350, 1163, 59
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 58
MDRP[m&gt;RWh], 46
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="52">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xd9 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 48, 0, 0
OFFSET[R], 352, 1115, 59
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 46
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="53">
      <instructions>
        <talk>/* VTTTalk glyph 53, char 0x56 (V) */
/* GUI generated Fri Jun 23 01:23:44 2023 */

/* Y direction */
ResYAnchor(12,17)
YShift(12,38)
ResYAnchor(54,8)
YInterpolate(54,25,12)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 53, char 0x56 (V) */
/* VTT 6.35 compiler Fri Jun 23 01:23:44 2023 */
SVTCA[Y]
CALL[], 12, 17, 114
SHP[2], 38
CALL[], 54, 8, 114
SRP1[], 12
IP[], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="54">
      <instructions>
        <talk>/* VTTTalk glyph 54, char 0x57 (W) */
/* GUI generated Fri Jun 23 01:24:32 2023 */

/* Y direction */
ResYAnchor(13,17)
YShift(13,56)
ResYAnchor(97,8)
YShift(97,73)
YIPAnchor(97,34,13)
YInterpolate(97,43,26,84,34)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 54, char 0x57 (W) */
/* VTT 6.35 compiler Fri Jun 23 01:24:32 2023 */
SVTCA[Y]
CALL[], 13, 17, 114
SHP[2], 56
CALL[], 97, 8, 114
SHP[2], 73
SRP1[], 13
IP[], 34
MDAP[R], 34
SLOOP[], 3
IP[], 43, 26, 84
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="55">
      <instructions>
        <talk>/* VTTTalk glyph 55, char 0x58 (X) */
/* GUI generated Fri Jun 23 01:25:45 2023 */

/* Y direction */
ResYAnchor(8,8)
YShift(8,67)
ResYAnchor(26,17)
YShift(26,47)
YInterpolate(8,0,16,58,37,26)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 55, char 0x58 (X) */
/* VTT 6.35 compiler Fri Jun 23 01:25:45 2023 */
SVTCA[Y]
CALL[], 8, 8, 114
SHP[2], 67
CALL[], 26, 17, 114
SHP[2], 47
SRP2[], 8
SLOOP[], 4
IP[], 0, 16, 58, 37
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="56">
      <instructions>
        <talk>/* VTTTalk glyph 56, char 0x59 (Y) */
/* GUI generated Fri Jun 23 01:26:10 2023 */

/* Y direction */
ResYAnchor(4,8)
ResYAnchor(20,17)
YShift(20,43)
YInterpolate(4,8,55,32,20)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 56, char 0x59 (Y) */
/* VTT 6.35 compiler Fri Jun 23 01:26:10 2023 */
SVTCA[Y]
CALL[], 4, 8, 114
CALL[], 20, 17, 114
SHP[2], 43
SRP2[], 4
SLOOP[], 3
IP[], 8, 55, 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="57">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xdd */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 56, 0, 0
OFFSET[R], 353, 1085, 59
SVTCA[Y]
MDAP[R], 20
MDRP[m&gt;RWh], 56
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="58">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x178 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 56, 0, 0
OFFSET[R], 350, 1079, 59
SVTCA[Y]
MDAP[R], 20
MDRP[m&gt;RWh], 68
MDRP[m&gt;RWh], 56
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="59">
      <instructions>
        <talk>/* VTTTalk glyph 59, char 0x5a (Z) */
/* GUI generated Fri Jun 23 01:26:39 2023 */

/* Y direction */
ResYAnchor(0,8)
ResYDist(0,28)
YShift(28,5)
ResYAnchor(21,2)
YShift(21,19)
ResYDist(21,7)
YShift(7,27)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 59, char 0x5a (Z) */
/* VTT 6.35 compiler Fri Jun 23 01:26:39 2023 */
SVTCA[Y]
CALL[], 0, 8, 114
CALL[], 0, 28, 106
SHP[2], 5
CALL[], 21, 2, 114
SHP[2], 19
CALL[], 21, 7, 106
SHP[2], 27
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="60">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x17d */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 59, 0, 0
OFFSET[R], 356, 1119, 59
SVTCA[Y]
MDAP[R], 22
MDRP[m&gt;RWh], 49
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="61">
      <instructions>
        <talk>/* VTTTalk glyph 61, char 0x61 (a) */
/* GUI generated Fri Jun 23 16:49:32 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,50)
ResYAnchor(35,6)
ResYDist(35,11)
YIPAnchor(0,8,35)
YInterpolate(0,47,53,8)
YInterpolate(8,18,35)
ResYDist(8,54)
ResYAnchor(42,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 61, char 0x61 (a) */
/* VTT 6.35 compiler Fri Jun 23 16:49:32 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 50, 106
CALL[], 35, 6, 114
CALL[], 35, 11, 106
SRP2[], 0
IP[], 8
MDAP[R], 8
IP[], 47
IP[], 53
SRP2[], 35
IP[], 18
CALL[], 8, 54, 106
CALL[], 42, 10, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="62">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe1 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 368, 210, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 61
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="63">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe2 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 370, 155, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 61
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="64">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe4 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 365, 131, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 73
MDRP[m&gt;RWh], 61
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="65">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe0 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 367, 158, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 61
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="66">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe5 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 373, 240, 0
SVTCA[Y]
MDAP[R], 36
MDRP[m&gt;RWh], 61
MDAP[R], 61
SHP[1], 79
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="67">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe3 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 61, 0, 0
OFFSET[R], 374, 182, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 69
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="68">
      <instructions>
        <talk>/* VTTTalk glyph 68, char 0xe6 */
/* GUI generated Fri Jun 23 16:50:41 2023 */

/* Y direction */
ResYAnchor(24,6)
ResYDist(24,0)
YShift(24,32)
YAnchor(32)
ResYDist(32,90)
ResYAnchor(73,11)
ResYDist(73,95)
YIPAnchor(73,81,24)
YInterpolate(73,69,81)
YInterpolate(81,5,27,24)
ResYDist(81,99)
YShift(73,66)
YAnchor(66)
ResYDist(66,43)
YIPAnchor(66,94,32)
ResYDist(94,40)
YInterpolate(66,48,40)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 68, char 0xe6 */
/* VTT 6.35 compiler Fri Jun 23 16:50:41 2023 */
SVTCA[Y]
CALL[], 24, 6, 114
CALL[], 24, 0, 106
SHP[1], 32
MDAP[R], 32
CALL[], 32, 90, 106
CALL[], 73, 11, 114
CALL[], 73, 95, 106
SRP2[], 24
IP[], 81
MDAP[R], 81
SRP2[], 73
IP[], 69
SRP2[], 24
IP[], 5
IP[], 27
CALL[], 81, 99, 106
SRP1[], 73
SHP[1], 66
MDAP[R], 66
CALL[], 66, 43, 106
SRP2[], 32
IP[], 94
MDAP[R], 94
CALL[], 94, 40, 106
SRP1[], 66
IP[], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="69">
      <instructions>
        <talk>/* VTTTalk glyph 69, char 0x62 (b) */
/* GUI generated Fri Jun 23 01:34:05 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,31)
ResYAnchor(11,0)
ResYAnchor(23,6)
ResYDist(23,37)
YInterpolate(0,4,41,40,19,23)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 69, char 0x62 (b) */
/* VTT 6.35 compiler Fri Jun 23 01:34:05 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 31, 106
CALL[], 11, 0, 114
CALL[], 23, 6, 114
CALL[], 23, 37, 106
SRP2[], 0
SLOOP[], 4
IP[], 4, 41, 40, 19
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="70">
      <instructions>
        <talk>/* VTTTalk glyph 70, char 0x63 (c) */
/* GUI generated Fri Jun 23 01:34:07 2023 */

/* Y direction */
ResYAnchor(0,6)
ResYDist(0,26)
ResYAnchor(50,11)
ResYDist(50,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 70, char 0x63 (c) */
/* VTT 6.35 compiler Fri Jun 23 01:34:07 2023 */
SVTCA[Y]
CALL[], 0, 6, 114
CALL[], 0, 26, 106
CALL[], 50, 11, 114
CALL[], 50, 33, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="71">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe7 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 70, 0, 0
OFFSET[R], 376, 414, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="72">
      <instructions>
        <talk>/* VTTTalk glyph 72, char 0x64 (d) */
/* GUI generated Fri Jun 23 01:34:12 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,39)
ResYAnchor(8,6)
ResYDist(8,46)
YInterpolate(0,34,42,43,11,8)
ResYAnchor(18,0)
ResYAnchor(30,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 72, char 0x64 (d) */
/* VTT 6.35 compiler Fri Jun 23 01:34:12 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 39, 106
CALL[], 8, 6, 114
CALL[], 8, 46, 106
SRP2[], 0
SLOOP[], 4
IP[], 34, 42, 43, 11
CALL[], 18, 0, 114
CALL[], 30, 10, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="73">
      <instructions>
        <talk>/* VTTTalk glyph 73, char 0xf0 */
/* GUI generated Fri Jun 23 01:34:37 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,46)
ResYAnchor(31,1)
YShift(31,38)
YIPAnchor(31,7,0)
YInterpolate(31,37,39,40,18,17,15,16,7)
ResYDist(7,51)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 73, char 0xf0 */
/* VTT 6.35 compiler Fri Jun 23 01:34:37 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 46, 106
CALL[], 31, 1, 114
SHP[2], 38
SRP1[], 0
IP[], 7
MDAP[R], 7
SLOOP[], 7
IP[], 37, 39, 40, 18, 17, 15, 16
CALL[], 7, 51, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="74">
      <instructions>
        <talk>/* VTTTalk glyph 74, char 0x65 (e) */
/* GUI generated Fri Jun 23 16:50:03 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,18)
ResYAnchor(7,6)
ResYDist(7,45)
YIPAnchor(0,39,7)
ResYDist(39,15)
YInterpolate(0,23,15)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 74, char 0x65 (e) */
/* VTT 6.35 compiler Fri Jun 23 16:50:03 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 18, 106
CALL[], 7, 6, 114
CALL[], 7, 45, 106
SRP2[], 0
IP[], 39
MDAP[R], 39
CALL[], 39, 15, 106
SRP1[], 0
IP[], 23
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="75">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe9 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 74, 0, 0
OFFSET[R], 368, 250, 0
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="76">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xea */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 74, 0, 0
OFFSET[R], 370, 195, 0
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="77">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xeb */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 74, 0, 0
OFFSET[R], 365, 171, 0
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 60
MDRP[m&gt;RWh], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="78">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xe8 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 74, 0, 0
OFFSET[R], 367, 198, 0
SVTCA[Y]
MDAP[R], 7
MDRP[m&gt;RWh], 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="79">
      <instructions>
        <talk>/* VTTTalk glyph 79, char 0x66 (f) */
/* GUI generated Fri Jun 23 01:38:42 2023 */

/* Y direction */
ResYAnchor(4,10)
ResYAnchor(22,1)
ResYDist(22,37)
YAnchor(40,18)
YShift(40,16)
ResYDist(40,49)
YShift(49,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 79, char 0x66 (f) */
/* VTT 6.35 compiler Fri Jun 23 01:38:42 2023 */
SVTCA[Y]
CALL[], 4, 10, 114
CALL[], 22, 1, 114
CALL[], 22, 37, 106
MIAP[R], 40, 18
SHP[1], 16
CALL[], 40, 49, 106
SHP[2], 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="80">
      <instructions>
        <talk>/* VTTTalk glyph 80, char 0x67 (g) */
/* GUI generated Fri Jun 23 01:36:02 2023 */

/* Y direction */
ResYAnchor(4,15)
ResYDist(4,28)
ResYAnchor(37,11)
ResYDist(37,54)
ResYAnchor(45,6)
ResYDist(45,49)
YInterpolate(37,32,57,58,0,45)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 80, char 0x67 (g) */
/* VTT 6.35 compiler Fri Jun 23 01:36:02 2023 */
SVTCA[Y]
CALL[], 4, 15, 114
CALL[], 4, 28, 106
CALL[], 37, 11, 114
CALL[], 37, 54, 106
CALL[], 45, 6, 114
CALL[], 45, 49, 106
SRP2[], 37
SLOOP[], 4
IP[], 32, 57, 58, 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="81">
      <instructions>
        <talk>/* VTTTalk glyph 81, char 0x68 (h) */
/* GUI generated Fri Jun 23 01:36:24 2023 */

/* Y direction */
ResYAnchor(4,10)
YShift(4,36)
ResYAnchor(14,0)
ResYAnchor(27,6)
ResYDist(27,43)
YInterpolate(4,46,22,27)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 81, char 0x68 (h) */
/* VTT 6.35 compiler Fri Jun 23 01:36:24 2023 */
SVTCA[Y]
CALL[], 4, 10, 114
SHP[2], 36
CALL[], 14, 0, 114
CALL[], 27, 6, 114
CALL[], 27, 43, 106
SRP2[], 4
IP[], 46
IP[], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="82">
      <instructions>
        <talk>/* VTTTalk glyph 82, char 0x69 (i) */
/* GUI generated Fri Jun 23 01:38:27 2023 */

/* Y direction */
ResYAnchor(39,10)
YAnchor(46,18)
YDist(46,25,&gt;=)
ResYDist(25,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 82, char 0x69 (i) */
/* VTT 6.35 compiler Fri Jun 23 01:38:31 2023 */
SVTCA[Y]
CALL[], 39, 10, 114
MIAP[R], 46, 18
MDRP[m&gt;RWh], 25
CALL[], 25, 8, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="83">
      <instructions>
        <talk>/* VTTTalk glyph 83, char 0x131 */
/* GUI generated Fri Jun 23 01:38:59 2023 */

/* Y direction */
ResYAnchor(4,10)
YAnchor(11,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 83, char 0x131 */
/* VTT 6.35 compiler Fri Jun 23 01:38:59 2023 */
SVTCA[Y]
CALL[], 4, 10, 114
MIAP[R], 11, 18
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="84">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xed */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 83, 0, 0
OFFSET[R], 368, -61, 0
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 16
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="85">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xee */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 83, 0, 0
OFFSET[R], 370, -116, 0
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 16
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="86">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xef */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 83, 0, 0
OFFSET[R], 365, -140, 0
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 28
MDRP[m&gt;RWh], 16
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="87">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xec */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 83, 0, 0
OFFSET[R], 367, -66, 0
SVTCA[Y]
MDAP[R], 11
MDRP[m&gt;RWh], 16
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="88">
      <instructions>
        <talk>/* VTTTalk glyph 88, char 0x6a (j) */
/* GUI generated Fri Jun 23 02:14:38 2023 */

/* Y direction */
YAnchor(39,18)
YDist(39,26,&gt;=)
ResYDist(26,8)
ResYAnchor(50,15)
YShift(50,57)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 88, char 0x6a (j) */
/* VTT 6.35 compiler Fri Jun 23 02:14:38 2023 */
SVTCA[Y]
MIAP[R], 39, 18
MDRP[m&gt;RWh], 26
CALL[], 26, 8, 106
CALL[], 50, 15, 114
SHP[2], 57
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="89">
      <instructions>
        <talk>/* VTTTalk glyph 89, char 0x237 */
/* GUI generated Fri Jun 23 02:14:52 2023 */

/* Y direction */
YAnchor(4,18)
ResYAnchor(15,15)
YShift(15,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 89, char 0x237 */
/* VTT 6.35 compiler Fri Jun 23 02:14:52 2023 */
SVTCA[Y]
MIAP[R], 4, 18
CALL[], 15, 15, 114
SHP[2], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="90">
      <instructions>
        <talk>/* VTTTalk glyph 90, char 0x6b (k) */
/* GUI generated Fri Jun 23 01:40:41 2023 */

/* Y direction */
ResYAnchor(4,10)
YShift(4,56)
ResYAnchor(14,0)
ResYAnchor(33,7)
YIPAnchor(4,64,33)
ResYDist(64,22)
YInterpolate(64,46,45,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 90, char 0x6b (k) */
/* VTT 6.35 compiler Fri Jun 23 01:40:41 2023 */
SVTCA[Y]
CALL[], 4, 10, 114
SHP[2], 56
CALL[], 14, 0, 114
CALL[], 33, 7, 114
SRP2[], 4
IP[], 64
MDAP[R], 64
CALL[], 64, 22, 106
IP[], 46
IP[], 45
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="91">
      <instructions>
        <talk>/* VTTTalk glyph 91, char 0x6c (l) */
/* GUI generated Fri Jun 23 01:41:04 2023 */

/* Y direction */
ResYAnchor(2,11)
ResYAnchor(14,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 91, char 0x6c (l) */
/* VTT 6.35 compiler Fri Jun 23 01:41:04 2023 */
SVTCA[Y]
CALL[], 2, 11, 114
CALL[], 14, 0, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="92">
      <instructions>
        <talk>/* VTTTalk glyph 92, char 0x6d (m) */
/* GUI generated Fri Jun 23 01:42:18 2023 */

/* Y direction */
ResYAnchor(41,10)
YShift(41,11)
YShift(41,26)
YAnchor(52,7)
ResYAnchor(61,6)
ResYDist(61,33)
YInterpolate(41,36,21,0,57,61)
YShift(61,3)
ResYDist(3,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 92, char 0x6d (m) */
/* VTT 6.35 compiler Fri Jun 23 01:42:18 2023 */
SVTCA[Y]
CALL[], 41, 10, 114
SHP[2], 11
SHP[2], 26
MIAP[R], 52, 7
CALL[], 61, 6, 114
CALL[], 61, 33, 106
SRP2[], 41
SLOOP[], 4
IP[], 36, 21, 0, 57
SHP[1], 3
CALL[], 3, 18, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="93">
      <instructions>
        <talk>/* VTTTalk glyph 93, char 0x6e (n) */
/* GUI generated Fri Jun 23 01:42:33 2023 */

/* Y direction */
ResYAnchor(20,10)
YShift(20,5)
YAnchor(31,7)
ResYAnchor(41,6)
ResYDist(41,12)
YInterpolate(20,15,36,41)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 93, char 0x6e (n) */
/* VTT 6.35 compiler Fri Jun 23 01:42:33 2023 */
SVTCA[Y]
CALL[], 20, 10, 114
SHP[2], 5
MIAP[R], 31, 7
CALL[], 41, 6, 114
CALL[], 41, 12, 106
SRP2[], 20
IP[], 15
IP[], 36
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="94">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf1 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 93, 0, 0
OFFSET[R], 374, 233, 0
SVTCA[Y]
MDAP[R], 41
MDRP[m&gt;RWh], 45
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="95">
      <instructions>
        <talk>/* VTTTalk glyph 95, char 0x6f (o) */
/* GUI generated Fri Jun 23 01:42:40 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,12)
ResYAnchor(6,6)
ResYDist(6,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 95, char 0x6f (o) */
/* VTT 6.35 compiler Fri Jun 23 01:42:40 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 12, 106
CALL[], 6, 6, 114
CALL[], 6, 18, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="96">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf3 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 95, 0, 0
OFFSET[R], 368, 283, 0
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RWh], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="97">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf4 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 95, 0, 0
OFFSET[R], 370, 228, 0
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RWh], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="98">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf6 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 95, 0, 0
OFFSET[R], 365, 204, 0
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RWh], 36
MDRP[m&gt;RWh], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="99">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf2 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 95, 0, 0
OFFSET[R], 367, 231, 0
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RWh], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="100">
      <instructions>
        <talk>/* VTTTalk glyph 100, char 0xf8 */
/* GUI generated Fri Jun 23 01:43:30 2023 */

/* Y direction */
ResYAnchor(7,6)
ResYDist(7,26)
YDist(7,10)
YShift(10,11)
ResYAnchor(18,11)
ResYDist(18,29)
YDist(18,0)
YShift(0,1)
YInterpolate(18,20,2,35,23,34,24,12,9,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 100, char 0xf8 */
/* VTT 6.35 compiler Fri Jun 23 01:43:30 2023 */
SVTCA[Y]
CALL[], 7, 6, 114
CALL[], 7, 26, 106
SRP0[], 7
MDRP[m&lt;RWh], 10
SHP[2], 11
CALL[], 18, 11, 114
CALL[], 18, 29, 106
SRP0[], 18
MDRP[m&lt;RWh], 0
SHP[2], 1
SRP2[], 7
SLOOP[], 8
IP[], 20, 2, 35, 23, 34, 24, 12, 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="101">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf5 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 95, 0, 0
OFFSET[R], 374, 255, 0
SVTCA[Y]
CALL[], 24, 6, 1, 1, 135, 86
SHC[2], 2</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="102">
      <instructions>
        <talk>/* VTTTalk glyph 102, char 0x153 */
/* GUI generated Fri Jun 23 01:44:12 2023 */

/* Y direction */
ResYAnchor(36,11)
ResYDist(36,68)
YShift(36,27)
YAnchor(27)
ResYDist(27,4)
ResYAnchor(44,6)
ResYDist(44,74)
YIPAnchor(36,67,44)
YInterpolate(36,31,67)
YInterpolate(67,47,44)
ResYDist(67,1)
YShift(44,51)
YAnchor(51)
ResYDist(51,64)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 102, char 0x153 */
/* VTT 6.35 compiler Fri Jun 23 01:44:12 2023 */
SVTCA[Y]
CALL[], 36, 11, 114
CALL[], 36, 68, 106
SHP[1], 27
MDAP[R], 27
CALL[], 27, 4, 106
CALL[], 44, 6, 114
CALL[], 44, 74, 106
SRP2[], 36
IP[], 67
MDAP[R], 67
IP[], 31
SRP2[], 44
IP[], 47
CALL[], 67, 1, 106
SRP1[], 44
SHP[1], 51
MDAP[R], 51
CALL[], 51, 64, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="103">
      <instructions>
        <talk>/* VTTTalk glyph 103, char 0x70 (p) */
/* GUI generated Fri Jun 23 01:44:44 2023 */

/* Y direction */
ResYAnchor(0,6)
ResYDist(0,50)
ResYAnchor(8,11)
ResYDist(8,45)
YInterpolate(8,12,54,53,40,0)
ResYAnchor(20,14)
YAnchor(35,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 103, char 0x70 (p) */
/* VTT 6.35 compiler Fri Jun 23 01:44:44 2023 */
SVTCA[Y]
CALL[], 0, 6, 114
CALL[], 0, 50, 106
CALL[], 8, 11, 114
CALL[], 8, 45, 106
SRP2[], 0
SLOOP[], 4
IP[], 12, 54, 53, 40
CALL[], 20, 14, 114
MIAP[R], 35, 7
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="104">
      <instructions>
        <talk>/* VTTTalk glyph 104, char 0xfe */
/* GUI generated Fri Jun 23 01:45:09 2023 */

/* Y direction */
ResYAnchor(6,14)
ResYAnchor(20,0)
ResYAnchor(33,6)
ResYDist(33,52)
ResYAnchor(41,11)
ResYDist(41,47)
YInterpolate(41,45,56,55,28,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 104, char 0xfe */
/* VTT 6.35 compiler Fri Jun 23 01:45:09 2023 */
SVTCA[Y]
CALL[], 6, 14, 114
CALL[], 20, 0, 114
CALL[], 33, 6, 114
CALL[], 33, 52, 106
CALL[], 41, 11, 114
CALL[], 41, 47, 106
SRP2[], 33
SLOOP[], 4
IP[], 45, 56, 55, 28
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="105">
      <instructions>
        <talk>/* VTTTalk glyph 105, char 0x71 (q) */
/* GUI generated Fri Jun 23 01:45:26 2023 */

/* Y direction */
ResYAnchor(0,6)
ResYDist(0,32)
ResYAnchor(11,14)
ResYAnchor(24,11)
ResYDist(24,37)
YInterpolate(24,19,40,41,4,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 105, char 0x71 (q) */
/* VTT 6.35 compiler Fri Jun 23 01:45:26 2023 */
SVTCA[Y]
CALL[], 0, 6, 114
CALL[], 0, 32, 106
CALL[], 11, 14, 114
CALL[], 24, 11, 114
CALL[], 24, 37, 106
SRP2[], 0
SLOOP[], 4
IP[], 19, 40, 41, 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="106">
      <instructions>
        <talk>/* VTTTalk glyph 106, char 0x72 (r) */
/* GUI generated Fri Jun 23 01:45:48 2023 */

/* Y direction */
ResYAnchor(3,6)
YShift(3,6)
ResYDist(3,16)
YShift(16,11)
ResYAnchor(24,10)
YInterpolate(24,0,3)
ResYAnchor(36,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 106, char 0x72 (r) */
/* VTT 6.35 compiler Fri Jun 23 01:45:48 2023 */
SVTCA[Y]
CALL[], 3, 6, 114
SHP[2], 6
CALL[], 3, 16, 106
SHP[2], 11
CALL[], 24, 10, 114
SRP1[], 3
IP[], 0
CALL[], 36, 7, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="107">
      <instructions>
        <talk>/* VTTTalk glyph 107, char 0x73 (s) */
/* GUI generated Fri Jun 23 16:52:17 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,16)
ResYAnchor(30,7)
ResYDist(30,51)
YInterpolate(0,23,51)
YInterpolate(16,11,23)
YInterpolate(16,57,30)
YInterpolate(57,45,51)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 107, char 0x73 (s) */
/* VTT 6.35 compiler Fri Jun 23 16:52:17 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 16, 106
CALL[], 30, 7, 114
CALL[], 30, 51, 106
SRP1[], 0
IP[], 23
SRP1[], 16
SRP2[], 23
IP[], 11
SRP2[], 30
IP[], 57
SRP1[], 57
SRP2[], 51
IP[], 45
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="108">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x161 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 107, 0, 0
OFFSET[R], 371, 56, 0
SVTCA[Y]
MDAP[R], 30
MDRP[m&gt;RWh], 65
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="109">
      <instructions>
        <talk>/* VTTTalk glyph 109, char 0xdf */
/* GUI generated Fri Jun 23 01:47:02 2023 */

/* Y direction */
ResYAnchor(40,10)
YShift(40,1)
YAnchor(1)
ResYDist(1,15)
ResYAnchor(48,1)
ResYDist(48,33)
YIPAnchor(1,22,48)
ResYDist(22,27)
YInterpolate(22,56,55,27)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 109, char 0xdf */
/* VTT 6.35 compiler Fri Jun 23 01:47:02 2023 */
SVTCA[Y]
CALL[], 40, 10, 114
SHP[2], 1
MDAP[R], 1
CALL[], 1, 15, 106
CALL[], 48, 1, 114
CALL[], 48, 33, 106
SRP2[], 1
IP[], 22
MDAP[R], 22
CALL[], 22, 27, 106
IP[], 56
IP[], 55
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="110">
      <instructions>
        <talk>/* VTTTalk glyph 110, char 0x74 (t) */
/* GUI generated Fri Jun 23 01:47:31 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,39)
YAnchor(27,18)
YShift(27,11)
YDist(27,19,&gt;=)
ResYDist(27,36)
YShift(36,4)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 110, char 0x74 (t) */
/* VTT 6.35 compiler Fri Jun 23 01:47:43 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 39, 106
MIAP[R], 27, 18
SHP[1], 11
MDRP[m&gt;RBl], 19
CALL[], 27, 36, 106
SHP[2], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="111">
      <instructions>
        <talk>/* VTTTalk glyph 111, char 0x75 (u) */
/* GUI generated Fri Jun 23 01:48:16 2023 */

/* Y direction */
ResYAnchor(0,11)
ResYDist(0,19)
YAnchor(9,7)
YShift(9,29)
YInterpolate(0,45,22,9)
ResYAnchor(41,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 111, char 0x75 (u) */
/* VTT 6.35 compiler Fri Jun 23 01:48:16 2023 */
SVTCA[Y]
CALL[], 0, 11, 114
CALL[], 0, 19, 106
MIAP[R], 9, 7
SHP[1], 29
SRP2[], 0
IP[], 45
IP[], 22
CALL[], 41, 10, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="112">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfa */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 111, 0, 0
OFFSET[R], 368, 280, 0
SVTCA[Y]
MDAP[R], 9
MDRP[m&gt;RWh], 50
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="113">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfb */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 111, 0, 0
OFFSET[R], 370, 225, 0
SVTCA[Y]
MDAP[R], 9
MDRP[m&gt;RWh], 50
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="114">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfc */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 111, 0, 0
OFFSET[R], 365, 201, 0
SVTCA[Y]
MDAP[R], 9
MDRP[m&gt;RWh], 62
MDRP[m&gt;RWh], 50
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="115">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xf9 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 111, 0, 0
OFFSET[R], 367, 228, 0
SVTCA[Y]
MDAP[R], 9
MDRP[m&gt;RWh], 50
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="116">
      <instructions>
        <talk>/* VTTTalk glyph 116, char 0x76 (v) */
/* GUI generated Fri Jun 23 01:48:44 2023 */

/* Y direction */
ResYAnchor(11,7)
YShift(11,37)
ResYAnchor(53,10)
YInterpolate(53,23,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 116, char 0x76 (v) */
/* VTT 6.35 compiler Fri Jun 23 01:48:44 2023 */
SVTCA[Y]
CALL[], 11, 7, 114
SHP[2], 37
CALL[], 53, 10, 114
SRP1[], 11
IP[], 23
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="117">
      <instructions>
        <talk>/* VTTTalk glyph 117, char 0x77 (w) */
/* GUI generated Fri Jun 23 01:49:24 2023 */

/* Y direction */
ResYAnchor(12,7)
YShift(12,56)
ResYAnchor(98,10)
YShift(98,74)
YIPAnchor(98,34,12)
YInterpolate(98,43,25,85,34)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 117, char 0x77 (w) */
/* VTT 6.35 compiler Fri Jun 23 01:49:24 2023 */
SVTCA[Y]
CALL[], 12, 7, 114
SHP[2], 56
CALL[], 98, 10, 114
SHP[2], 74
SRP1[], 12
IP[], 34
MDAP[R], 34
SLOOP[], 3
IP[], 43, 25, 85
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="118">
      <instructions>
        <talk>/* VTTTalk glyph 118, char 0x78 (x) */
/* GUI generated Fri Jun 23 01:50:42 2023 */

/* Y direction */
ResYAnchor(7,10)
YShift(7,60)
ResYAnchor(22,7)
YShift(22,42)
YInterpolate(7,0,12,53,32,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 118, char 0x78 (x) */
/* VTT 6.35 compiler Fri Jun 23 01:50:42 2023 */
SVTCA[Y]
CALL[], 7, 10, 114
SHP[2], 60
CALL[], 22, 7, 114
SHP[2], 42
SRP2[], 7
SLOOP[], 4
IP[], 0, 12, 53, 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="119">
      <instructions>
        <talk>/* VTTTalk glyph 119, char 0x79 (y) */
/* GUI generated Fri Jun 23 01:51:02 2023 */

/* Y direction */
ResYAnchor(0,15)
ResYDist(0,21)
ResYAnchor(35,7)
YShift(35,62)
YInterpolate(0,73,24,48,35)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 119, char 0x79 (y) */
/* VTT 6.35 compiler Fri Jun 23 01:51:02 2023 */
SVTCA[Y]
CALL[], 0, 15, 114
CALL[], 0, 21, 106
CALL[], 35, 7, 114
SHP[2], 62
SRP2[], 0
SLOOP[], 3
IP[], 73, 24, 48
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="120">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfd */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 119, 0, 0
OFFSET[R], 368, 225, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 83
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="121">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xff */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 119, 0, 0
OFFSET[R], 365, 146, 0
SVTCA[Y]
MDAP[R], 35
MDRP[m&gt;RWh], 95
MDRP[m&gt;RWh], 83
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="122">
      <instructions>
        <talk>/* VTTTalk glyph 122, char 0x7a (z) */
/* GUI generated Fri Jun 23 01:51:50 2023 */

/* Y direction */
ResYAnchor(0,10)
ResYDist(0,26)
YShift(26,4)
YAnchor(18,18)
ResYDist(18,6)
YShift(6,25)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 122, char 0x7a (z) */
/* VTT 6.35 compiler Fri Jun 23 01:51:50 2023 */
SVTCA[Y]
CALL[], 0, 10, 114
CALL[], 0, 26, 106
SHP[2], 4
MIAP[R], 18, 18
CALL[], 18, 6, 106
SHP[2], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="123">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x17e */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 122, 0, 0
OFFSET[R], 371, 93, 0
SVTCA[Y]
MDAP[R], 18
MDRP[m&gt;RWh], 40
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="124">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfb01 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 79, 0, 0
OFFSET[R], 82, 782, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="125">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xfb02 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 79, 0, 0
OFFSET[R], 91, 782, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="126">
      <instructions>
        <talk>/* VTTTalk glyph 126, char 0xaa */
/* GUI generated Fri Jun 23 16:50:13 2023 */

/* Y direction */
ResYAnchor(33,3)
ResYDist(33,10)
YDist(33,0)
YDist(0,39)
ResYDist(0,46)
YIPAnchor(0,7,33)
YInterpolate(0,42,49,7)
YInterpolate(7,15,33)
ResYDist(7,50)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 126, char 0xaa */
/* VTT 6.35 compiler Fri Jun 23 16:50:13 2023 */
SVTCA[Y]
CALL[], 33, 3, 114
CALL[], 33, 10, 106
SRP0[], 33
MDRP[M&lt;RGr], 0
MDRP[m&lt;RGr], 39
CALL[], 0, 46, 106
SRP2[], 33
IP[], 7
MDAP[R], 7
SRP2[], 0
IP[], 42
IP[], 49
SRP2[], 33
IP[], 15
CALL[], 7, 50, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="127">
      <instructions>
        <talk>/* VTTTalk glyph 127, char 0xba */
/* GUI generated Fri Jun 23 01:53:03 2023 */

/* Y direction */
ResYAnchor(6,3)
ResYDist(6,18)
YDist(6,0)
ResYDist(0,12)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 127, char 0xba */
/* VTT 6.35 compiler Fri Jun 23 01:53:03 2023 */
SVTCA[Y]
CALL[], 6, 3, 114
CALL[], 6, 18, 106
SRP0[], 6
MDRP[m&lt;RGr], 0
CALL[], 0, 12, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="128">
      <instructions>
        <talk>/* VTTTalk glyph 128, char 0x1e900 */
/* GUI generated Fri Jun 23 01:54:47 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,32)
YAnchor(9,2)
ResYDist(9,25)
YInterpolate(0,52,51,48,40,44,47,41,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 128, char 0x1e900 */
/* VTT 6.35 compiler Fri Jun 23 01:54:47 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 32, 106
MIAP[R], 9, 2
CALL[], 9, 25, 106
SRP2[], 0
SLOOP[], 7
IP[], 52, 51, 48, 40, 44, 47, 41
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="129">
      <instructions>
        <talk>/* VTTTalk glyph 129, char 0x1e901 */
/* GUI generated Fri Jun 23 01:56:32 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,14)
YAnchor(34,17)
YShift(34,57)
YIPAnchor(0,23,34)
ResYDist(23,46)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 129, char 0x1e901 */
/* VTT 6.35 compiler Fri Jun 23 01:56:32 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 14, 106
MIAP[R], 34, 17
SHP[1], 57
SRP2[], 0
IP[], 23
MDAP[R], 23
CALL[], 23, 46, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="130">
      <instructions>
        <talk>/* VTTTalk glyph 130, char 0x1e902 */
/* GUI generated Fri Jun 23 02:34:29 2023 */

/* Y direction */
YAnchor(0)
YShift(0,74)
ResYDist(0,14)
YAnchor(46,3)
YDist(46,34)
ResYDist(46,23)
YInterpolate(0,78,23)
YInterpolate(14,54,46)
YAnchor(65,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 130, char 0x1e902 */
/* VTT 6.35 compiler Fri Jun 23 02:34:29 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 74
CALL[], 0, 14, 106
MIAP[R], 46, 3
MDRP[m&lt;RGr], 34
CALL[], 46, 23, 106
SRP1[], 0
IP[], 78
SRP1[], 14
SRP2[], 46
IP[], 54
MIAP[R], 65, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="131">
      <instructions>
        <talk>/* VTTTalk glyph 131, char 0x1e903 */
/* GUI generated Fri Jun 23 01:59:38 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,14)
YAnchor(30,3)
ResYDist(30,39)
YInterpolate(0,22,39)
YInterpolate(14,46,30)
YInterpolate(46,35,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 131, char 0x1e903 */
/* VTT 6.35 compiler Fri Jun 23 01:59:38 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 14, 106
MIAP[R], 30, 3
CALL[], 30, 39, 106
SRP1[], 0
IP[], 22
SRP1[], 14
SRP2[], 30
IP[], 46
SRP1[], 46
SRP2[], 39
IP[], 35
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="132">
      <instructions>
        <talk>/* VTTTalk glyph 132, char 0x1e904 */
/* GUI generated Fri Jun 23 02:00:31 2023 */

/* Y direction */
YAnchor(15,8)
YShift(15,25)
ResYDist(15,60)
YAnchor(32,17)
YAnchor(47,3)
YShift(47,44)
YIPAnchor(15,56,47)
YShift(56,20)
YShift(20,23)
ResYDist(56,65)
YShift(65,43)
YShift(43,40)
ResYDist(47,61)
YShift(61,64)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 132, char 0x1e904 */
/* VTT 6.35 compiler Fri Jun 23 02:00:31 2023 */
SVTCA[Y]
MIAP[R], 15, 8
SHP[1], 25
CALL[], 15, 60, 106
MIAP[R], 32, 17
MIAP[R], 47, 3
SHP[1], 44
SRP2[], 15
IP[], 56
MDAP[R], 56
SHP[1], 20
SRP1[], 20
SHP[1], 23
CALL[], 56, 65, 106
SHP[2], 43
SRP1[], 43
SHP[1], 40
CALL[], 47, 61, 106
SHP[2], 64
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="133">
      <instructions>
        <talk>/* VTTTalk glyph 133, char 0x1e905 */
/* GUI generated Fri Jun 23 02:01:39 2023 */

/* Y direction */
YAnchor(0,9)
YShift(0,74)
ResYDist(0,22)
YShift(22,43)
YAnchor(11,17)
YAnchor(65,2)
ResYDist(65,51)
YIPAnchor(22,32,51)
YInterpolate(0,78,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 133, char 0x1e905 */
/* VTT 6.35 compiler Fri Jun 23 02:01:39 2023 */
SVTCA[Y]
MIAP[R], 0, 9
SHP[2], 74
CALL[], 0, 22, 106
SHP[2], 43
MIAP[R], 11, 17
MIAP[R], 65, 2
CALL[], 65, 51, 106
SRP1[], 22
IP[], 32
MDAP[R], 32
SRP2[], 0
IP[], 78
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="134">
      <instructions>
        <talk>/* VTTTalk glyph 134, char 0x1e906 */
/* GUI generated Fri Jun 23 02:02:45 2023 */

/* Y direction */
YAnchor(16,8)
ResYDist(16,0)
YShift(0,33)
YShift(33,34)
YAnchor(23,3)
YShift(23,20)
ResYDist(23,41)
YShift(41,44)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 134, char 0x1e906 */
/* VTT 6.35 compiler Fri Jun 23 02:02:45 2023 */
SVTCA[Y]
MIAP[R], 16, 8
CALL[], 16, 0, 106
SHP[2], 33
SRP1[], 33
SHP[1], 34
MIAP[R], 23, 3
SHP[1], 20
CALL[], 23, 41, 106
SHP[2], 44
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="135">
      <instructions>
        <talk>/* VTTTalk glyph 135, char 0x1e907 */
/* GUI generated Fri Jun 23 02:25:44 2023 */

/* Y direction */
YAnchor(13,2)
ResYDist(13,29)
YShift(29,43)
YAnchor(52,8)
YDist(52,0)
YShift(0,1)
YIPAnchor(52,53,13)
ResYDist(53,36)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 135, char 0x1e907 */
/* VTT 6.35 compiler Fri Jun 23 02:25:44 2023 */
SVTCA[Y]
MIAP[R], 13, 2
CALL[], 13, 29, 106
SHP[2], 43
MIAP[R], 52, 8
MDRP[m&lt;RWh], 0
SHP[2], 1
SRP2[], 13
IP[], 53
MDAP[R], 53
CALL[], 53, 36, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="136">
      <instructions>
        <talk>/* VTTTalk glyph 136, char 0x1e908 */
/* GUI generated Fri Jun 23 02:06:21 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,54)
YAnchor(11)
YShift(11,33)
YIPAnchor(11,46,0)
YShift(46,49)
ResYDist(46,22)
YShift(22,19)
YAnchor(13,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 136, char 0x1e908 */
/* VTT 6.35 compiler Fri Jun 23 02:06:21 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 54, 106
MDAP[R], 11
SHP[1], 33
SRP2[], 0
IP[], 46
MDAP[R], 46
SHP[1], 49
CALL[], 46, 22, 106
SHP[2], 19
MIAP[R], 13, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="137">
      <instructions>
        <talk>/* VTTTalk glyph 137, char 0x1e909 */
/* GUI generated Fri Jun 23 03:00:08 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,60)
YAnchor(13)
YAnchor(25,3)
YInterpolate(60,49,25)
ResYDist(25,55)
YInterpolate(0,69,55)
YInterpolate(69,34,33,49)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 137, char 0x1e909 */
/* VTT 6.35 compiler Fri Jun 23 03:00:08 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 60, 106
MDAP[R], 13
MIAP[R], 25, 3
IP[], 49
CALL[], 25, 55, 106
SRP1[], 0
IP[], 69
SRP1[], 69
SRP2[], 49
IP[], 34
IP[], 33
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="138">
      <instructions>
        <talk>/* VTTTalk glyph 138, char 0x1e90a */
/* GUI generated Fri Jun 23 02:08:27 2023 */

/* Y direction */
YAnchor(6)
YAnchor(23,8)
YAnchor(28,2)
ResYDist(28,44)
YIPAnchor(23,53,28)
YInterpolate(23,21,49,53)
ResYDist(53,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 138, char 0x1e90a */
/* VTT 6.35 compiler Fri Jun 23 02:08:27 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 23, 8
MIAP[R], 28, 2
CALL[], 28, 44, 106
SRP2[], 23
IP[], 53
MDAP[R], 53
IP[], 21
IP[], 49
CALL[], 53, 18, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="139">
      <instructions>
        <talk>/* VTTTalk glyph 139, char 0x1e90b */
/* GUI generated Fri Jun 23 02:08:38 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,23)
YAnchor(11,17)
YShift(11,34)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 139, char 0x1e90b */
/* VTT 6.35 compiler Fri Jun 23 02:08:38 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 23, 106
MIAP[R], 11, 17
SHP[1], 34
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="140">
      <instructions>
        <talk>/* VTTTalk glyph 140, char 0x1e90c */
/* GUI generated Fri Jun 23 02:09:19 2023 */

/* Y direction */
YAnchor(27,8)
ResYDist(27,11)
YInterpolate(27,35,36,11)
YDist(27,31)
YShift(31,32)
YAnchor(44,3)
ResYDist(44,4)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 140, char 0x1e90c */
/* VTT 6.35 compiler Fri Jun 23 02:09:19 2023 */
SVTCA[Y]
MIAP[R], 27, 8
CALL[], 27, 11, 106
IP[], 35
IP[], 36
SRP0[], 27
MDRP[m&lt;RWh], 31
SHP[2], 32
MIAP[R], 44, 3
CALL[], 44, 4, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="141">
      <instructions>
        <talk>/* VTTTalk glyph 141, char 0x1e90d */
/* GUI generated Fri Jun 23 02:11:47 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,63)
YAnchor(6,8)
YShift(6,55)
YAnchor(13,17)
YAnchor(48,2)
ResYDist(48,33)
YIPAnchor(6,25,48)
YInterpolate(6,56,3,21,28,25)
ResYDist(25,70)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 141, char 0x1e90d */
/* VTT 6.35 compiler Fri Jun 23 02:11:47 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 63, 106
MIAP[R], 6, 8
SHP[1], 55
MIAP[R], 13, 17
MIAP[R], 48, 2
CALL[], 48, 33, 106
SRP2[], 6
IP[], 25
MDAP[R], 25
SLOOP[], 4
IP[], 56, 3, 21, 28
CALL[], 25, 70, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="142">
      <instructions>
        <talk>/* VTTTalk glyph 142, char 0x1e90e */
/* GUI generated Fri Jun 23 02:13:00 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,38)
YAnchor(15)
YShift(15,14)
YIPAnchor(0,9,15)
YShift(9,10)
YShift(9,23)
ResYDist(9,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 142, char 0x1e90e */
/* VTT 6.35 compiler Fri Jun 23 02:13:00 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 38, 106
MDAP[R], 15
SHP[1], 14
SRP2[], 0
IP[], 9
MDAP[R], 9
SHP[1], 10
SHP[1], 23
CALL[], 9, 32, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="143">
      <instructions>
        <talk>/* VTTTalk glyph 143, char 0x1e90f */
/* GUI generated Fri Jun 23 02:14:18 2023 */

/* Y direction */
YAnchor(27,8)
YDist(27,0)
YShift(0,51)
YAnchor(31,2)
ResYDist(31,5)
YShift(5,47)
YIPAnchor(27,25,31)
ResYDist(25,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 143, char 0x1e90f */
/* VTT 6.35 compiler Fri Jun 23 02:14:18 2023 */
SVTCA[Y]
MIAP[R], 27, 8
MDRP[m&lt;RWh], 0
SHP[2], 51
MIAP[R], 31, 2
CALL[], 31, 5, 106
SHP[2], 47
SRP2[], 27
IP[], 25
MDAP[R], 25
CALL[], 25, 9, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="144">
      <instructions>
        <talk>/* VTTTalk glyph 144, char 0x1e910 */
/* GUI generated Fri Jun 23 02:16:36 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,52)
YDist(0,68)
YShift(68,77)
YAnchor(37,2)
YInterpolate(52,7,37)
ResYDist(37,15)
YInterpolate(0,45,15)
YShift(45,72)
YAnchor(72)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 144, char 0x1e910 */
/* VTT 6.35 compiler Fri Jun 23 02:16:36 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 52, 106
SRP0[], 0
MDRP[m&lt;RWh], 68
SHP[2], 77
MIAP[R], 37, 2
SRP2[], 52
IP[], 7
CALL[], 37, 15, 106
SRP1[], 0
IP[], 45
SRP1[], 45
SHP[1], 72
MDAP[R], 72
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="145">
      <instructions>
        <talk>/* VTTTalk glyph 145, char 0x1e911 */
/* GUI generated Fri Jun 23 02:17:10 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,14)
YShift(0,77)
YAnchor(70,2)
ResYDist(70,56)
YShift(56,42)
YIPAnchor(0,79,70)
YShift(79,19)
ResYDist(79,50)
YShift(50,35)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 145, char 0x1e911 */
/* VTT 6.35 compiler Fri Jun 23 02:17:10 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 14, 106
SHP[1], 77
MIAP[R], 70, 2
CALL[], 70, 56, 106
SHP[2], 42
SRP2[], 0
IP[], 79
MDAP[R], 79
SHP[1], 19
CALL[], 79, 50, 106
SHP[2], 35
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="146">
      <instructions>
        <talk>/* VTTTalk glyph 146, char 0x1e912 */
/* GUI generated Fri Jun 23 02:18:14 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,14)
YAnchor(64,2)
ResYDist(64,50)
YIPAnchor(0,22,64)
YShift(22,23)
ResYDist(22,39)
YShift(39,38)
YInterpolate(22,74,73,29,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 146, char 0x1e912 */
/* VTT 6.35 compiler Fri Jun 23 02:18:14 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 14, 106
MIAP[R], 64, 2
CALL[], 64, 50, 106
SRP2[], 0
IP[], 22
MDAP[R], 22
SHP[1], 23
CALL[], 22, 39, 106
SHP[2], 38
SLOOP[], 3
IP[], 74, 73, 29
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="147">
      <instructions>
        <talk>/* VTTTalk glyph 147, char 0x1e913 */
/* GUI generated Fri Jun 23 02:19:07 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,38)
YShift(38,46)
YShift(46,47)
YAnchor(9,3)
ResYDist(9,54)
YInterpolate(0,43,51,13,9)
YAnchor(22,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 147, char 0x1e913 */
/* VTT 6.35 compiler Fri Jun 23 02:19:07 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 38, 106
SHP[2], 46
SRP1[], 46
SHP[1], 47
MIAP[R], 9, 3
CALL[], 9, 54, 106
SRP2[], 0
SLOOP[], 3
IP[], 43, 51, 13
MIAP[R], 22, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="148">
      <instructions>
        <talk>/* VTTTalk glyph 148, char 0x1e914 */
/* GUI generated Fri Jun 23 02:26:24 2023 */

/* Y direction */
YAnchor(6)
YAnchor(17,3)
ResYDist(17,78)
YAnchor(36,8)
YIPAnchor(36,27,17)
YInterpolate(36,22,27)
ResYDist(27,57)
ResYDist(36,50)
YShift(50,67)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 148, char 0x1e914 */
/* VTT 6.35 compiler Fri Jun 23 02:26:24 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 17, 3
CALL[], 17, 78, 106
MIAP[R], 36, 8
SRP2[], 17
IP[], 27
MDAP[R], 27
SRP2[], 36
IP[], 22
CALL[], 27, 57, 106
CALL[], 36, 50, 106
SHP[2], 67
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="149">
      <instructions>
        <talk>/* VTTTalk glyph 149, char 0x1e915 */
/* GUI generated Fri Jun 23 02:20:59 2023 */

/* Y direction */
YAnchor(18,2)
ResYDist(18,4)
YAnchor(50,8)
YShift(50,25)
ResYDist(50,34)
YIPAnchor(50,26,18)
YShift(26,28)
YShift(28,57)
YShift(57,60)
ResYDist(26,64)
YShift(64,61)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 149, char 0x1e915 */
/* VTT 6.35 compiler Fri Jun 23 02:20:59 2023 */
SVTCA[Y]
MIAP[R], 18, 2
CALL[], 18, 4, 106
MIAP[R], 50, 8
SHP[1], 25
CALL[], 50, 34, 106
SRP2[], 18
IP[], 26
MDAP[R], 26
SHP[1], 28
SRP1[], 28
SHP[1], 57
SRP1[], 57
SHP[1], 60
CALL[], 26, 64, 106
SHP[2], 61
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="150">
      <instructions>
        <talk>/* VTTTalk glyph 150, char 0x1e916 */
/* GUI generated Fri Jun 23 02:22:18 2023 */

/* Y direction */
YAnchor(49)
YShift(49,50)
YAnchor(61,8)
ResYDist(61,15)
YIPAnchor(61,45,49)
YInterpolate(45,39,49)
ResYDist(45,23)
YInterpolate(23,54,53,45)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 150, char 0x1e916 */
/* VTT 6.35 compiler Fri Jun 23 02:22:18 2023 */
SVTCA[Y]
MDAP[R], 49
SHP[1], 50
MIAP[R], 61, 8
CALL[], 61, 15, 106
SRP2[], 49
IP[], 45
MDAP[R], 45
IP[], 39
CALL[], 45, 23, 106
IP[], 54
IP[], 53
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="151">
      <instructions>
        <talk>/* VTTTalk glyph 151, char 0x1e917 */
/* GUI generated Fri Jun 23 02:23:17 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,61)
YAnchor(16,3)
ResYDist(16,23)
YIPAnchor(0,52,16)
ResYDist(52,30)
YInterpolate(52,55,7,8,30)
YShift(30,20)
YShift(20,19)
YAnchor(40,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 151, char 0x1e917 */
/* VTT 6.35 compiler Fri Jun 23 02:23:17 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 61, 106
MIAP[R], 16, 3
CALL[], 16, 23, 106
SRP2[], 0
IP[], 52
MDAP[R], 52
CALL[], 52, 30, 106
SLOOP[], 3
IP[], 55, 7, 8
SHP[2], 20
SRP1[], 20
SHP[1], 19
MIAP[R], 40, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="152">
      <instructions>
        <talk>/* VTTTalk glyph 152, char 0x1e918 */
/* GUI generated Fri Jun 23 02:24:29 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,16)
YAnchor(34,17)
YAnchor(67,2)
ResYDist(67,52)
YIPAnchor(0,23,67)
ResYDist(23,46)
YInterpolate(23,76,75,46)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 152, char 0x1e918 */
/* VTT 6.35 compiler Fri Jun 23 02:24:29 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 16, 106
MIAP[R], 34, 17
MIAP[R], 67, 2
CALL[], 67, 52, 106
SRP2[], 0
IP[], 23
MDAP[R], 23
CALL[], 23, 46, 106
IP[], 76
IP[], 75
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="153">
      <instructions>
        <talk>/* VTTTalk glyph 153, char 0x1e919 */
/* GUI generated Fri Jun 23 02:25:27 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,79)
YAnchor(16,3)
ResYDist(16,41)
YInterpolate(0,73,41)
YInterpolate(79,48,16)
YInterpolate(73,8,9,48)
YAnchor(60)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 153, char 0x1e919 */
/* VTT 6.35 compiler Fri Jun 23 02:25:27 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 79, 106
MIAP[R], 16, 3
CALL[], 16, 41, 106
SRP1[], 0
IP[], 73
SRP1[], 79
SRP2[], 16
IP[], 48
SRP1[], 73
SRP2[], 48
IP[], 8
IP[], 9
MDAP[R], 60
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="154">
      <instructions>
        <talk>/* VTTTalk glyph 154, char 0x1e91a */
/* GUI generated Fri Jun 23 02:27:09 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,66)
YShift(66,48)
YAnchor(17)
YAnchor(29,3)
YShift(29,38)
ResYDist(29,7)
YShift(7,59)
YInterpolate(0,33,29)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 154, char 0x1e91a */
/* VTT 6.35 compiler Fri Jun 23 02:27:09 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 66, 106
SHP[2], 48
MDAP[R], 17
MIAP[R], 29, 3
SHP[1], 38
CALL[], 29, 7, 106
SHP[2], 59
SRP2[], 0
IP[], 33
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="155">
      <instructions>
        <talk>/* VTTTalk glyph 155, char 0x1e91b */
/* GUI generated Fri Jun 23 03:20:35 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,77)
YAnchor(36,2)
ResYDist(36,92)
YShift(92,11)
YAnchor(64,19)
YInterpolate(64,44,92)
YShift(44,69)
ResYDist(64,48)
YInterpolate(48,87,36)
YShift(87,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 155, char 0x1e91b */
/* VTT 6.35 compiler Fri Jun 23 03:20:37 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 77, 106
MIAP[R], 36, 2
CALL[], 36, 92, 106
SHP[2], 11
MIAP[R], 64, 19
IP[], 44
SRP1[], 44
SHP[1], 69
CALL[], 64, 48, 106
SRP1[], 36
IP[], 87
SRP1[], 87
SHP[1], 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="156">
      <instructions>
        <talk>/* VTTTalk glyph 156, char 0x1e91c */
/* GUI generated Fri Jun 23 02:30:17 2023 */

/* Y direction */
YAnchor(21,2)
ResYDist(21,47)
YShift(47,5)
YAnchor(26,8)
YDist(26,0)
YShift(0,1)
YIPAnchor(26,27,21)
ResYDist(27,43)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 156, char 0x1e91c */
/* VTT 6.35 compiler Fri Jun 23 02:30:17 2023 */
SVTCA[Y]
MIAP[R], 21, 2
CALL[], 21, 47, 106
SHP[2], 5
MIAP[R], 26, 8
MDRP[m&lt;RWh], 0
SHP[2], 1
SRP2[], 21
IP[], 27
MDAP[R], 27
CALL[], 27, 43, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="157">
      <instructions>
        <talk>/* VTTTalk glyph 157, char 0x1e91d */
/* GUI generated Fri Jun 23 02:30:55 2023 */

/* Y direction */
YAnchor(1,8)
YShift(1,8)
ResYDist(1,70)
YAnchor(14,2)
YIPAnchor(1,7,14)
YShift(7,66)
ResYDist(7,34)
YShift(34,50)
ResYDist(14,30)
YShift(30,43)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 157, char 0x1e91d */
/* VTT 6.35 compiler Fri Jun 23 02:30:55 2023 */
SVTCA[Y]
MIAP[R], 1, 8
SHP[1], 8
CALL[], 1, 70, 106
MIAP[R], 14, 2
SRP2[], 1
IP[], 7
MDAP[R], 7
SHP[1], 66
CALL[], 7, 34, 106
SHP[2], 50
CALL[], 14, 30, 106
SHP[2], 43
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="158">
      <instructions>
        <talk>/* VTTTalk glyph 158, char 0x1e91e */
/* GUI generated Fri Jun 23 02:32:01 2023 */

/* Y direction */
YAnchor(9,8)
YDist(9,0)
YShift(0,60)
YAnchor(47,2)
YIPAnchor(9,7,47)
ResYDist(7,24)
ResYDist(47,31)
YShift(31,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 158, char 0x1e91e */
/* VTT 6.35 compiler Fri Jun 23 02:32:01 2023 */
SVTCA[Y]
MIAP[R], 9, 8
MDRP[m&lt;RWh], 0
SHP[2], 60
MIAP[R], 47, 2
SRP2[], 9
IP[], 7
MDAP[R], 7
CALL[], 7, 24, 106
CALL[], 47, 31, 106
SHP[2], 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="159">
      <instructions>
        <talk>/* VTTTalk glyph 159, char 0x1e91f */
/* GUI generated Fri Jun 23 02:33:00 2023 */

/* Y direction */
YAnchor(4,3)
ResYDist(4,26)
YAnchor(15)
YAnchor(70,2)
YInterpolate(70,47,26)
ResYDist(70,54)
YShift(54,37)
YInterpolate(54,92,4)
YAnchor(82,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 159, char 0x1e91f */
/* VTT 6.35 compiler Fri Jun 23 02:33:00 2023 */
SVTCA[Y]
MIAP[R], 4, 3
CALL[], 4, 26, 106
MDAP[R], 15
MIAP[R], 70, 2
IP[], 47
CALL[], 70, 54, 106
SHP[2], 37
SRP1[], 4
IP[], 92
MIAP[R], 82, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="160">
      <instructions>
        <talk>/* VTTTalk glyph 160, char 0x1e920 */
/* GUI generated Fri Jun 23 02:34:55 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,31)
YShift(31,16)
YShift(16,17)
YAnchor(4,2)
ResYDist(4,27)
YIPAnchor(4,47,0)
ResYDist(47,48)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 160, char 0x1e920 */
/* VTT 6.35 compiler Fri Jun 23 02:34:55 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 31, 106
SHP[2], 16
SRP1[], 16
SHP[1], 17
MIAP[R], 4, 2
CALL[], 4, 27, 106
SRP2[], 0
IP[], 47
MDAP[R], 47
CALL[], 47, 48, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="161">
      <instructions>
        <talk>/* VTTTalk glyph 161, char 0x1e921 */
/* GUI generated Fri Jun 23 02:35:40 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,50)
YAnchor(6,8)
YAnchor(11,2)
YIPAnchor(6,4,11)
ResYDist(4,31)
ResYDist(11,27)
YShift(27,39)
YAnchor(60,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 161, char 0x1e921 */
/* VTT 6.35 compiler Fri Jun 23 02:35:40 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 50, 106
MIAP[R], 6, 8
MIAP[R], 11, 2
SRP2[], 6
IP[], 4
MDAP[R], 4
CALL[], 4, 31, 106
CALL[], 11, 27, 106
SHP[2], 39
MIAP[R], 60, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="162">
      <instructions>
        <talk>/* VTTTalk glyph 162, char 0xffff */
/* GUI generated Fri Jun 23 02:36:58 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,32)
YShift(0,46)
YShift(46,45)
YAnchor(9,2)
ResYDist(9,25)
YShift(25,40)
YShift(40,39)
YInterpolate(0,49,36,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 162, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 02:36:58 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 32, 106
SHP[1], 46
SRP1[], 46
SHP[1], 45
MIAP[R], 9, 2
CALL[], 9, 25, 106
SHP[2], 40
SRP1[], 40
SHP[1], 39
SRP1[], 0
SRP2[], 9
IP[], 49
IP[], 36
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="163">
      <instructions>
        <talk>/* VTTTalk glyph 163, char 0x1e922 */
/* GUI generated Fri Jun 23 02:48:46 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,21)
YAnchor(10,159)
YInterpolate(0,42,41,37,28,33,36,29,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 163, char 0x1e922 */
/* VTT 6.35 compiler Fri Jun 23 02:48:46 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 21, 106
MIAP[R], 10, 159
SRP2[], 0
SLOOP[], 7
IP[], 42, 41, 37, 28, 33, 36, 29
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="164">
      <instructions>
        <talk>/* VTTTalk glyph 164, char 0x1e923 */
/* GUI generated Fri Jun 23 02:49:58 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(33,158)
YShift(33,55)
YInterpolate(0,21,44,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 164, char 0x1e923 */
/* VTT 6.35 compiler Fri Jun 23 02:49:58 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 33, 158
SHP[1], 55
SRP2[], 0
IP[], 21
IP[], 44
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="165">
      <instructions>
        <talk>/* VTTTalk glyph 165, char 0x1e924 */
/* GUI generated Fri Jun 23 02:50:39 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(45,157)
ResYDist(45,21)
YInterpolate(13,32,21)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 165, char 0x1e924 */
/* VTT 6.35 compiler Fri Jun 23 02:50:39 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 45, 157
CALL[], 45, 21, 106
SRP1[], 13
IP[], 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="166">
      <instructions>
        <talk>/* VTTTalk glyph 166, char 0x1e925 */
/* GUI generated Fri Jun 23 02:51:47 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(28,157)
ResYDist(28,37)
YInterpolate(0,21,37)
YInterpolate(13,43,28)
YInterpolate(37,33,43)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 166, char 0x1e925 */
/* VTT 6.35 compiler Fri Jun 23 02:51:47 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 28, 157
CALL[], 28, 37, 106
SRP1[], 0
IP[], 21
SRP1[], 13
SRP2[], 28
IP[], 43
SRP1[], 37
SRP2[], 43
IP[], 33
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="167">
      <instructions>
        <talk>/* VTTTalk glyph 167, char 0x1e926 */
/* GUI generated Fri Jun 23 02:53:23 2023 */

/* Y direction */
YAnchor(22,10)
ResYDist(22,7)
YAnchor(32,159)
YAnchor(58,157)
ResYDist(58,49)
YIPAnchor(22,0,58)
ResYDist(0,43)
YShift(43,53)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 167, char 0x1e926 */
/* VTT 6.35 compiler Fri Jun 23 02:53:23 2023 */
SVTCA[Y]
MIAP[R], 22, 10
CALL[], 22, 7, 106
MIAP[R], 32, 159
MIAP[R], 58, 157
CALL[], 58, 49, 106
SRP2[], 22
IP[], 0
MDAP[R], 0
CALL[], 0, 43, 106
SHP[2], 53
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="168">
      <instructions>
        <talk>/* VTTTalk glyph 168, char 0x1e927 */
/* GUI generated Fri Jun 23 02:54:46 2023 */

/* Y direction */
YAnchor(0,11)
YShift(0,63)
ResYDist(0,21)
YShift(21,42)
YAnchor(10,159)
YAnchor(31,158)
YShift(31,52)
YInterpolate(0,67,31)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 168, char 0x1e927 */
/* VTT 6.35 compiler Fri Jun 23 02:54:46 2023 */
SVTCA[Y]
MIAP[R], 0, 11
SHP[2], 63
CALL[], 0, 21, 106
SHP[2], 42
MIAP[R], 10, 159
MIAP[R], 31, 158
SHP[1], 52
SRP2[], 0
IP[], 67
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="169">
      <instructions>
        <talk>/* VTTTalk glyph 169, char 0x1e928 */
/* GUI generated Fri Jun 23 02:56:27 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,26)
YShift(26,13)
YShift(13,14)
YAnchor(4,160)
ResYDist(4,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 169, char 0x1e928 */
/* VTT 6.35 compiler Fri Jun 23 02:56:27 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 26, 106
SHP[2], 13
SRP1[], 13
SHP[1], 14
MIAP[R], 4, 160
CALL[], 4, 22, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="170">
      <instructions>
        <talk>/* VTTTalk glyph 170, char 0x1e929 */
/* GUI generated Fri Jun 23 02:57:23 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(32)
YShift(32,33)
YIPAnchor(0,21,32)
YInterpolate(21,54,32)
ResYDist(21,44)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 170, char 0x1e929 */
/* VTT 6.35 compiler Fri Jun 23 02:57:23 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MDAP[R], 32
SHP[1], 33
SRP2[], 0
IP[], 21
MDAP[R], 21
SRP2[], 32
IP[], 54
CALL[], 21, 44, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="171">
      <instructions>
        <talk>/* VTTTalk glyph 171, char 0x1e92a */
/* GUI generated Fri Jun 23 02:58:41 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,51)
YAnchor(10,159)
YIPAnchor(51,43,10)
ResYDist(43,21)
YAnchor(32,158)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 171, char 0x1e92a */
/* VTT 6.35 compiler Fri Jun 23 02:58:41 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 51, 106
MIAP[R], 10, 159
IP[], 43
MDAP[R], 43
CALL[], 43, 21, 106
MIAP[R], 32, 158
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="172">
      <instructions>
        <talk>/* VTTTalk glyph 172, char 0x1e92b */
/* GUI generated Fri Jun 23 02:59:59 2023 */

/* Y direction */
YAnchor(6)
YAnchor(19,158)
ResYDist(19,55)
YAnchor(35,10)
ResYDist(35,60)
YInterpolate(60,49,19)
YInterpolate(35,68,55)
YInterpolate(68,27,26,49)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 172, char 0x1e92b */
/* VTT 6.35 compiler Fri Jun 23 02:59:59 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 19, 158
CALL[], 19, 55, 106
MIAP[R], 35, 10
CALL[], 35, 60, 106
SRP1[], 19
IP[], 49
SRP1[], 35
SRP2[], 55
IP[], 68
SRP1[], 68
SRP2[], 49
IP[], 27
IP[], 26
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="173">
      <instructions>
        <talk>/* VTTTalk glyph 173, char 0x1e92c */
/* GUI generated Fri Jun 23 03:00:48 2023 */

/* Y direction */
YAnchor(6)
YAnchor(17,160)
ResYDist(17,32)
YAnchor(49,10)
ResYDist(49,61)
YIPAnchor(49,41,17)
ResYDist(41,67)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 173, char 0x1e92c */
/* VTT 6.35 compiler Fri Jun 23 03:00:48 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 17, 160
CALL[], 17, 32, 106
MIAP[R], 49, 10
CALL[], 49, 61, 106
SRP2[], 17
IP[], 41
MDAP[R], 41
CALL[], 41, 67, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="174">
      <instructions>
        <talk>/* VTTTalk glyph 174, char 0x1e92d */
/* GUI generated Fri Jun 23 03:01:43 2023 */

/* Y direction */
YAnchor(0,11)
ResYDist(0,22)
YAnchor(11,158)
YShift(11,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 174, char 0x1e92d */
/* VTT 6.35 compiler Fri Jun 23 03:01:43 2023 */
SVTCA[Y]
MIAP[R], 0, 11
CALL[], 0, 22, 106
MIAP[R], 11, 158
SHP[1], 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="175">
      <instructions>
        <talk>/* VTTTalk glyph 175, char 0x1e92e */
/* GUI generated Fri Jun 23 03:02:14 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,38)
YAnchor(9,157)
ResYDist(9,31)
YAnchor(20)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 175, char 0x1e92e */
/* VTT 6.35 compiler Fri Jun 23 03:02:14 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 38, 106
MIAP[R], 9, 157
CALL[], 9, 31, 106
MDAP[R], 20
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="176">
      <instructions>
        <talk>/* VTTTalk glyph 176, char 0x1e92f */
/* GUI generated Fri Jun 23 03:03:41 2023 */

/* Y direction */
YAnchor(0,11)
ResYDist(0,40)
YAnchor(6,10)
YShift(6,32)
YAnchor(11,157)
ResYDist(11,48)
YInterpolate(0,33,3,51,15,7,11)
YAnchor(23,159)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 176, char 0x1e92f */
/* VTT 6.35 compiler Fri Jun 23 03:03:41 2023 */
SVTCA[Y]
MIAP[R], 0, 11
CALL[], 0, 40, 106
MIAP[R], 6, 10
SHP[1], 32
MIAP[R], 11, 157
CALL[], 11, 48, 106
SRP2[], 0
SLOOP[], 5
IP[], 33, 3, 51, 15, 7
MIAP[R], 23, 159
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="177">
      <instructions>
        <talk>/* VTTTalk glyph 177, char 0x1e930 */
/* GUI generated Fri Jun 23 03:04:29 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,41)
YAnchor(25,160)
YShift(25,28)
YShift(28,29)
ResYDist(25,34)
YShift(34,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 177, char 0x1e930 */
/* VTT 6.35 compiler Fri Jun 23 03:04:29 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 41, 106
MIAP[R], 25, 160
SHP[1], 28
SRP1[], 28
SHP[1], 29
CALL[], 25, 34, 106
SHP[2], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="178">
      <instructions>
        <talk>/* VTTTalk glyph 178, char 0x1e931 */
/* GUI generated Fri Jun 23 03:05:50 2023 */

/* Y direction */
YAnchor(0,11)
YShift(0,65)
YAnchor(32)
YAnchor(44,157)
ResYDist(44,7)
YIPAnchor(0,25,44)
YInterpolate(25,4,48,44)
ResYDist(25,11)
YAnchor(54,158)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 178, char 0x1e931 */
/* VTT 6.35 compiler Fri Jun 23 03:05:50 2023 */
SVTCA[Y]
MIAP[R], 0, 11
SHP[2], 65
MDAP[R], 32
MIAP[R], 44, 157
CALL[], 44, 7, 106
SRP2[], 0
IP[], 25
MDAP[R], 25
SRP2[], 44
IP[], 4
IP[], 48
CALL[], 25, 11, 106
MIAP[R], 54, 158
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="179">
      <instructions>
        <talk>/* VTTTalk glyph 179, char 0x1e932 */
/* GUI generated Fri Jun 23 03:06:25 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,44)
YAnchor(29,160)
YInterpolate(44,8,29)
ResYDist(29,16)
YInterpolate(0,37,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 179, char 0x1e932 */
/* VTT 6.35 compiler Fri Jun 23 03:06:25 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 44, 106
MIAP[R], 29, 160
IP[], 8
CALL[], 29, 16, 106
SRP1[], 0
IP[], 37
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="180">
      <instructions>
        <talk>/* VTTTalk glyph 180, char 0x1e933 */
/* GUI generated Fri Jun 23 03:09:44 2023 */

/* Y direction */
YAnchor(61,160)
ResYDist(61,48)
YShift(48,34)
YAnchor(73,10)
ResYDist(73,14)
YShift(73,67)
YIPAnchor(73,68,61)
YShift(68,18)
ResYDist(68,43)
YShift(43,25)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 180, char 0x1e933 */
/* VTT 6.35 compiler Fri Jun 23 03:09:44 2023 */
SVTCA[Y]
MIAP[R], 61, 160
CALL[], 61, 48, 106
SHP[2], 34
MIAP[R], 73, 10
CALL[], 73, 14, 106
SHP[1], 67
SRP2[], 61
IP[], 68
MDAP[R], 68
SHP[1], 18
CALL[], 68, 43, 106
SHP[2], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="181">
      <instructions>
        <talk>/* VTTTalk glyph 181, char 0x1e934 */
/* GUI generated Fri Jun 23 03:10:34 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(58,160)
YInterpolate(13,39,58)
YShift(39,36)
ResYDist(58,45)
YInterpolate(0,20,45)
YShift(20,23)
YInterpolate(20,68,67,29,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 181, char 0x1e934 */
/* VTT 6.35 compiler Fri Jun 23 03:10:34 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 58, 160
IP[], 39
SRP1[], 39
SHP[1], 36
CALL[], 58, 45, 106
SRP1[], 0
IP[], 20
SRP1[], 20
SHP[1], 23
SRP2[], 39
SLOOP[], 3
IP[], 68, 67, 29
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="182">
      <instructions>
        <talk>/* VTTTalk glyph 182, char 0x1e935 */
/* GUI generated Fri Jun 23 03:11:27 2023 */

/* Y direction */
YAnchor(0,11)
ResYDist(0,37)
YShift(37,47)
YShift(47,48)
YAnchor(8,157)
ResYDist(8,58)
YInterpolate(0,42,52,12,8)
YAnchor(21,158)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 182, char 0x1e935 */
/* VTT 6.35 compiler Fri Jun 23 03:11:27 2023 */
SVTCA[Y]
MIAP[R], 0, 11
CALL[], 0, 37, 106
SHP[2], 47
SRP1[], 47
SHP[1], 48
MIAP[R], 8, 157
CALL[], 8, 58, 106
SRP2[], 0
SLOOP[], 3
IP[], 42, 52, 12
MIAP[R], 21, 158
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="183">
      <instructions>
        <talk>/* VTTTalk glyph 183, char 0x1e936 */
/* GUI generated Fri Jun 23 03:12:07 2023 */

/* Y direction */
YAnchor(6)
YAnchor(18,157)
ResYDist(18,44)
YAnchor(40,10)
YShift(40,32)
YIPAnchor(40,26,18)
YInterpolate(40,22,26)
ResYDist(26,35)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 183, char 0x1e936 */
/* VTT 6.35 compiler Fri Jun 23 03:12:07 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 18, 157
CALL[], 18, 44, 106
MIAP[R], 40, 10
SHP[1], 32
SRP2[], 18
IP[], 26
MDAP[R], 26
SRP2[], 40
IP[], 22
CALL[], 26, 35, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="184">
      <instructions>
        <talk>/* VTTTalk glyph 184, char 0x1e937 */
/* GUI generated Fri Jun 23 03:13:13 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,44)
YAnchor(18)
YShift(18,19)
YIPAnchor(0,12,18)
YInterpolate(0,37,8,9,23,22,15,12)
YShift(12,11)
YAnchor(30)
YShift(30,31)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 184, char 0x1e937 */
/* VTT 6.35 compiler Fri Jun 23 03:13:13 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 44, 106
MDAP[R], 18
SHP[1], 19
SRP2[], 0
IP[], 12
MDAP[R], 12
SLOOP[], 6
IP[], 37, 8, 9, 23, 22, 15
SHP[1], 11
MDAP[R], 30
SHP[1], 31
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="185">
      <instructions>
        <talk>/* VTTTalk glyph 185, char 0x1e938 */
/* GUI generated Fri Jun 23 03:14:08 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(30,159)
YIPAnchor(0,41,30)
ResYDist(41,19)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 185, char 0x1e938 */
/* VTT 6.35 compiler Fri Jun 23 03:14:08 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 30, 159
SRP2[], 0
IP[], 41
MDAP[R], 41
CALL[], 41, 19, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="186">
      <instructions>
        <talk>/* VTTTalk glyph 186, char 0x1e939 */
/* GUI generated Fri Jun 23 03:15:40 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,56)
YAnchor(16,157)
ResYDist(16,23)
YInterpolate(0,50,23)
YInterpolate(56,29,16)
YInterpolate(50,7,8,29)
YAnchor(39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 186, char 0x1e939 */
/* VTT 6.35 compiler Fri Jun 23 03:15:40 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 56, 106
MIAP[R], 16, 157
CALL[], 16, 23, 106
SRP1[], 0
IP[], 50
SRP1[], 56
SRP2[], 16
IP[], 29
SRP1[], 50
SRP2[], 29
IP[], 7
IP[], 8
MDAP[R], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="187">
      <instructions>
        <talk>/* VTTTalk glyph 187, char 0x1e93a */
/* GUI generated Fri Jun 23 03:16:47 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(33,159)
YAnchor(53,19)
YInterpolate(0,21,53)
YAnchor(66,160)
ResYDist(66,52)
YInterpolate(13,45,66)
YInterpolate(21,74,73,45)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 187, char 0x1e93a */
/* VTT 6.35 compiler Fri Jun 23 03:16:47 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MIAP[R], 33, 159
MIAP[R], 53, 19
SRP2[], 0
IP[], 21
MIAP[R], 66, 160
CALL[], 66, 52, 106
SRP2[], 13
IP[], 45
SRP1[], 21
SRP2[], 45
IP[], 74
IP[], 73
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="188">
      <instructions>
        <talk>/* VTTTalk glyph 188, char 0x1e93b */
/* GUI generated Fri Jun 23 03:18:00 2023 */

/* Y direction */
YAnchor(6)
YAnchor(43,10)
ResYDist(43,28)
YAnchor(60,157)
ResYDist(60,88)
YInterpolate(43,18,88)
YInterpolate(28,95,60)
YInterpolate(18,22,51,52,95)
YInterpolate(95,81,88)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 188, char 0x1e93b */
/* VTT 6.35 compiler Fri Jun 23 03:18:00 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 43, 10
CALL[], 43, 28, 106
MIAP[R], 60, 157
CALL[], 60, 88, 106
SRP1[], 43
IP[], 18
SRP1[], 28
SRP2[], 60
IP[], 95
SRP1[], 18
SRP2[], 95
SLOOP[], 3
IP[], 22, 51, 52
SRP1[], 88
IP[], 81
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="189">
      <instructions>
        <talk>/* VTTTalk glyph 189, char 0x1e93c */
/* GUI generated Fri Jun 23 03:18:55 2023 */

/* Y direction */
YAnchor(6)
YAnchor(17,157)
ResYDist(17,76)
YAnchor(30,158)
YAnchor(65,10)
YInterpolate(65,44,72,73,20,17)
ResYDist(65,50)
YShift(50,39)
YAnchor(39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 189, char 0x1e93c */
/* VTT 6.35 compiler Fri Jun 23 03:18:55 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 17, 157
CALL[], 17, 76, 106
MIAP[R], 30, 158
MIAP[R], 65, 10
SRP2[], 17
SLOOP[], 4
IP[], 44, 72, 73, 20
CALL[], 65, 50, 106
SHP[2], 39
MDAP[R], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="190">
      <instructions>
        <talk>/* VTTTalk glyph 190, char 0x1e93d */
/* GUI generated Fri Jun 23 03:20:56 2023 */

/* Y direction */
YAnchor(12)
ResYDist(12,0)
YAnchor(49,157)
ResYDist(49,92)
YAnchor(76,10)
YInterpolate(76,57,92)
YShift(57,80)
ResYDist(76,61)
YInterpolate(61,86,49)
YShift(86,23)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 190, char 0x1e93d */
/* VTT 6.35 compiler Fri Jun 23 03:20:56 2023 */
SVTCA[Y]
MDAP[R], 12
CALL[], 12, 0, 106
MIAP[R], 49, 157
CALL[], 49, 92, 106
MIAP[R], 76, 10
IP[], 57
SRP1[], 57
SHP[1], 80
CALL[], 76, 61, 106
SRP1[], 49
IP[], 86
SRP1[], 86
SHP[1], 23
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="191">
      <instructions>
        <talk>/* VTTTalk glyph 191, char 0x1e93e */
/* GUI generated Fri Jun 23 03:21:57 2023 */

/* Y direction */
YAnchor(0,11)
YShift(0,1)
YAnchor(12,158)
YAnchor(22,157)
ResYDist(22,59)
YIPAnchor(0,41,22)
YInterpolate(41,62,17,22)
ResYDist(41,55)
YAnchor(34)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 191, char 0x1e93e */
/* VTT 6.35 compiler Fri Jun 23 03:21:57 2023 */
SVTCA[Y]
MIAP[R], 0, 11
SHP[2], 1
MIAP[R], 12, 158
MIAP[R], 22, 157
CALL[], 22, 59, 106
SRP2[], 0
IP[], 41
MDAP[R], 41
SRP2[], 22
IP[], 62
IP[], 17
CALL[], 41, 55, 106
MDAP[R], 34
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="192">
      <instructions>
        <talk>/* VTTTalk glyph 192, char 0x1e93f */
/* GUI generated Fri Jun 23 03:22:37 2023 */

/* Y direction */
YAnchor(1,10)
YShift(1,7)
ResYDist(1,60)
YAnchor(12,160)
YIPAnchor(1,6,12)
YShift(6,56)
ResYDist(6,31)
YShift(31,49)
ResYDist(12,27)
YShift(27,40)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 192, char 0x1e93f */
/* VTT 6.35 compiler Fri Jun 23 03:22:37 2023 */
SVTCA[Y]
MIAP[R], 1, 10
SHP[1], 7
CALL[], 1, 60, 106
MIAP[R], 12, 160
SRP2[], 1
IP[], 6
MDAP[R], 6
SHP[1], 56
CALL[], 6, 31, 106
SHP[2], 49
CALL[], 12, 27, 106
SHP[2], 40
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="193">
      <instructions>
        <talk>/* VTTTalk glyph 193, char 0x1e940 */
/* GUI generated Fri Jun 23 03:23:20 2023 */

/* Y direction */
YAnchor(1,19)
ResYDist(1,52)
YAnchor(34)
YShift(34,33)
YIPAnchor(1,45,34)
YInterpolate(45,12,34)
ResYDist(45,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 193, char 0x1e940 */
/* VTT 6.35 compiler Fri Jun 23 03:23:20 2023 */
SVTCA[Y]
MIAP[R], 1, 19
CALL[], 1, 52, 106
MDAP[R], 34
SHP[1], 33
SRP2[], 1
IP[], 45
MDAP[R], 45
SRP2[], 34
IP[], 12
CALL[], 45, 22, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="194">
      <instructions>
        <talk>/* VTTTalk glyph 194, char 0x1e941 */
/* GUI generated Fri Jun 23 03:24:15 2023 */

/* Y direction */
YAnchor(0,10)
YShift(0,86)
ResYDist(0,13)
YShift(13,31)
YShift(13,73)
YShift(73,58)
YShift(58,57)
YAnchor(41,157)
YShift(41,50)
ResYDist(41,21)
YShift(21,65)
YInterpolate(0,93,45,41)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 194, char 0x1e941 */
/* VTT 6.35 compiler Fri Jun 23 03:24:15 2023 */
SVTCA[Y]
MIAP[R], 0, 10
SHP[2], 86
CALL[], 0, 13, 106
SHP[2], 31
SHP[2], 73
SRP1[], 73
SHP[1], 58
SRP1[], 58
SHP[1], 57
MIAP[R], 41, 157
SHP[1], 50
CALL[], 41, 21, 106
SHP[2], 65
SRP2[], 0
IP[], 93
IP[], 45
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="195">
      <instructions>
        <talk>/* VTTTalk glyph 195, char 0x1e942 */
/* GUI generated Fri Jun 23 03:24:35 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,34)
YAnchor(7,157)
ResYDist(7,27)
YIPAnchor(7,14,0)
ResYDist(14,21)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 195, char 0x1e942 */
/* VTT 6.35 compiler Fri Jun 23 03:24:35 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 34, 106
MIAP[R], 7, 157
CALL[], 7, 27, 106
SRP2[], 0
IP[], 14
MDAP[R], 14
CALL[], 14, 21, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="196">
      <instructions>
        <talk>/* VTTTalk glyph 196, char 0x1e943 */
/* GUI generated Fri Jun 23 03:25:34 2023 */

/* Y direction */
YAnchor(0,11)
ResYDist(0,47)
YAnchor(10,159)
YAnchor(24,157)
ResYDist(24,40)
YIPAnchor(0,30,24)
YShift(30,51)
ResYDist(30,36)
YShift(36,19)
YAnchor(29,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 196, char 0x1e943 */
/* VTT 6.35 compiler Fri Jun 23 03:25:34 2023 */
SVTCA[Y]
MIAP[R], 0, 11
CALL[], 0, 47, 106
MIAP[R], 10, 159
MIAP[R], 24, 157
CALL[], 24, 40, 106
SRP2[], 0
IP[], 30
MDAP[R], 30
SHP[1], 51
CALL[], 30, 36, 106
SHP[2], 19
MIAP[R], 29, 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="197">
      <instructions>
        <talk>/* VTTTalk glyph 197, char 0xffff */
/* GUI generated Fri Jun 23 03:26:20 2023 */

/* Y direction */
YAnchor(0,11)
ResYDist(0,36)
YShift(36,51)
YAnchor(11,159)
YAnchor(24,157)
ResYDist(24,44)
YIPAnchor(0,55,24)
ResYDist(55,20)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 197, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 03:26:20 2023 */
SVTCA[Y]
MIAP[R], 0, 11
CALL[], 0, 36, 106
SHP[2], 51
MIAP[R], 11, 159
MIAP[R], 24, 157
CALL[], 24, 44, 106
SRP2[], 0
IP[], 55
MDAP[R], 55
CALL[], 55, 20, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="198">
      <instructions>
        <talk>/* VTTTalk glyph 198, char 0xffff */
/* GUI generated Fri Jun 23 03:27:01 2023 */

/* Y direction */
YAnchor(6)
YAnchor(18,157)
YShift(18,26)
ResYDist(18,77)
YShift(77,47)
YAnchor(70,10)
YInterpolate(70,22,18)
ResYDist(70,54)
YShift(54,37)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 198, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 03:27:01 2023 */
SVTCA[Y]
MDAP[R], 6
MIAP[R], 18, 157
SHP[1], 26
CALL[], 18, 77, 106
SHP[2], 47
MIAP[R], 70, 10
SRP2[], 18
IP[], 22
CALL[], 70, 54, 106
SHP[2], 37
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="199">
      <instructions>
        <talk>/* VTTTalk glyph 199, char 0xffff */
/* GUI generated Fri Jun 23 03:28:00 2023 */

/* Y direction */
YAnchor(0,10)
ResYDist(0,13)
YAnchor(32)
YIPAnchor(0,43,32)
ResYDist(43,21)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 199, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 03:28:00 2023 */
SVTCA[Y]
MIAP[R], 0, 10
CALL[], 0, 13, 106
MDAP[R], 32
SRP2[], 0
IP[], 43
MDAP[R], 43
CALL[], 43, 21, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="200">
      <instructions>
        <talk>/* VTTTalk glyph 200, char 0x1e94b */
/* GUI generated Fri Jun 23 03:28:09 2023 */

/* Y direction */
YAnchor(1)
YDist(1,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 200, char 0x1e94b */
/* VTT 6.35 compiler Fri Jun 23 03:28:09 2023 */
SVTCA[Y]
MDAP[R], 1
MDRP[m&gt;RBl], 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="201">
      <instructions>
        <talk>/* VTTTalk glyph 201, char 0x1e950 */
/* GUI generated Fri Jun 23 03:28:41 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,7)
YAnchor(36,3)
ResYDist(36,13)
YInterpolate(7,3,4,24,13)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 201, char 0x1e950 */
/* VTT 6.35 compiler Fri Jun 23 03:28:41 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 7, 106
MIAP[R], 36, 3
CALL[], 36, 13, 106
SRP1[], 7
SLOOP[], 3
IP[], 3, 4, 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="202">
      <instructions>
        <talk>/* VTTTalk glyph 202, char 0x1e951 */
/* GUI generated Fri Jun 23 03:29:04 2023 */

/* Y direction */
YAnchor(0,8)
YAnchor(14,2)
ResYDist(14,30)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 202, char 0x1e951 */
/* VTT 6.35 compiler Fri Jun 23 03:29:04 2023 */
SVTCA[Y]
MIAP[R], 0, 8
MIAP[R], 14, 2
CALL[], 14, 30, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="203">
      <instructions>
        <talk>/* VTTTalk glyph 203, char 0x1e952 */
/* GUI generated Fri Jun 23 03:29:52 2023 */

/* Y direction */
YAnchor(0,8)
YAnchor(26,2)
YInterpolate(26,30,31,21,5,10,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 203, char 0x1e952 */
/* VTT 6.35 compiler Fri Jun 23 03:29:52 2023 */
SVTCA[Y]
MIAP[R], 0, 8
MIAP[R], 26, 2
SLOOP[], 5
IP[], 30, 31, 21, 5, 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="204">
      <instructions>
        <talk>/* VTTTalk glyph 204, char 0x1e953 */
/* GUI generated Fri Jun 23 03:30:26 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,60)
YAnchor(20,17)
YShift(20,42)
YIPAnchor(0,54,20)
ResYDist(54,32)
YInterpolate(54,8,9,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 204, char 0x1e953 */
/* VTT 6.35 compiler Fri Jun 23 03:30:32 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 60, 106
MIAP[R], 20, 17
SHP[1], 42
SRP2[], 0
IP[], 54
MDAP[R], 54
CALL[], 54, 32, 106
IP[], 8
IP[], 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="205">
      <instructions>
        <talk>/* VTTTalk glyph 205, char 0x1e954 */
/* GUI generated Fri Jun 23 03:31:06 2023 */

/* Y direction */
YAnchor(0,8)
ResYDist(0,60)
YAnchor(16,17)
YIPAnchor(0,37,16)
YInterpolate(0,53,6,28,27,37)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 205, char 0x1e954 */
/* VTT 6.35 compiler Fri Jun 23 03:31:06 2023 */
SVTCA[Y]
MIAP[R], 0, 8
CALL[], 0, 60, 106
MIAP[R], 16, 17
SRP2[], 0
IP[], 37
MDAP[R], 37
SLOOP[], 4
IP[], 53, 6, 28, 27
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="206">
      <instructions>
        <talk>/* VTTTalk glyph 206, char 0x1e955 */
/* GUI generated Fri Jun 23 03:32:36 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,40)
YAnchor(21,17)
YInterpolate(40,64,21)
YInterpolate(0,52,64)
ResYDist(21,78)
YInterpolate(0,34,78)
YInterpolate(34,7,8,64)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 206, char 0x1e955 */
/* VTT 6.35 compiler Fri Jun 23 03:32:36 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 40, 106
MIAP[R], 21, 17
IP[], 64
SRP1[], 0
SRP2[], 64
IP[], 52
CALL[], 21, 78, 106
SRP1[], 0
IP[], 34
SRP1[], 34
SRP2[], 64
IP[], 7
IP[], 8
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="207">
      <instructions>
        <talk>/* VTTTalk glyph 207, char 0x1e956 */
/* GUI generated Fri Jun 23 03:33:46 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,53)
YAnchor(30,2)
YInterpolate(53,8,30)
ResYDist(30,16)
YInterpolate(0,61,16)
YShift(61,38)
YInterpolate(0,46,30)
YAnchor(43,8)
YDist(43,42)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 207, char 0x1e956 */
/* VTT 6.35 compiler Fri Jun 23 03:33:46 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 53, 106
MIAP[R], 30, 2
IP[], 8
CALL[], 30, 16, 106
SRP1[], 0
IP[], 61
SRP1[], 61
SHP[1], 38
SRP1[], 0
SRP2[], 30
IP[], 46
MIAP[R], 43, 8
MDRP[m&gt;RBl], 42
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="208">
      <instructions>
        <talk>/* VTTTalk glyph 208, char 0x1e957 */
/* GUI generated Fri Jun 23 03:34:53 2023 */

/* Y direction */
YAnchor(0,9)
YShift(0,38)
YAnchor(15,3)
ResYDist(15,46)
YAnchor(27,8)
YInterpolate(27,31,46)
YInterpolate(27,39,15)
YInterpolate(31,7,22,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 208, char 0x1e957 */
/* VTT 6.35 compiler Fri Jun 23 03:34:53 2023 */
SVTCA[Y]
MIAP[R], 0, 9
SHP[2], 38
MIAP[R], 15, 3
CALL[], 15, 46, 106
MIAP[R], 27, 8
IP[], 31
SRP2[], 15
IP[], 39
SRP1[], 31
SRP2[], 39
IP[], 7
IP[], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="209">
      <instructions>
        <talk>/* VTTTalk glyph 209, char 0x1e958 */
/* GUI generated Fri Jun 23 03:35:31 2023 */

/* Y direction */
YAnchor(0,17)
YShift(0,38)
YAnchor(15,19)
ResYDist(15,46)
YAnchor(26,2)
YInterpolate(46,31,26)
YInterpolate(15,39,26)
YInterpolate(39,7,22,31)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 209, char 0x1e958 */
/* VTT 6.35 compiler Fri Jun 23 03:35:31 2023 */
SVTCA[Y]
MIAP[R], 0, 17
SHP[2], 38
MIAP[R], 15, 19
CALL[], 15, 46, 106
MIAP[R], 26, 2
IP[], 31
SRP2[], 15
IP[], 39
SRP1[], 39
SRP2[], 31
IP[], 7
IP[], 22
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="210">
      <instructions>
        <talk>/* VTTTalk glyph 210, char 0x1e959 */
/* GUI generated Fri Jun 23 03:36:05 2023 */

/* Y direction */
YAnchor(0,9)
YShift(0,33)
YAnchor(18,3)
YInterpolate(33,34,18)
ResYDist(18,41)
YInterpolate(0,8,41)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 210, char 0x1e959 */
/* VTT 6.35 compiler Fri Jun 23 03:36:05 2023 */
SVTCA[Y]
MIAP[R], 0, 9
SHP[2], 33
MIAP[R], 18, 3
SRP2[], 33
IP[], 34
CALL[], 18, 41, 106
SRP1[], 0
IP[], 8
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="211">
      <instructions>
        <talk>/* VTTTalk Unicode 0x30 (0) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 13 */
/* CVT 6 5 */
/* Min and Max */
ResYAnchor(0,13)	/* min, CVT */
ResYAnchor(6,5)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(6,19) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
ResYDist(0,13) /*perpendicular to the stroke*/

Smooth()

</talk>
        <assembly>
/* TT glyph 211, char 0x30 (0) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 0, 13, 114
CALL[], 6, 5, 114
CALL[], 6, 19, 106
CALL[], 0, 13, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="212">
      <instructions>
        <talk>/* VTTTalk glyph 212, char 0x31 (1) */
/* GUI generated Fri Jun 23 03:36:33 2023 */

/* Y direction */
ResYAnchor(4,12)
ResYAnchor(25,5)
YShift(25,24)
YShift(25,8)
YShift(8,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 212, char 0x31 (1) */
/* VTT 6.35 compiler Fri Jun 23 03:36:33 2023 */
SVTCA[Y]
CALL[], 4, 12, 114
CALL[], 25, 5, 114
SHP[2], 24
SHP[2], 8
SRP1[], 8
SHP[1], 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="213">
      <instructions>
        <talk>/* VTTTalk glyph 213, char 0x32 (2) */
/* GUI generated Fri Jun 23 03:36:50 2023 */

/* Y direction */
ResYAnchor(25,5)
ResYDist(25,11)
ResYAnchor(51,12)
YInterpolate(51,32,11)
ResYDist(51,35)
YShift(35,1)
YInterpolate(35,6,25)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 213, char 0x32 (2) */
/* VTT 6.35 compiler Fri Jun 23 03:36:50 2023 */
SVTCA[Y]
CALL[], 25, 5, 114
CALL[], 25, 11, 106
CALL[], 51, 12, 114
SRP1[], 11
IP[], 32
CALL[], 51, 35, 106
SHP[2], 1
SRP1[], 25
IP[], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="214">
      <instructions>
        <talk>/* VTTTalk glyph 214, char 0x33 (3) */
/* GUI generated Fri Jun 23 03:37:04 2023 */

/* Y direction */
ResYAnchor(0,13)
ResYDist(0,17)
YAnchor(39,4)
ResYAnchor(60,5)
ResYDist(60,43)
YIPAnchor(60,24,0)
ResYDist(24,38)
YInterpolate(24,67,66,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 214, char 0x33 (3) */
/* VTT 6.35 compiler Fri Jun 23 03:37:04 2023 */
SVTCA[Y]
CALL[], 0, 13, 114
CALL[], 0, 17, 106
MIAP[R], 39, 4
CALL[], 60, 5, 114
CALL[], 60, 43, 106
SRP2[], 0
IP[], 24
MDAP[R], 24
CALL[], 24, 38, 106
SRP2[], 39
IP[], 67
IP[], 66
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="215">
      <instructions>
        <talk>/* VTTTalk glyph 215, char 0x34 (4) */
/* GUI generated Fri Jun 23 03:37:16 2023 */

/* Y direction */
ResYAnchor(4,12)
ResYAnchor(20,4)
YIPAnchor(20,41,4)
YInterpolate(20,44,41)
YShift(41,9)
ResYDist(41,25)
YShift(25,42)
YShift(42,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 215, char 0x34 (4) */
/* VTT 6.35 compiler Fri Jun 23 03:37:16 2023 */
SVTCA[Y]
CALL[], 4, 12, 114
CALL[], 20, 4, 114
SRP1[], 4
IP[], 41
MDAP[R], 41
IP[], 44
SHP[1], 9
CALL[], 41, 25, 106
SHP[2], 42
SRP1[], 42
SHP[1], 16
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="216">
      <instructions>
        <talk>/* VTTTalk glyph 216, char 0x35 (5) */
/* GUI generated Fri Jun 23 03:37:35 2023 */

/* Y direction */
ResYAnchor(0,13)
ResYDist(0,17)
ResYAnchor(30,4)
ResYDist(30,46)
YIPAnchor(0,52,30)
ResYDist(52,22)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 216, char 0x35 (5) */
/* VTT 6.35 compiler Fri Jun 23 03:37:35 2023 */
SVTCA[Y]
CALL[], 0, 13, 114
CALL[], 0, 17, 106
CALL[], 30, 4, 114
CALL[], 30, 46, 106
SRP2[], 0
IP[], 52
MDAP[R], 52
CALL[], 52, 22, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="217">
      <instructions>
        <talk>/* VTTTalk glyph 217, char 0x36 (6) */
/* GUI generated Fri Jun 23 03:37:49 2023 */

/* Y direction */
ResYAnchor(0,13)
ResYDist(0,42)
ResYAnchor(7,5)
ResYDist(7,28)
YIPAnchor(0,35,7)
ResYDist(35,48)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 217, char 0x36 (6) */
/* VTT 6.35 compiler Fri Jun 23 03:37:49 2023 */
SVTCA[Y]
CALL[], 0, 13, 114
CALL[], 0, 42, 106
CALL[], 7, 5, 114
CALL[], 7, 28, 106
SRP2[], 0
IP[], 35
MDAP[R], 35
CALL[], 35, 48, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="218">
      <instructions>
        <talk>/* VTTTalk glyph 218, char 0x37 (7) */
/* GUI generated Fri Jun 23 03:37:56 2023 */

/* Y direction */
ResYAnchor(24,4)
YShift(24,22)
ResYDist(24,10)
YShift(10,31)
ResYAnchor(38,12)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 218, char 0x37 (7) */
/* VTT 6.35 compiler Fri Jun 23 03:37:56 2023 */
SVTCA[Y]
CALL[], 24, 4, 114
SHP[2], 22
CALL[], 24, 10, 106
SHP[2], 31
CALL[], 38, 12, 114
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="219">
      <instructions>
        <talk>/* VTTTalk glyph 219, char 0x38 (8) */
/* GUI generated Fri Jun 23 03:38:12 2023 */

/* Y direction */
ResYAnchor(0,13)
ResYDist(0,39)
ResYAnchor(14,5)
ResYDist(14,33)
YIPAnchor(14,45,0)
ResYDist(45,27)
YInterpolate(45,6,7,21,20,27)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 219, char 0x38 (8) */
/* VTT 6.35 compiler Fri Jun 23 03:38:12 2023 */
SVTCA[Y]
CALL[], 0, 13, 114
CALL[], 0, 39, 106
CALL[], 14, 5, 114
CALL[], 14, 33, 106
SRP2[], 0
IP[], 45
MDAP[R], 45
CALL[], 45, 27, 106
SLOOP[], 4
IP[], 6, 7, 21, 20
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="220">
      <instructions>
        <talk>/* VTTTalk Unicode 0x39 (9) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* CVT 0 5 */
/* CVT 7 13 */
/* Min and Max */
ResYAnchor(7,13)	/* min, CVT */
ResYAnchor(0,5)	/* max, CVT */

/* CVTs - beginning */
/* CVTs - end */


/* YDir: Stroke #0 */
ResYDist(0,43) /*perpendicular to the stroke*/

/* YDir: Stroke #1 */
YInterpolate(0,35,7)
YAnchor(35)
ResYDist(35,49) /*perpendicular to the stroke*/

/* YDir: Stroke #2 */
ResYDist(7,28) /*perpendicular to the stroke*/

Smooth()

</talk>
        <assembly>
/* TT glyph 220, char 0x39 (9) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
CALL[], 7, 13, 114
CALL[], 0, 5, 114
CALL[], 0, 43, 106
SRP2[], 7
IP[], 35
MDAP[R], 35
CALL[], 35, 49, 106
CALL[], 7, 28, 106
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="221">
      <instructions>
        <talk>/* VTTTalk glyph 221, char 0x2044 */
/* GUI generated Fri Jun 23 03:38:37 2023 */

/* Y direction */
YAnchor(5)
YAnchor(18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 221, char 0x2044 */
/* VTT 6.35 compiler Fri Jun 23 03:38:37 2023 */
SVTCA[Y]
MDAP[R], 5
MDAP[R], 18
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="222">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xbd */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 379, 2, 0
OFFSET[R], 221, 701, 0
OFFSET[R], 380, 1257, -584</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="223">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xbc */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 379, 0, 0
OFFSET[R], 221, 702, 0
OFFSET[R], 382, 1110, -583</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="224">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xbe */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 381, 0, 0
OFFSET[R], 221, 624, 0
OFFSET[R], 382, 1033, -584</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="225">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xb9 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 379, 0, 300
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="226">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xb2 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 380, 0, 300
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="227">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xb3 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 381, 0, 300
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="228">
      <instructions>
        <talk>/* VTTTalk Unicode 0xd */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/*Auto-Hinting Light is not applied: Empty glyph or glyph with one point*/

</talk>
        <assembly>
/* TT glyph 228, char 0xd */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="229">
      <instructions>
        <talk>/* VTTTalk Unicode 0xffff */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/*Auto-Hinting Light is not applied: Empty glyph or glyph with one point*/
</talk>
        <assembly>
/* TT glyph 229, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="230">
      <instructions>
        <talk>/* VTTTalk Unicode 0x20 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/*Auto-Hinting Light is not applied: Empty glyph or glyph with one point*/
</talk>
        <assembly>
/* TT glyph 230, char 0x20 */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="231">
      <instructions>
        <talk>/* VTTTalk Unicode 0xa0 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/*Auto-Hinting Light is not applied: Empty glyph or glyph with one point*/
</talk>
        <assembly>
/* TT glyph 231, char 0xa0 */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="232">
      <instructions>
        <talk>/* VTTTalk glyph 232, char 0x1e95e */
/* GUI generated Fri Jun 23 03:40:19 2023 */

/* Y direction */
YAnchor(0)
YShift(0,61)
YAnchor(12,2)
YDist(12,30)
YIPAnchor(0,6,12)
YShift(6,44)
ResYDist(6,7)
YInterpolate(6,19,18,7)
YShift(7,24)
YShift(24,25)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 232, char 0x1e95e */
/* VTT 6.35 compiler Fri Jun 23 03:40:19 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 61
MIAP[R], 12, 2
MDRP[m&lt;RWh], 30
SRP2[], 0
IP[], 6
MDAP[R], 6
SHP[1], 44
CALL[], 6, 7, 106
IP[], 19
IP[], 18
SHP[2], 24
SRP1[], 24
SHP[1], 25
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="233">
      <instructions>
        <talk>/* VTTTalk glyph 233, char 0x1e95f */
/* GUI generated Fri Jun 23 03:41:32 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YAnchor(40)
YIPAnchor(0,6,16,40)
YInterpolate(6,45,20,16)
YInterpolate(16,25,36,40)
YShift(6,5)
ResYDist(6,54)
YShift(6,75)
YShift(16,29)
ResYDist(16,48)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 233, char 0x1e95f */
/* VTT 6.35 compiler Fri Jun 23 03:41:32 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
MDAP[R], 40
IP[], 6
IP[], 16
MDAP[R], 6
MDAP[R], 16
SRP2[], 6
IP[], 45
IP[], 20
SRP2[], 40
IP[], 25
IP[], 36
SRP1[], 6
SHP[1], 5
CALL[], 6, 54, 106
SHP[1], 75
SRP1[], 16
SHP[1], 29
CALL[], 16, 48, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="234">
      <instructions>
        <talk>/* VTTTalk glyph 234, char 0x61f */
/* GUI generated Fri Jun 23 03:43:28 2023 */

/* Y direction */
YAnchor(18,3)
ResYDist(18,35)
YAnchor(75)
YDist(75,58)
YDist(58,1)
YInterpolate(1,10,35)
YInterpolate(1,42,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 234, char 0x61f */
/* VTT 6.35 compiler Fri Jun 23 03:43:28 2023 */
SVTCA[Y]
MIAP[R], 18, 3
CALL[], 18, 35, 106
MDAP[R], 75
MDRP[M&gt;RBl], 58
MDRP[m&lt;RWh], 1
SRP1[], 35
IP[], 10
SRP1[], 18
IP[], 42
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="235">
      <instructions>
        <talk>/* VTTTalk glyph 235, char 0x2e (.) */
/* GUI generated Fri Jun 23 03:42:37 2023 */

/* Y direction */
YAnchor(25)
ResYDist(25,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 235, char 0x2e (.) */
/* VTT 6.35 compiler Fri Jun 23 03:42:39 2023 */
SVTCA[Y]
MDAP[R], 25
CALL[], 25, 9, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="236">
      <instructions>
        <talk>/* VTTTalk glyph 236, char 0x2c (,) */
/* GUI generated Fri Jun 23 03:42:49 2023 */

/* Y direction */
YAnchor(6)
YDist(6,12)
YShift(12,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 236, char 0x2c (,) */
/* VTT 6.35 compiler Fri Jun 23 03:42:49 2023 */
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RBl], 12
SHP[2], 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="237">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x3a (:) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 235, 0, 40
USEMYMETRICS[]
OFFSET[R], 235, 0, 663</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="238">
      <instructions>
        <talk>/* VTTTalk Unicode 0x3b (;) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* Min and Max */
YAnchor(45)	/* min */
YAnchor(9)	/* max */

/* Extreme Max */
YShift(9,11)

/* Extreme Max */
YShift(9,7)

Smooth()

</talk>
        <assembly>
/* TT glyph 238, char 0x3b (;) */
/* VTT 6.35 compiler Fri Jun 23 01:02:17 2023 */
SVTCA[Y]
MDAP[R], 45
MDAP[R], 9
SHP[1], 11
SHP[1], 7
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="239">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x2026 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 235, 35, 0
OFFSET[R], 235, 658, 0
OFFSET[R], 235, 1278, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="240">
      <instructions>
        <talk>/* VTTTalk glyph 240, char 0x21 (!) */
/* GUI generated Fri Jun 23 03:43:13 2023 */

/* Y direction */
YAnchor(5,2)
YAnchor(37)
YDist(37,20)
YDist(20,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 240, char 0x21 (!) */
/* VTT 6.35 compiler Fri Jun 23 03:43:13 2023 */
SVTCA[Y]
MIAP[R], 5, 2
MDAP[R], 37
MDRP[M&gt;RBl], 20
MDRP[m&lt;RWh], 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="241">
      <instructions>
        <talk>/* VTTTalk glyph 241, char 0xa1 */
/* GUI generated Fri Jun 23 03:43:46 2023 */

/* Y direction */
YAnchor(6)
YAnchor(37)
YDist(37,20)
YDist(20,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 241, char 0xa1 */
/* VTT 6.35 compiler Fri Jun 23 03:43:46 2023 */
SVTCA[Y]
MDAP[R], 6
MDAP[R], 37
MDRP[M&gt;RBl], 20
MDRP[m&lt;RWh], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="242">
      <instructions>
        <talk>/* VTTTalk glyph 242, char 0x3f (?) */
/* GUI generated Fri Jun 23 03:44:15 2023 */

/* Y direction */
YAnchor(31,3)
ResYDist(31,14)
YAnchor(74)
YDist(74,57)
YDist(57,0)
YInterpolate(0,7,31)
YInterpolate(0,39,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 242, char 0x3f (?) */
/* VTT 6.35 compiler Fri Jun 23 03:44:15 2023 */
SVTCA[Y]
MIAP[R], 31, 3
CALL[], 31, 14, 106
MDAP[R], 74
MDRP[M&gt;RBl], 57
MDRP[m&lt;RWh], 0
SRP1[], 31
IP[], 7
SRP1[], 14
IP[], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="243">
      <instructions>
        <talk>/* VTTTalk glyph 243, char 0xbf */
/* GUI generated Fri Jun 23 03:44:43 2023 */

/* Y direction */
YAnchor(31)
ResYDist(31,14)
YAnchor(74)
YDist(74,57)
YDist(57,0)
YInterpolate(0,7,31)
YInterpolate(0,39,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 243, char 0xbf */
/* VTT 6.35 compiler Fri Jun 23 03:44:43 2023 */
SVTCA[Y]
MDAP[R], 31
CALL[], 31, 14, 106
MDAP[R], 74
MDRP[M&gt;RBl], 57
MDRP[m&lt;RWh], 0
SRP1[], 31
IP[], 7
SRP1[], 14
IP[], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="244">
      <instructions>
        <talk>/* VTTTalk glyph 244, char 0xb7 */
/* GUI generated Fri Jun 23 03:44:48 2023 */

/* Y direction */
YAnchor(25)
ResYDist(25,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 244, char 0xb7 */
/* VTT 6.35 compiler Fri Jun 23 03:44:50 2023 */
SVTCA[Y]
MDAP[R], 25
CALL[], 25, 8, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="245">
      <instructions>
        <talk>/* VTTTalk glyph 245, char 0x2022 */
/* GUI generated Fri Jun 23 03:44:55 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 245, char 0x2022 */
/* VTT 6.35 compiler Fri Jun 23 03:44:57 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 8, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="246">
      <instructions>
        <talk>/* VTTTalk glyph 246, char 0x2a (*) */
/* GUI generated Fri Jun 23 03:45:38 2023 */

/* Y direction */
YAnchor(28,2)
YDist(28,2)
YShift(2,55)
YInterpolate(2,50,7,58,47,10,11,44,34,23,20,37,28)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 246, char 0x2a (*) */
/* VTT 6.35 compiler Fri Jun 23 03:45:38 2023 */
SVTCA[Y]
MIAP[R], 28, 2
MDRP[m&lt;RGr], 2
SHP[2], 55
SLOOP[], 11
IP[], 50, 7, 58, 47, 10, 11, 44, 34, 23, 20, 37
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="247">
      <instructions>
        <talk>/* VTTTalk glyph 247, char 0x2e41 */
/* GUI generated Fri Jun 23 03:45:51 2023 */

/* Y direction */
YAnchor(6)
YDist(6,1)
YShift(1,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 247, char 0x2e41 */
/* VTT 6.35 compiler Fri Jun 23 03:45:51 2023 */
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RBl], 1
SHP[2], 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="248">
      <instructions>
        <talk>/* VTTTalk glyph 248, char 0x23 (#) */
/* GUI generated Fri Jun 23 03:46:44 2023 */

/* Y direction */
YAnchor(0)
YShift(0,82)
YAnchor(34)
YShift(34,47)
YIPAnchor(0,7,19,34)
ResYDist(7,18)
YShift(18,94)
YShift(94,67)
YShift(7,90)
YShift(90,78)
ResYDist(19,30)
YShift(30,42)
YShift(42,55)
YShift(19,97)
YShift(97,66)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 248, char 0x23 (#) */
/* VTT 6.35 compiler Fri Jun 23 03:46:44 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 82
MDAP[R], 34
SHP[1], 47
IP[], 7
IP[], 19
MDAP[R], 7
MDAP[R], 19
CALL[], 7, 18, 106
SHP[2], 94
SRP1[], 94
SHP[1], 67
SRP1[], 7
SHP[1], 90
SRP1[], 90
SHP[1], 78
CALL[], 19, 30, 106
SHP[2], 42
SRP1[], 42
SHP[1], 55
SRP1[], 19
SHP[1], 97
SRP1[], 97
SHP[1], 66
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="249">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x204f */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 235, -4, 733
USEMYMETRICS[]
OFFSET[R], 247, 0, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="250">
      <instructions>
        <talk>/* VTTTalk glyph 250, char 0x2f (/) */
/* GUI generated Fri Jun 23 03:47:02 2023 */

/* Y direction */
YAnchor(7,17)
YAnchor(21)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 250, char 0x2f (/) */
/* VTT 6.35 compiler Fri Jun 23 03:47:02 2023 */
SVTCA[Y]
MIAP[R], 7, 17
MDAP[R], 21
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="251">
      <instructions>
        <talk>/* VTTTalk glyph 251, char 0x5c (\) */
/* GUI generated Fri Jun 23 03:47:19 2023 */

/* Y direction */
YAnchor(4)
YAnchor(16,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 251, char 0x5c (\) */
/* VTT 6.35 compiler Fri Jun 23 03:47:19 2023 */
SVTCA[Y]
MDAP[R], 4
MIAP[R], 16, 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="252">
      <instructions>
        <talk>/* VTTTalk glyph 252, char 0x2d (-) */
/* GUI generated Fri Jun 23 03:47:28 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 252, char 0x2d (-) */
/* VTT 6.35 compiler Fri Jun 23 03:47:29 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 5, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="253">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xad */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 252, 0, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="254">
      <instructions>
        <talk>/* VTTTalk glyph 254, char 0x2013 */
/* GUI generated Fri Jun 23 03:47:35 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 254, char 0x2013 */
/* VTT 6.35 compiler Fri Jun 23 03:47:36 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 5, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="255">
      <instructions>
        <talk>/* VTTTalk glyph 255, char 0x2014 */
/* GUI generated Fri Jun 23 03:47:39 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 255, char 0x2014 */
/* VTT 6.35 compiler Fri Jun 23 03:47:41 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 5, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="256">
      <instructions>
        <talk>/* VTTTalk glyph 256, char 0x5f (_) */
/* GUI generated Fri Jun 23 03:47:44 2023 */

/* Y direction */
YAnchor(1)
ResYDist(1,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 256, char 0x5f (_) */
/* VTT 6.35 compiler Fri Jun 23 03:47:46 2023 */
SVTCA[Y]
MDAP[R], 1
CALL[], 1, 0, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="257">
      <instructions>
        <talk>/* VTTTalk glyph 257, char 0x28 (() */
/* GUI generated Fri Jun 23 03:47:54 2023 */

/* Y direction */
YAnchor(0)
YShift(0,14)
YAnchor(7)
YShift(7,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 257, char 0x28 (() */
/* VTT 6.35 compiler Fri Jun 23 03:47:54 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 14
MDAP[R], 7
SHP[1], 8
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="258">
      <instructions>
        <talk>/* VTTTalk glyph 258, char 0x29 ()) */
/* GUI generated Fri Jun 23 03:47:58 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YAnchor(8)
YShift(8,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 258, char 0x29 ()) */
/* VTT 6.35 compiler Fri Jun 23 03:47:58 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
MDAP[R], 8
SHP[1], 7
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="259">
      <instructions>
        <talk>/* VTTTalk glyph 259, char 0x7b ({) */
/* GUI generated Fri Jun 23 03:49:02 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,42)
YAnchor(22,2)
ResYDist(22,29)
YIPAnchor(0,8,22)
ResYDist(8,15)
YInterpolate(15,35,36,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 259, char 0x7b ({) */
/* VTT 6.35 compiler Fri Jun 23 03:49:02 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 42, 106
MIAP[R], 22, 2
CALL[], 22, 29, 106
SRP2[], 0
IP[], 8
MDAP[R], 8
CALL[], 8, 15, 106
IP[], 35
IP[], 36
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="260">
      <instructions>
        <talk>/* VTTTalk glyph 260, char 0x7d (}) */
/* GUI generated Fri Jun 23 03:49:40 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,6)
YAnchor(26,2)
ResYDist(26,19)
YIPAnchor(0,40,26)
ResYDist(40,33)
YInterpolate(40,12,13,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 260, char 0x7d (}) */
/* VTT 6.35 compiler Fri Jun 23 03:49:40 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 6, 106
MIAP[R], 26, 2
CALL[], 26, 19, 106
SRP2[], 0
IP[], 40
MDAP[R], 40
CALL[], 40, 33, 106
IP[], 12
IP[], 13
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="261">
      <instructions>
        <talk>/* VTTTalk glyph 261, char 0x5b ([) */
/* GUI generated Fri Jun 23 03:49:56 2023 */

/* Y direction */
YAnchor(6)
ResYDist(6,3)
ResYAnchor(13,2)
ResYDist(13,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 261, char 0x5b ([) */
/* VTT 6.35 compiler Fri Jun 23 03:49:56 2023 */
SVTCA[Y]
MDAP[R], 6
CALL[], 6, 3, 106
CALL[], 13, 2, 114
CALL[], 13, 16, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="262">
      <instructions>
        <talk>/* VTTTalk glyph 262, char 0x5d (]) */
/* GUI generated Fri Jun 23 03:50:02 2023 */

/* Y direction */
ResYAnchor(6,2)
ResYDist(6,5)
YAnchor(15)
ResYDist(15,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 262, char 0x5d (]) */
/* VTT 6.35 compiler Fri Jun 23 03:50:02 2023 */
SVTCA[Y]
CALL[], 6, 2, 114
CALL[], 6, 5, 106
MDAP[R], 15
CALL[], 15, 16, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="263">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x2e28 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 257, 498, 0
OFFSET[R], 257, -2, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="264">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x2e29 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 258, 498, 0
OFFSET[R], 258, -2, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="265">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x201a */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 270, 0, -1164
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="266">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x201e */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 270, 452, -1164
OFFSET[R], 270, 0, -1164
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="267">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x201c */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 269, 0, 0
OFFSET[R], 269, 447, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="268">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x201d */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 270, 0, 0
OFFSET[R], 270, 443, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="269">
      <instructions>
        <talk>/* VTTTalk glyph 269, char 0x2018 */
/* GUI generated Fri Jun 23 03:50:41 2023 */

/* Y direction */
YAnchor(14)
YShift(14,0)
YDist(14,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 269, char 0x2018 */
/* VTT 6.35 compiler Fri Jun 23 03:50:41 2023 */
SVTCA[Y]
MDAP[R], 14
SHP[1], 0
MDRP[m&gt;RBl], 7
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="270">
      <instructions>
        <talk>/* VTTTalk glyph 270, char 0x2019 */
/* GUI generated Fri Jun 23 03:51:12 2023 */

/* Y direction */
YAnchor(7,17)
YDist(7,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 270, char 0x2019 */
/* VTT 6.35 compiler Fri Jun 23 03:51:12 2023 */
SVTCA[Y]
MIAP[R], 7, 17
MDRP[m&gt;RBl], 14
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="271">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xab */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 273, 498, 0
OFFSET[R], 273, 0, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="272">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0xbb */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 274, 495, 0
OFFSET[R], 274, 0, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="273">
      <instructions>
        <talk>/* VTTTalk glyph 273, char 0x2039 */
/* GUI generated Fri Jun 23 03:51:32 2023 */

/* Y direction */
YAnchor(0)
YShift(0,5)
YAnchor(2)
YShift(2,3)
YInterpolate(0,1,4,2)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 273, char 0x2039 */
/* VTT 6.35 compiler Fri Jun 23 03:51:32 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 5
MDAP[R], 2
SHP[1], 3
IP[], 1
IP[], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="274">
      <instructions>
        <talk>/* VTTTalk glyph 274, char 0x203a */
/* GUI generated Fri Jun 23 03:52:00 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YAnchor(4)
YShift(4,3)
YInterpolate(0,2,5,4)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 274, char 0x203a */
/* VTT 6.35 compiler Fri Jun 23 03:52:00 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
MDAP[R], 4
SHP[1], 3
IP[], 2
IP[], 5
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="275">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x22 (") */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 276, 463, 0
OFFSET[R], 276, -4, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="276">
      <instructions>
        <talk>/* VTTTalk glyph 276, char 0x27 (') */
/* GUI generated Fri Jun 23 03:52:39 2023 */

/* Y direction */
YAnchor(6)
YDist(6,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 276, char 0x27 (') */
/* VTT 6.35 compiler Fri Jun 23 03:52:39 2023 */
SVTCA[Y]
MDAP[R], 6
MDRP[m&gt;RBl], 0
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="277">
      <instructions>
        <talk>/* VTTTalk glyph 277, char 0x192 */
/* GUI generated Fri Jun 23 03:53:40 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,16)
YAnchor(37,1)
ResYDist(37,56)
YIPAnchor(0,73,37)
YShift(73,19)
ResYDist(73,59)
YShift(59,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 277, char 0x192 */
/* VTT 6.35 compiler Fri Jun 23 03:53:40 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 16, 106
MIAP[R], 37, 1
CALL[], 37, 56, 106
SRP2[], 0
IP[], 73
MDAP[R], 73
SHP[1], 19
CALL[], 73, 59, 106
SHP[2], 33
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="278">
      <instructions>
        <talk>/* VTTTalk glyph 278, char 0x40 (@) */
/* GUI generated Fri Jun 23 03:54:43 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,55)
YAnchor(9)
YIPAnchor(55,24,9)
ResYDist(24,76)
YDist(24,17)
ResYDist(17,41)
ResYDist(9,48)
YIPAnchor(0,33,48)
ResYDist(33,83)
YInterpolate(24,20,33)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 278, char 0x40 (@) */
/* VTT 6.35 compiler Fri Jun 23 03:54:43 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 55, 106
MDAP[R], 9
IP[], 24
MDAP[R], 24
CALL[], 24, 76, 106
SRP0[], 24
MDRP[m&lt;RGr], 17
CALL[], 17, 41, 106
CALL[], 9, 48, 106
SRP1[], 0
IP[], 33
MDAP[R], 33
CALL[], 33, 83, 106
SRP2[], 24
IP[], 20
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="279">
      <instructions>
        <talk>/* VTTTalk glyph 279, char 0x26 (&amp;) */
/* GUI generated Fri Jun 23 03:55:39 2023 */

/* Y direction */
YAnchor(40,19)
ResYDist(40,25)
YAnchor(47,9)
ResYDist(47,85)
YAnchor(61,3)
YIPAnchor(47,12,61)
YInterpolate(47,44,88,22,2,12)
YInterpolate(85,73,61)
ResYDist(61,79)
YInterpolate(47,93,79)
YInterpolate(93,68,54,73)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 279, char 0x26 (&amp;) */
/* VTT 6.35 compiler Fri Jun 23 03:55:39 2023 */
SVTCA[Y]
MIAP[R], 40, 19
CALL[], 40, 25, 106
MIAP[R], 47, 9
CALL[], 47, 85, 106
MIAP[R], 61, 3
SRP2[], 47
IP[], 12
MDAP[R], 12
SLOOP[], 4
IP[], 44, 88, 22, 2
SRP1[], 85
SRP2[], 61
IP[], 73
CALL[], 61, 79, 106
SRP1[], 47
IP[], 93
SRP1[], 93
SRP2[], 73
IP[], 68
IP[], 54
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="280">
      <instructions>
        <talk>/* VTTTalk glyph 280, char 0xb6 */
/* GUI generated Fri Jun 23 03:56:09 2023 */

/* Y direction */
YAnchor(4,8)
YShift(4,46)
YAnchor(26,2)
ResYDist(26,8)
ResYDist(26,51)
YShift(51,41)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 280, char 0xb6 */
/* VTT 6.35 compiler Fri Jun 23 03:56:09 2023 */
SVTCA[Y]
MIAP[R], 4, 8
SHP[1], 46
MIAP[R], 26, 2
CALL[], 26, 8, 106
CALL[], 26, 51, 106
SHP[2], 41
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="281">
      <instructions>
        <talk>/* VTTTalk glyph 281, char 0xa7 */
/* GUI generated Fri Jun 23 03:56:55 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,25)
YAnchor(47,3)
ResYDist(47,69)
YInterpolate(0,32,96,69)
YInterpolate(25,18,32)
YShift(96,40)
YInterpolate(25,89,75,47)
YShift(89,83)
YInterpolate(69,63,75)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 281, char 0xa7 */
/* VTT 6.35 compiler Fri Jun 23 03:56:56 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 25, 106
MIAP[R], 47, 3
CALL[], 47, 69, 106
SRP1[], 0
IP[], 32
IP[], 96
SRP1[], 25
SRP2[], 32
IP[], 18
SRP1[], 96
SHP[1], 40
SRP1[], 25
SRP2[], 47
IP[], 89
IP[], 75
SRP1[], 89
SHP[1], 83
SRP1[], 69
SRP2[], 75
IP[], 63
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="282">
      <instructions>
        <talk>/* VTTTalk glyph 282, char 0xa9 */
/* GUI generated Fri Jun 23 03:57:36 2023 */

/* Y direction */
YAnchor(0,9)
ResYDist(0,16)
YAnchor(8,3)
ResYDist(8,24)
YIPAnchor(0,40,24)
ResYDist(40,55)
YIPAnchor(16,32,8)
ResYDist(32,61)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 282, char 0xa9 */
/* VTT 6.35 compiler Fri Jun 23 03:57:36 2023 */
SVTCA[Y]
MIAP[R], 0, 9
CALL[], 0, 16, 106
MIAP[R], 8, 3
CALL[], 8, 24, 106
SRP1[], 0
IP[], 40
MDAP[R], 40
CALL[], 40, 55, 106
SRP1[], 16
SRP2[], 8
IP[], 32
MDAP[R], 32
CALL[], 32, 61, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="283">
      <instructions>
        <talk>/* VTTTalk glyph 283, char 0xae */
/* GUI generated Fri Jun 23 03:59:16 2023 */

/* Y direction */
YAnchor(8)
YDist(8,0,&gt;=5)
ResYDist(0,16)
YIPAnchor(16,28,8)
YDist(28,48)
ResYDist(8,22)
YIPAnchor(0,33,22)
ResYDist(33,67)
YIPAnchor(28,54,33)
ResYDist(54,58)
YInterpolate(54,40,39,58)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 283, char 0xae */
/* VTT 6.35 compiler Fri Jun 23 03:59:16 2023 */
SVTCA[Y]
MDAP[R], 8
SMD[], 320
MDRP[m&gt;RGr], 0
CALL[], 0, 16, 106
SRP1[], 8
IP[], 28
MDAP[R], 28
MDRP[m&lt;RGr], 48
CALL[], 8, 22, 106
SRP1[], 0
IP[], 33
MDAP[R], 33
CALL[], 33, 67, 106
SRP2[], 28
IP[], 54
MDAP[R], 54
CALL[], 54, 58, 106
IP[], 40
IP[], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="284">
      <instructions>
        <talk>/* VTTTalk glyph 284, char 0x2122 */
/* GUI generated Fri Jun 23 04:00:05 2023 */

/* Y direction */
YAnchor(67,2)
YShift(67,11)
YShift(11,21)
YDist(67,49)
YShift(49,4)
YInterpolate(4,16,43,35,11)
YShift(4,40)
YShift(40,30)
ResYDist(67,53)
YShift(53,82)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 284, char 0x2122 */
/* VTT 6.35 compiler Fri Jun 23 04:00:05 2023 */
SVTCA[Y]
MIAP[R], 67, 2
SHP[1], 11
SRP1[], 11
SHP[1], 21
MDRP[m&lt;RGr], 49
SHP[2], 4
SRP1[], 4
SRP2[], 11
SLOOP[], 3
IP[], 16, 43, 35
SHP[1], 40
SRP1[], 40
SHP[1], 30
CALL[], 67, 53, 106
SHP[2], 82
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="285">
      <instructions>
        <talk>/* VTTTalk glyph 285, char 0xb0 */
/* GUI generated Fri Jun 23 04:00:25 2023 */

/* Y direction */
YAnchor(8)
ResYDist(8,22)
YDist(8,0)
ResYDist(0,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 285, char 0xb0 */
/* VTT 6.35 compiler Fri Jun 23 04:00:25 2023 */
SVTCA[Y]
MDAP[R], 8
CALL[], 8, 22, 106
SRP0[], 8
MDRP[m&lt;RGr], 0
CALL[], 0, 16, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="286">
      <instructions>
        <talk>/* VTTTalk Unicode 0x7c (|) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* Min and Max */
YAnchor(3)	/* min */
YAnchor(11)	/* max */

Smooth()
</talk>
        <assembly>
/* TT glyph 286, char 0x7c (|) */
/* VTT 6.35 compiler Fri Jun 23 01:02:18 2023 */
SVTCA[Y]
MDAP[R], 3
MDAP[R], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="287">
      <instructions>
        <talk>/* VTTTalk glyph 287, char 0xa6 */
/* GUI generated Fri Jun 23 04:00:39 2023 */

/* Y direction */
YAnchor(11)
YAnchor(19)
YIPAnchor(19,27,4,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 287, char 0xa6 */
/* VTT 6.35 compiler Fri Jun 23 04:00:39 2023 */
SVTCA[Y]
MDAP[R], 11
MDAP[R], 19
SRP2[], 11
IP[], 27
IP[], 4
MDAP[R], 27
MDAP[R], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="288">
      <instructions>
        <talk>/* VTTTalk glyph 288, char 0x2020 */
/* GUI generated Fri Jun 23 04:01:08 2023 */

/* Y direction */
YAnchor(16)
YAnchor(31,2)
YIPAnchor(16,19,31)
YShift(19,12)
ResYDist(19,28)
YShift(28,3)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 288, char 0x2020 */
/* VTT 6.35 compiler Fri Jun 23 04:01:08 2023 */
SVTCA[Y]
MDAP[R], 16
MIAP[R], 31, 2
SRP2[], 16
IP[], 19
MDAP[R], 19
SHP[1], 12
CALL[], 19, 28, 106
SHP[2], 3
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="289">
      <instructions>
        <talk>/* VTTTalk glyph 289, char 0x2021 */
/* GUI generated Fri Jun 23 04:01:48 2023 */

/* Y direction */
YAnchor(15,2)
YAnchor(47)
YIPAnchor(47,52,1,15)
YInterpolate(52,31,0,1)
YShift(52,41)
ResYDist(52,61)
YShift(61,32)
YShift(1,30)
ResYDist(1,10)
YShift(10,21)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 289, char 0x2021 */
/* VTT 6.35 compiler Fri Jun 23 04:01:48 2023 */
SVTCA[Y]
MIAP[R], 15, 2
MDAP[R], 47
SRP2[], 15
IP[], 52
IP[], 1
MDAP[R], 52
MDAP[R], 1
SRP2[], 52
IP[], 31
IP[], 0
SHP[2], 41
CALL[], 52, 61, 106
SHP[2], 32
SRP1[], 1
SHP[1], 30
CALL[], 1, 10, 106
SHP[2], 21
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="290">
      <instructions>
        <talk>/* VTTTalk glyph 290, char 0xa2 */
/* GUI generated Fri Jun 23 04:03:20 2023 */

/* Y direction */
YAnchor(0)
YAnchor(14)
YIPAnchor(0,3,11,14)
YShift(3,48)
ResYDist(3,52)
YShift(52,33)
YShift(11,18)
ResYDist(11,53)
YShift(53,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 290, char 0xa2 */
/* VTT 6.35 compiler Fri Jun 23 04:03:20 2023 */
SVTCA[Y]
MDAP[R], 0
MDAP[R], 14
IP[], 3
IP[], 11
MDAP[R], 3
MDAP[R], 11
SRP1[], 3
SHP[1], 48
CALL[], 3, 52, 106
SHP[2], 33
SRP1[], 11
SHP[1], 18
CALL[], 11, 53, 106
SHP[2], 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="291">
      <instructions>
        <talk>/* VTTTalk glyph 291, char 0xa4 */
/* GUI generated Fri Jun 23 04:04:46 2023 */

/* Y direction */
YAnchor(30)
ResYDist(30,65)
YDist(30,0)
ResYDist(0,59)
YInterpolate(0,2,57,13,46,17,42,28,32,30)
YDist(0,5)
YShift(5,10)
YShift(5,54)
YShift(54,49)
YDist(30,25)
YShift(25,20)
YShift(25,36)
YShift(36,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 291, char 0xa4 */
/* VTT 6.35 compiler Fri Jun 23 04:04:46 2023 */
SVTCA[Y]
MDAP[R], 30
CALL[], 30, 65, 106
SRP0[], 30
MDRP[m&lt;RGr], 0
CALL[], 0, 59, 106
SRP2[], 30
SLOOP[], 8
IP[], 2, 57, 13, 46, 17, 42, 28, 32
SRP0[], 0
MDRP[m&lt;RGr], 5
SHP[2], 10
SHP[2], 54
SRP1[], 54
SHP[1], 49
SRP0[], 30
MDRP[m&lt;RGr], 25
SHP[2], 20
SHP[2], 36
SRP1[], 36
SHP[1], 39
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="292">
      <instructions>
        <talk>/* VTTTalk glyph 292, char 0x24 ($) */
/* GUI generated Fri Jun 23 04:05:45 2023 */

/* Y direction */
YAnchor(3,8)
YDist(3,0,&gt;=)
YShift(3,78)
ResYDist(3,28)
YShift(28,92)
YAnchor(38,2)
YDist(38,41,&gt;=)
YShift(38,45)
YInterpolate(28,85,38)
YShift(85,68)
ResYDist(38,86)
YShift(86,67)
YInterpolate(3,29,86)
YShift(29,91)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 292, char 0x24 ($) */
/* VTT 6.35 compiler Fri Jun 23 04:05:52 2023 */
SVTCA[Y]
MIAP[R], 3, 8
MDRP[m&gt;RBl], 0
SHP[1], 78
CALL[], 3, 28, 106
SHP[2], 92
MIAP[R], 38, 2
MDRP[m&gt;RBl], 41
SHP[1], 45
SRP2[], 28
IP[], 85
SRP1[], 85
SHP[1], 68
CALL[], 38, 86, 106
SHP[2], 67
SRP1[], 3
IP[], 29
SRP1[], 29
SHP[1], 91
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="293">
      <instructions>
        <talk>/* VTTTalk glyph 293, char 0x20ac */
/* GUI generated Fri Jun 23 04:07:22 2023 */

/* Y direction */
YAnchor(0,13)
ResYDist(0,82)
YAnchor(26,5)
ResYDist(26,41)
YIPAnchor(0,58,26)
YDelta(58,1@12)
YShift(58,16)
ResYDist(58,44)
YShift(44,23)
YDist(58,64,&gt;=)
YDelta(64,2@8..9)
YShift(64,10)
ResYDist(64,80)
YShift(80,3)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 293, char 0x20ac */
/* VTT 6.35 compiler Fri Jun 23 04:07:22 2023 */
SVTCA[Y]
MIAP[R], 0, 13
CALL[], 0, 82, 106
MIAP[R], 26, 5
CALL[], 26, 41, 106
SRP2[], 0
IP[], 58
MDAP[R], 58
DLTP1[(58 @3 8)]
SHP[1], 16
CALL[], 58, 44, 106
SHP[2], 23
SRP0[], 58
MDRP[m&gt;RWh], 64
SDS[], 2
SDB[], 8
DLTP1[(64 @0 8)(64 @1 8)]
SHP[2], 10
CALL[], 64, 80, 106
SHP[2], 3
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="294">
      <instructions>
        <talk>/* VTTTalk glyph 294, char 0xa3 */
/* GUI generated Fri Jun 23 04:07:45 2023 */

/* Y direction */
ResYAnchor(0,12)
YShift(0,3)
ResYDist(0,58)
YShift(58,6)
ResYAnchor(23,5)
ResYDist(23,38)
YIPAnchor(23,55,0)
YShift(55,10)
ResYDist(55,41)
YShift(41,17)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 294, char 0xa3 */
/* VTT 6.35 compiler Fri Jun 23 04:07:45 2023 */
SVTCA[Y]
CALL[], 0, 12, 114
SHP[2], 3
CALL[], 0, 58, 106
SHP[2], 6
CALL[], 23, 5, 114
CALL[], 23, 38, 106
SRP2[], 0
IP[], 55
MDAP[R], 55
SHP[1], 10
CALL[], 55, 41, 106
SHP[2], 17
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="295">
      <instructions>
        <talk>/* VTTTalk glyph 295, char 0xa5 */
/* GUI generated Fri Jun 23 04:10:33 2023 */

/* Y direction */
YAnchor(11,8)
YAnchor(41)
YShift(41,65)
YIPAnchor(11,16,24,41)
YDelta(16,1@12..13;21)
YShift(16,6)
ResYDist(16,21)
YShift(21,85)
YShift(24,84)
ResYDist(24,29)
YShift(29,53)
YShift(29,77)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 295, char 0xa5 */
/* VTT 6.35 compiler Fri Jun 23 04:10:33 2023 */
SVTCA[Y]
MIAP[R], 11, 8
MDAP[R], 41
SHP[1], 65
SRP2[], 11
IP[], 16
IP[], 24
MDAP[R], 16
MDAP[R], 24
DLTP1[(16 @3 8)(16 @4 8)(16 @12 8)]
SRP1[], 16
SHP[1], 6
CALL[], 16, 21, 106
SHP[2], 85
SRP1[], 24
SHP[1], 84
CALL[], 24, 29, 106
SHP[2], 53
SHP[2], 77
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="296">
      <instructions>
        <talk>/* VTTTalk Unicode 0x2b (+) */
/* ACT generated Fri Jun 23 01:02:17 2023 */

/* Auto-Hinting Light */

/* ***Settings*** */
/* ModeHinting = LightLatin */
/* ToAnchorBottom = true */


/* Min and Max */
YAnchor(0)	/* min */
YAnchor(5)	/* max */

/* YDir: Stroke #0 */
YInterpolate(5,2,0)
YAnchor(2)
ResYDist(2,3) /*perpendicular to the stroke*/
YShift(2,10) /*along bottom edge*/
YShift(3,7) /*along top edge*/

Smooth()

</talk>
        <assembly>
/* TT glyph 296, char 0x2b (+) */
/* VTT 6.35 compiler Fri Jun 23 01:02:18 2023 */
SVTCA[Y]
MDAP[R], 0
MDAP[R], 5
IP[], 2
MDAP[R], 2
CALL[], 2, 3, 106
SHP[1], 10
SHP[2], 7
IUP[Y]
IUP[X]</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="297">
      <instructions>
        <talk>/* VTTTalk glyph 297, char 0x2212 */
/* GUI generated Fri Jun 23 04:10:58 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,1)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 297, char 0x2212 */
/* VTT 6.35 compiler Fri Jun 23 04:11:02 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 1, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="298">
      <instructions>
        <talk>/* VTTTalk glyph 298, char 0xd7 */
/* GUI generated Fri Jun 23 04:11:30 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YShift(0,10)
YShift(10,9)
YAnchor(4)
YShift(4,3)
YInterpolate(0,11,8,2,5,4)
YShift(4,6)
YShift(6,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 298, char 0xd7 */
/* VTT 6.35 compiler Fri Jun 23 04:11:30 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
SHP[2], 10
SRP1[], 10
SHP[1], 9
MDAP[R], 4
SHP[1], 3
SLOOP[], 4
IP[], 11, 8, 2, 5
SHP[1], 6
SRP1[], 6
SHP[1], 7
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="299">
      <instructions>
        <talk>/* VTTTalk glyph 299, char 0xf7 */
/* GUI generated Fri Jun 23 04:11:51 2023 */

/* Y direction */
YAnchor(12)
ResYDist(12,13)
YDist(13,0)
ResYDist(0,6)
YDist(12,22)
ResYDist(22,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 299, char 0xf7 */
/* VTT 6.35 compiler Fri Jun 23 04:11:51 2023 */
SVTCA[Y]
MDAP[R], 12
CALL[], 12, 13, 106
MDRP[m&lt;RWh], 0
CALL[], 0, 6, 106
SRP0[], 12
MDRP[m&lt;RWh], 22
CALL[], 22, 16, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="300">
      <instructions>
        <talk>/* VTTTalk glyph 300, char 0x3d (=) */
/* GUI generated Fri Jun 23 15:53:38 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,1)
YDist(0,5,&gt;=)
ResYDist(5,4)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 300, char 0x3d (=) */
/* VTT 6.35 compiler Fri Jun 23 15:53:38 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 1, 106
SRP0[], 0
MDRP[m&gt;RWh], 5
CALL[], 5, 4, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="301">
      <instructions>
        <talk>/* VTTTalk glyph 301, char 0x2260 */
/* GUI generated Fri Jun 23 15:56:06 2023 */

/* Y direction */
YAnchor(0,8)
YAnchor(7)
YShift(7,11)
ResYDist(7,6)
YShift(6,14)
YDist(7,9,&gt;=)
YIPAnchor(0,2,9)
YShift(2,18)
ResYDist(2,3)
YShift(3,15)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 301, char 0x2260 */
/* VTT 6.35 compiler Fri Jun 23 15:56:06 2023 */
SVTCA[Y]
MIAP[R], 0, 8
MDAP[R], 7
SHP[1], 11
CALL[], 7, 6, 106
SHP[2], 14
SRP0[], 7
MDRP[m&gt;RWh], 9
SRP1[], 0
IP[], 2
MDAP[R], 2
SHP[1], 18
CALL[], 2, 3, 106
SHP[2], 15
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="302">
      <instructions>
        <talk>/* VTTTalk glyph 302, char 0x3e (&gt;) */
/* GUI generated Fri Jun 23 15:56:36 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,1)
YDist(0,5)
ResYDist(5,4)
YInterpolate(0,7,2,3,6,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 302, char 0x3e (&gt;) */
/* VTT 6.35 compiler Fri Jun 23 15:56:36 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 1, 106
SRP0[], 0
MDRP[m&lt;RWh], 5
CALL[], 5, 4, 106
SRP2[], 0
SLOOP[], 4
IP[], 7, 2, 3, 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="303">
      <instructions>
        <talk>/* VTTTalk glyph 303, char 0x3c (&lt;) */
/* GUI generated Fri Jun 23 15:57:00 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,7)
YDist(0,3)
ResYDist(3,4)
YInterpolate(0,1,6,5,2,3)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 303, char 0x3c (&lt;) */
/* VTT 6.35 compiler Fri Jun 23 15:57:00 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 7, 106
SRP0[], 0
MDRP[m&lt;RWh], 3
CALL[], 3, 4, 106
SRP2[], 0
SLOOP[], 4
IP[], 1, 6, 5, 2
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="304">
      <instructions>
        <talk>/* VTTTalk glyph 304, char 0x2265 */
/* GUI generated Fri Jun 23 15:57:56 2023 */

/* Y direction */
YAnchor(5)
ResYDist(5,4)
YDist(5,0)
ResYDist(0,1)
YInterpolate(0,7,2,3,6,5)
YAnchor(8,8)
ResYDist(8,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 304, char 0x2265 */
/* VTT 6.35 compiler Fri Jun 23 15:57:56 2023 */
SVTCA[Y]
MDAP[R], 5
CALL[], 5, 4, 106
SRP0[], 5
MDRP[m&lt;RWh], 0
CALL[], 0, 1, 106
SRP2[], 5
SLOOP[], 4
IP[], 7, 2, 3, 6
MIAP[R], 8, 8
CALL[], 8, 9, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="305">
      <instructions>
        <talk>/* VTTTalk glyph 305, char 0x2264 */
/* GUI generated Fri Jun 23 15:58:37 2023 */

/* Y direction */
YAnchor(3)
ResYDist(3,4)
YDist(3,0)
ResYDist(0,7)
YInterpolate(0,1,6,5,2,3)
YAnchor(9,8)
ResYDist(9,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 305, char 0x2264 */
/* VTT 6.35 compiler Fri Jun 23 15:58:37 2023 */
SVTCA[Y]
MDAP[R], 3
CALL[], 3, 4, 106
SRP0[], 3
MDRP[m&lt;RWh], 0
CALL[], 0, 7, 106
SRP2[], 3
SLOOP[], 4
IP[], 1, 6, 5, 2
MIAP[R], 9, 8
CALL[], 9, 10, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="306">
      <instructions>
        <talk>/* VTTTalk glyph 306, char 0xb1 */
/* GUI generated Fri Jun 23 15:59:24 2023 */

/* Y direction */
YAnchor(2)
YDist(2,0)
YShift(2,10)
ResYDist(2,3)
YDist(3,5)
YShift(3,7)
YAnchor(12,8)
ResYDist(12,13)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 306, char 0xb1 */
/* VTT 6.35 compiler Fri Jun 23 15:59:24 2023 */
SVTCA[Y]
MDAP[R], 2
MDRP[m&lt;RWh], 0
SHP[1], 10
CALL[], 2, 3, 106
MDRP[m&lt;RWh], 5
SHP[1], 7
MIAP[R], 12, 8
CALL[], 12, 13, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="307">
      <instructions>
        <talk>/* VTTTalk glyph 307, char 0x2248 */
/* GUI generated Fri Jun 23 16:01:21 2023 */

/* Y direction */
YAnchor(43)
ResYDist(43,36)
YDist(43,51)
YDist(43,30,&gt;=2)
YDist(30,39)
ResYDist(30,49)
YDist(30,17,&gt;=)
ResYDist(17,10)
YDist(17,25)
YDist(17,4,&gt;=2)
YDist(4,13)
ResYDist(4,23)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 307, char 0x2248 */
/* VTT 6.35 compiler Fri Jun 23 16:01:21 2023 */
SVTCA[Y]
MDAP[R], 43
CALL[], 43, 36, 106
SRP0[], 43
MDRP[m&lt;RWh], 51
SMD[], 128
MDRP[M&gt;RBl], 30
MDRP[m&lt;RWh], 39
CALL[], 30, 49, 106
SMD[], 64
SRP0[], 30
MDRP[m&gt;RWh], 17
CALL[], 17, 10, 106
SRP0[], 17
MDRP[m&lt;RWh], 25
SMD[], 128
MDRP[M&gt;RBl], 4
MDRP[m&lt;RWh], 13
CALL[], 4, 23, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="308">
      <instructions>
        <talk>/* VTTTalk glyph 308, char 0x7e (~) */
/* GUI generated Fri Jun 23 16:01:51 2023 */

/* Y direction */
YAnchor(16)
ResYDist(16,8)
YDist(16,22)
YDist(16,4,&gt;=2)
YDist(4,11)
ResYDist(4,20)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 308, char 0x7e (~) */
/* VTT 6.35 compiler Fri Jun 23 16:01:51 2023 */
SVTCA[Y]
MDAP[R], 16
CALL[], 16, 8, 106
SRP0[], 16
MDRP[m&lt;RWh], 22
SMD[], 128
MDRP[M&gt;RBl], 4
MDRP[m&lt;RWh], 11
CALL[], 4, 20, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="309">
      <instructions>
        <talk>/* VTTTalk glyph 309, char 0xac */
/* GUI generated Fri Jun 23 16:02:08 2023 */

/* Y direction */
YAnchor(2)
YDist(2,0)
ResYDist(2,3)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 309, char 0xac */
/* VTT 6.35 compiler Fri Jun 23 16:02:08 2023 */
SVTCA[Y]
MDAP[R], 2
MDRP[m&lt;RWh], 0
CALL[], 2, 3, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="310">
      <instructions>
        <talk>/* VTTTalk glyph 310, char 0x5e (^) */
/* GUI generated Fri Jun 23 16:02:36 2023 */

/* Y direction */
ResYAnchor(1,3)
YIPAnchor(8,0,1)
YInterpolate(0,5,1)
YShift(0,4)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 310, char 0x5e (^) */
/* VTT 6.35 compiler Fri Jun 23 16:02:36 2023 */
SVTCA[Y]
CALL[], 1, 3, 114
SRP2[], 8
IP[], 0
MDAP[R], 0
SRP2[], 1
IP[], 5
SHP[1], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="311">
      <instructions>
        <talk>/* VTTTalk glyph 311, char 0x221e */
/* GUI generated Fri Jun 23 16:03:15 2023 */

/* Y direction */
YAnchor(6)
YShift(6,0)
YDist(6,12)
YShift(12,18)
YInterpolate(6,3,45,27,15,12)
ResYDist(12,30)
YShift(30,42)
ResYDist(6,24)
YShift(24,36)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 311, char 0x221e */
/* VTT 6.35 compiler Fri Jun 23 16:03:15 2023 */
SVTCA[Y]
MDAP[R], 6
SHP[1], 0
MDRP[m&lt;RGr], 12
SHP[2], 18
SLOOP[], 4
IP[], 3, 45, 27, 15
CALL[], 12, 30, 106
SHP[2], 42
CALL[], 6, 24, 106
SHP[2], 36
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="312">
      <instructions>
        <talk>/* VTTTalk glyph 312, char 0xb5 */
/* GUI generated Fri Jun 23 16:04:29 2023 */

/* Y direction */
YAnchor(9)
YAnchor(21,7)
YShift(21,41)
YAnchor(61,11)
ResYDist(61,31)
YInterpolate(61,0,64,57,56,21)
YDist(61,53)
YShift(53,52)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 312, char 0xb5 */
/* VTT 6.35 compiler Fri Jun 23 16:04:29 2023 */
SVTCA[Y]
MDAP[R], 9
MIAP[R], 21, 7
SHP[1], 41
MIAP[R], 61, 11
CALL[], 61, 31, 106
SRP2[], 21
SLOOP[], 4
IP[], 0, 64, 57, 56
SRP0[], 61
MDRP[m&lt;RWh], 53
SHP[2], 52
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="313">
      <instructions>
        <talk>/* VTTTalk glyph 313, char 0x25 (%) */
/* GUI generated Fri Jun 23 16:05:13 2023 */

/* Y direction */
YAnchor(32,3)
YDist(32,18)
ResYDist(32,42)
YDist(32,26)
ResYDist(26,38)
YAnchor(46,9)
YDist(46,5)
ResYDist(46,58)
YDist(46,52)
ResYDist(52,62)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 313, char 0x25 (%) */
/* VTT 6.35 compiler Fri Jun 23 16:05:13 2023 */
SVTCA[Y]
MIAP[R], 32, 3
MDRP[m&lt;RGr], 18
CALL[], 32, 42, 106
SRP0[], 32
MDRP[m&lt;RGr], 26
CALL[], 26, 38, 106
MIAP[R], 46, 9
MDRP[m&lt;RGr], 5
CALL[], 46, 58, 106
SRP0[], 46
MDRP[m&lt;RGr], 52
CALL[], 52, 62, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="314">
      <instructions>
        <talk>/* VTTTalk glyph 314, char 0x2030 */
/* GUI generated Fri Jun 23 16:06:00 2023 */

/* Y direction */
YAnchor(32,3)
YDist(32,18)
ResYDist(32,42)
YDist(32,26)
ResYDist(26,38)
YAnchor(46,9)
YDist(46,5)
YShift(46,58)
YDist(46,52)
YShift(52,64)
ResYDist(52,74)
YShift(74,82)
ResYDist(46,70)
YShift(70,78)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 314, char 0x2030 */
/* VTT 6.35 compiler Fri Jun 23 16:06:00 2023 */
SVTCA[Y]
MIAP[R], 32, 3
MDRP[m&lt;RGr], 18
CALL[], 32, 42, 106
SRP0[], 32
MDRP[m&lt;RGr], 26
CALL[], 26, 38, 106
MIAP[R], 46, 9
MDRP[m&lt;RGr], 5
SHP[1], 58
MDRP[m&lt;RGr], 52
SHP[2], 64
CALL[], 52, 74, 106
SHP[2], 82
CALL[], 46, 70, 106
SHP[2], 78
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="315">
      <instructions>
        <talk>/* VTTTalk glyph 315, char 0xffff */
/* GUI generated Fri Jun 23 16:07:00 2023 */

/* Y direction */
YAnchor(60,3)
YDist(60,7)
YDist(60,26)
ResYDist(26,33)
ResYDist(60,39)
YInterpolate(33,29,30,49,39)
YAnchor(67,9)
YDist(67,20)
ResYDist(67,74)
YDist(67,101)
ResYDist(101,80)
YInterpolate(74,70,71,90,80)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 315, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:07:00 2023 */
SVTCA[Y]
MIAP[R], 60, 3
MDRP[m&lt;RGr], 7
MDRP[m&lt;RGr], 26
CALL[], 26, 33, 106
CALL[], 60, 39, 106
SRP1[], 33
SLOOP[], 3
IP[], 29, 30, 49
MIAP[R], 67, 9
MDRP[m&lt;RGr], 20
CALL[], 67, 74, 106
SRP0[], 67
MDRP[m&lt;RGr], 101
CALL[], 101, 80, 106
SRP1[], 74
SLOOP[], 3
IP[], 70, 71, 90
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="316">
      <instructions>
        <talk>/* VTTTalk glyph 316, char 0xffff */
/* GUI generated Fri Jun 23 16:08:27 2023 */

/* Y direction */
YAnchor(60,3)
YDist(60,7)
YDist(60,26)
ResYDist(26,33)
ResYDist(60,39)
YInterpolate(33,29,30,49,39)
YAnchor(67,9)
YDist(67,20)
YShift(67,108)
ResYDist(67,74)
YShift(74,115)
YDist(67,101)
YShift(101,142)
ResYDist(101,80)
YInterpolate(74,70,71,90,80)
YShift(80,121)
YInterpolate(115,111,112,131,121)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 316, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:08:27 2023 */
SVTCA[Y]
MIAP[R], 60, 3
MDRP[m&lt;RGr], 7
MDRP[m&lt;RGr], 26
CALL[], 26, 33, 106
CALL[], 60, 39, 106
SRP1[], 33
SLOOP[], 3
IP[], 29, 30, 49
MIAP[R], 67, 9
MDRP[m&lt;RGr], 20
SHP[1], 108
CALL[], 67, 74, 106
SHP[2], 115
SRP0[], 67
MDRP[m&lt;RGr], 101
SHP[2], 142
CALL[], 101, 80, 106
SRP1[], 74
SLOOP[], 3
IP[], 70, 71, 90
SHP[2], 121
SRP1[], 115
SRP2[], 121
SLOOP[], 3
IP[], 111, 112, 131
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="317">
      <instructions>
        <talk>/* VTTTalk glyph 317, char 0x1e944 */
/* GUI generated Fri Jun 23 16:09:08 2023 */

/* Y direction */
YAnchor(7)
ResYDist(7,5)
YDist(7,0,&gt;=2)
YInterpolate(0,15,12,11,7)
YShift(7,13)
YShift(13,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 317, char 0x1e944 */
/* VTT 6.35 compiler Fri Jun 23 16:09:08 2023 */
SVTCA[Y]
MDAP[R], 7
CALL[], 7, 5, 106
SMD[], 128
SRP0[], 7
MDRP[m&gt;RGr], 0
SLOOP[], 3
IP[], 15, 12, 11
SHP[1], 13
SRP1[], 13
SHP[1], 14
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="318">
      <instructions>
        <talk>/* VTTTalk glyph 318, char 0x1e945 */
/* GUI generated Fri Jun 23 16:09:37 2023 */

/* Y direction */
YAnchor(10)
ResYDist(10,14)
YDist(10,4,&gt;=3)
ResYDist(4,18)
YShift(4,0)
YShift(0,23)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 318, char 0x1e945 */
/* VTT 6.35 compiler Fri Jun 23 16:09:37 2023 */
SVTCA[Y]
MDAP[R], 10
CALL[], 10, 14, 106
SMD[], 192
SRP0[], 10
MDRP[m&gt;RGr], 4
CALL[], 4, 18, 106
SHP[1], 0
SRP1[], 0
SHP[1], 23
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="319">
      <instructions>
        <talk>/* VTTTalk glyph 319, char 0x1e946 */
/* GUI generated Fri Jun 23 16:16:05 2023 */

/* Y direction */
YAnchor(8)
ResYDist(8,15)
YShift(15,3)
YShift(3,4)
YShift(15,12)
YShift(12,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 319, char 0x1e946 */
/* VTT 6.35 compiler Fri Jun 23 16:16:05 2023 */
SVTCA[Y]
MDAP[R], 8
CALL[], 8, 15, 106
SHP[2], 3
SRP1[], 3
SHP[1], 4
SHP[2], 12
SRP1[], 12
SHP[1], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="320">
      <instructions>
        <talk>/* VTTTalk glyph 320, char 0x1e947 */
/* GUI generated Fri Jun 23 16:10:33 2023 */

/* Y direction */
YAnchor(23)
YDist(23,0,&gt;=3)
ResYDist(0,20)
YIPAnchor(0,7,23)
ResYDist(7,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 320, char 0x1e947 */
/* VTT 6.35 compiler Fri Jun 23 16:10:33 2023 */
SVTCA[Y]
MDAP[R], 23
SMD[], 192
MDRP[m&gt;RGr], 0
CALL[], 0, 20, 106
SRP2[], 23
IP[], 7
MDAP[R], 7
CALL[], 7, 14, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="321">
      <instructions>
        <talk>/* VTTTalk glyph 321, char 0x1e948 */
/* GUI generated Fri Jun 23 16:11:46 2023 */

/* Y direction */
YAnchor(0)
YDist(0,2,&gt;=2)
YShift(2,1)
YInterpolate(0,3,2)
YShift(2,5)
YShift(5,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 321, char 0x1e948 */
/* VTT 6.35 compiler Fri Jun 23 16:11:46 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 2
SHP[2], 1
IP[], 3
SHP[2], 5
SRP1[], 5
SHP[1], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="322">
      <instructions>
        <talk>/* VTTTalk glyph 322, char 0x1e949 */
/* GUI generated Fri Jun 23 16:14:47 2023 */

/* Y direction */
YAnchor(0)
YShift(0,8)
YDist(0,2,&gt;=2)
YShift(2,1)
YInterpolate(0,3,2)
YShift(2,5)
YShift(5,6)
YIPAnchor(0,9,5)
YShift(9,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 322, char 0x1e949 */
/* VTT 6.35 compiler Fri Jun 23 16:14:47 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 8
SMD[], 128
MDRP[m&gt;RBl], 2
SHP[2], 1
IP[], 3
SHP[2], 5
SRP1[], 5
SHP[1], 6
SRP2[], 0
IP[], 9
MDAP[R], 9
SHP[1], 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="323">
      <instructions>
        <talk>/* VTTTalk glyph 323, char 0x1e94a */
/* GUI generated Fri Jun 23 16:12:54 2023 */

/* Y direction */
YAnchor(26)
ResYDist(26,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 323, char 0x1e94a */
/* VTT 6.35 compiler Fri Jun 23 16:12:56 2023 */
SVTCA[Y]
MDAP[R], 26
CALL[], 26, 9, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="324">
      <instructions>
        <talk>/* VTTTalk glyph 324, char 0xffff */
/* GUI generated Fri Jun 23 16:13:02 2023 */

/* Y direction */
YAnchor(26)
ResYDist(26,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 324, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:13:04 2023 */
SVTCA[Y]
MDAP[R], 26
CALL[], 26, 9, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="325">
      <instructions>
        <talk>/* VTTTalk glyph 325, char 0xffff */
/* GUI generated Fri Jun 23 16:13:15 2023 */

/* Y direction */
YAnchor(0)
YDist(0,5)
YInterpolate(0,9,4,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 325, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:13:15 2023 */
SVTCA[Y]
MDAP[R], 0
MDRP[m&gt;RBl], 5
IP[], 9
IP[], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="326">
      <instructions>
        <talk>/* VTTTalk glyph 326, char 0xffff */
/* GUI generated Fri Jun 23 16:13:29 2023 */

/* Y direction */
YAnchor(0)
YDist(0,5)
YInterpolate(0,1,6,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 326, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:13:29 2023 */
SVTCA[Y]
MDAP[R], 0
MDRP[m&gt;RBl], 5
IP[], 1
IP[], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="327">
      <instructions>
        <talk>/* VTTTalk glyph 327, char 0xffff */
/* GUI generated Fri Jun 23 16:16:24 2023 */

/* Y direction */
YAnchor(8)
ResYDist(8,15)
YShift(15,3)
YShift(3,4)
YShift(15,12)
YShift(12,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 327, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:16:24 2023 */
SVTCA[Y]
MDAP[R], 8
CALL[], 8, 15, 106
SHP[2], 3
SRP1[], 3
SHP[1], 4
SHP[2], 12
SRP1[], 12
SHP[1], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="328">
      <instructions>
        <talk>/* VTTTalk glyph 328, char 0xffff */
/* GUI generated Fri Jun 23 16:14:05 2023 */

/* Y direction */
YAnchor(0)
YDist(0,2,&gt;=2)
YShift(2,1)
YInterpolate(0,3,2)
YShift(2,5)
YShift(5,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 328, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:14:05 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 2
SHP[2], 1
IP[], 3
SHP[2], 5
SRP1[], 5
SHP[1], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="329">
      <instructions>
        <talk>/* VTTTalk glyph 329, char 0xffff */
/* GUI generated Fri Jun 23 16:14:43 2023 */

/* Y direction */
YAnchor(0)
YShift(0,8)
YDist(0,2,&gt;=2)
YShift(2,1)
YInterpolate(0,3,2)
YShift(2,5)
YShift(5,6)
YIPAnchor(0,9,5)
YShift(9,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 329, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:14:43 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 8
SMD[], 128
MDRP[m&gt;RBl], 2
SHP[2], 1
IP[], 3
SHP[2], 5
SRP1[], 5
SHP[1], 6
SRP2[], 0
IP[], 9
MDAP[R], 9
SHP[1], 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="330">
      <instructions>
        <talk>/* VTTTalk glyph 330, char 0xffff */
/* GUI generated Fri Jun 23 16:15:48 2023 */

/* Y direction */
YAnchor(8)
ResYDist(8,15)
YShift(15,3)
YShift(3,4)
YShift(15,12)
YShift(12,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 330, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:15:48 2023 */
SVTCA[Y]
MDAP[R], 8
CALL[], 8, 15, 106
SHP[2], 3
SRP1[], 3
SHP[1], 4
SHP[2], 12
SRP1[], 12
SHP[1], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="331">
      <instructions>
        <talk>/* VTTTalk glyph 331, char 0xffff */
/* GUI generated Fri Jun 23 16:15:29 2023 */

/* Y direction */
YAnchor(8)
ResYDist(8,15)
YShift(15,3)
YShift(3,4)
YShift(15,12)
YShift(12,11)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 331, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:15:29 2023 */
SVTCA[Y]
MDAP[R], 8
CALL[], 8, 15, 106
SHP[2], 3
SRP1[], 3
SHP[1], 4
SHP[2], 12
SRP1[], 12
SHP[1], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="332">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x308 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 365, -858, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="333">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x307 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 366, -458, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="334">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x300 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 367, -726, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="335">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x301 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 368, -738, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="336">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x30b */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 369, -1064, 0
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="337">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x302 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 370, -784, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="338">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x30c */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 371, -819, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="339">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x306 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 372, -816, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="340">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x30a */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 373, -622, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="341">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x303 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 374, -817, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="342">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x304 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 375, -800, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="343">
      <instructions>
        <talk>/* VTTTalk glyph 343, char 0x323 */
/* GUI generated Fri Jun 23 16:16:45 2023 */

/* Y direction */
YAnchor(6)
ResYDist(6,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 343, char 0x323 */
/* VTT 6.35 compiler Fri Jun 23 16:16:46 2023 */
SVTCA[Y]
MDAP[R], 6
CALL[], 6, 0, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="344">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x327 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 376, -493, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="345">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x328 */
/* ACT generated Fri Jun 23 01:02:17 2023 */

OFFSET[R], 377, -542, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="346">
      <instructions>
        <talk>/* VTTTalk glyph 346, char 0x331 */
/* GUI generated Fri Jun 23 16:16:54 2023 */

/* Y direction */
YAnchor(7)
ResYDist(7,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 346, char 0x331 */
/* VTT 6.35 compiler Fri Jun 23 16:16:55 2023 */
SVTCA[Y]
MDAP[R], 7
CALL[], 7, 0, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="347">
      <instructions>
        <talk>/* VTTTalk glyph 347, char 0x335 */
/* GUI generated Fri Jun 23 16:17:01 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 347, char 0x335 */
/* VTT 6.35 compiler Fri Jun 23 16:17:03 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 8, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="348">
      <instructions>
        <talk>/* VTTTalk glyph 348, char 0x336 */
/* GUI generated Fri Jun 23 16:17:10 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,8)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 348, char 0x336 */
/* VTT 6.35 compiler Fri Jun 23 16:17:11 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 8, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="349">
      <instructions>
        <talk>/* VTTTalk glyph 349, char 0x338 */
/* GUI generated Fri Jun 23 16:17:18 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YAnchor(2)
YShift(2,3)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 349, char 0x338 */
/* VTT 6.35 compiler Fri Jun 23 16:17:18 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
MDAP[R], 2
SHP[1], 3
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="350">
      <instructions>
        <talk>/* VTTTalk glyph 350, char 0xffff */
/* GUI generated Fri Jun 23 16:17:36 2023 */

/* Y direction */
YAnchor(12)
YShift(12,0)
ResYDist(12,18)
YShift(18,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 350, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:17:36 2023 */
SVTCA[Y]
MDAP[R], 12
SHP[1], 0
CALL[], 12, 18, 106
SHP[2], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="351">
      <instructions>
        <talk>/* VTTTalk glyph 351, char 0xffff */
/* GUI generated Fri Jun 23 16:17:43 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 351, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:17:44 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 6, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="352">
      <instructions>
        <talk>/* VTTTalk glyph 352, char 0xffff */
/* GUI generated Fri Jun 23 16:18:29 2023 */

/* Y direction */
YAnchor(0)
YDist(0,6,&gt;=2)
YInterpolate(0,10,5,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 352, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:18:29 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 6
IP[], 10
IP[], 5
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="353">
      <instructions>
        <talk>/* VTTTalk glyph 353, char 0xffff */
/* GUI generated Fri Jun 23 16:18:51 2023 */

/* Y direction */
YAnchor(0)
YDist(0,5,&gt;=2)
YInterpolate(5,6,1,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 353, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:18:51 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 5
IP[], 6
IP[], 1
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="354">
      <instructions>
        <talk>/* VTTTalk glyph 354, char 0xffff */
/* GUI generated Fri Jun 23 16:19:05 2023 */

/* Y direction */
YAnchor(4)
YShift(4,0)
YDist(4,6,&gt;=2)
YShift(6,2)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 354, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:19:05 2023 */
SVTCA[Y]
MDAP[R], 4
SHP[1], 0
SMD[], 128
MDRP[m&gt;RBl], 6
SHP[2], 2
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="355">
      <instructions>
        <talk>/* VTTTalk glyph 355, char 0xffff */
/* GUI generated Fri Jun 23 16:19:26 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YDist(0,5,&gt;=2)
YInterpolate(0,11,5)
YShift(0,10)
YShift(10,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 355, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:19:26 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
SMD[], 128
MDRP[m&gt;RBl], 5
IP[], 11
SHP[1], 10
SRP1[], 10
SHP[1], 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="356">
      <instructions>
        <talk>/* VTTTalk glyph 356, char 0xffff */
/* GUI generated Fri Jun 23 16:19:47 2023 */

/* Y direction */
YAnchor(5)
YDist(5,10,&gt;=2)
YShift(10,9)
YShift(10,0)
YShift(0,1)
YInterpolate(5,11,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 356, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:19:47 2023 */
SVTCA[Y]
MDAP[R], 5
SMD[], 128
MDRP[m&gt;RBl], 10
SHP[2], 9
SHP[2], 0
SRP1[], 0
SHP[1], 1
SRP1[], 5
IP[], 11
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="357">
      <instructions>
        <talk>/* VTTTalk glyph 357, char 0xffff */
/* GUI generated Fri Jun 23 16:20:16 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,7)
YDist(0,3,&gt;=2)
YShift(3,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 357, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:20:16 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 7, 106
SMD[], 128
SRP0[], 0
MDRP[m&gt;RBl], 3
SHP[2], 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="358">
      <instructions>
        <talk>/* VTTTalk glyph 358, char 0xffff */
/* GUI generated Fri Jun 23 16:20:28 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,12)
YDist(0,6,&gt;=3)
ResYDist(6,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 358, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:20:32 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 12, 106
SMD[], 192
SRP0[], 0
MDRP[m&gt;RGr], 6
CALL[], 6, 18, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="359">
      <instructions>
        <talk>/* VTTTalk glyph 359, char 0xffff */
/* GUI generated Fri Jun 23 16:20:54 2023 */

/* Y direction */
YAnchor(0)
YDist(0,9)
ResYDist(0,18)
YDist(0,12,&gt;=2)
ResYDist(12,6)
YDist(12,20)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 359, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:20:54 2023 */
SVTCA[Y]
MDAP[R], 0
MDRP[m&lt;RGr], 9
CALL[], 0, 18, 106
SMD[], 128
SRP0[], 0
MDRP[m&gt;RBl], 12
CALL[], 12, 6, 106
SRP0[], 12
MDRP[m&lt;RGr], 20
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="360">
      <instructions>
        <talk>/* VTTTalk glyph 360, char 0xffff */
/* GUI generated Fri Jun 23 16:21:04 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 360, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:21:05 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 7, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="361">
      <instructions>
        <talk>/* VTTTalk glyph 361, char 0xffff */
/* GUI generated Fri Jun 23 16:21:09 2023 */

/* Y direction */
YAnchor(6)
ResYDist(6,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 361, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:21:11 2023 */
SVTCA[Y]
MDAP[R], 6
CALL[], 6, 0, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="362">
      <instructions>
        <talk>/* VTTTalk glyph 362, char 0xffff */
/* GUI generated Fri Jun 23 16:22:35 2023 */

/* Y direction */
YAnchor(14)
YDist(14,0,&gt;=3)
ResYDist(0,6)
YInterpolate(6,16,14)
YInterpolate(0,13,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 362, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:22:35 2023 */
SVTCA[Y]
MDAP[R], 14
SMD[], 192
MDRP[m&gt;RGr], 0
CALL[], 0, 6, 106
SRP1[], 14
IP[], 16
SRP2[], 0
IP[], 13
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="363">
      <instructions>
        <talk>/* VTTTalk glyph 363, char 0xffff */
/* GUI generated Fri Jun 23 16:22:12 2023 */

/* Y direction */
YAnchor(7)
YDist(7,0,&gt;=3)
ResYDist(0,15)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 363, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:22:23 2023 */
SVTCA[Y]
MDAP[R], 7
SMD[], 192
MDRP[m&gt;RGr], 0
CALL[], 0, 15, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="364">
      <instructions>
        <talk>/* VTTTalk glyph 364, char 0xffff */
/* GUI generated Fri Jun 23 16:22:49 2023 */

/* Y direction */
YAnchor(7)
ResYDist(7,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 364, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:22:50 2023 */
SVTCA[Y]
MDAP[R], 7
CALL[], 7, 0, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="365">
      <instructions>
        <talk>/* VTTTalk glyph 365, char 0xa8 */
/* GUI generated Fri Jun 23 16:23:03 2023 */

/* Y direction */
YAnchor(12)
YShift(12,0)
ResYDist(12,18)
YShift(18,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 365, char 0xa8 */
/* VTT 6.35 compiler Fri Jun 23 16:23:03 2023 */
SVTCA[Y]
MDAP[R], 12
SHP[1], 0
CALL[], 12, 18, 106
SHP[2], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="366">
      <instructions>
        <talk>/* VTTTalk glyph 366, char 0x2d9 */
/* GUI generated Fri Jun 23 16:23:07 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,6)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 366, char 0x2d9 */
/* VTT 6.35 compiler Fri Jun 23 16:23:09 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 6, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="367">
      <instructions>
        <talk>/* VTTTalk glyph 367, char 0x60 (`) */
/* GUI generated Fri Jun 23 16:23:21 2023 */

/* Y direction */
YAnchor(0)
YDist(0,5,&gt;=2)
YInterpolate(0,9,4,5)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 367, char 0x60 (`) */
/* VTT 6.35 compiler Fri Jun 23 16:23:21 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 5
IP[], 9
IP[], 4
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="368">
      <instructions>
        <talk>/* VTTTalk glyph 368, char 0xb4 */
/* GUI generated Fri Jun 23 16:23:36 2023 */

/* Y direction */
YAnchor(0)
YDist(0,5,&gt;=2)
YInterpolate(5,6,1,0)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 368, char 0xb4 */
/* VTT 6.35 compiler Fri Jun 23 16:23:36 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 5
IP[], 6
IP[], 1
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="369">
      <instructions>
        <talk>/* VTTTalk glyph 369, char 0x2dd */
/* GUI generated Fri Jun 23 16:23:51 2023 */

/* Y direction */
YAnchor(4)
YShift(4,0)
YDist(4,6,&gt;=2)
YShift(6,2)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 369, char 0x2dd */
/* VTT 6.35 compiler Fri Jun 23 16:23:51 2023 */
SVTCA[Y]
MDAP[R], 4
SHP[1], 0
SMD[], 128
MDRP[m&gt;RBl], 6
SHP[2], 2
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="370">
      <instructions>
        <talk>/* VTTTalk glyph 370, char 0x2c6 */
/* GUI generated Fri Jun 23 16:24:07 2023 */

/* Y direction */
YAnchor(0)
YShift(0,1)
YDist(0,5,&gt;=2)
YInterpolate(0,11,5)
YShift(0,10)
YShift(10,9)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 370, char 0x2c6 */
/* VTT 6.35 compiler Fri Jun 23 16:24:07 2023 */
SVTCA[Y]
MDAP[R], 0
SHP[2], 1
SMD[], 128
MDRP[m&gt;RBl], 5
IP[], 11
SHP[1], 10
SRP1[], 10
SHP[1], 9
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="371">
      <instructions>
        <talk>/* VTTTalk glyph 371, char 0x2c7 */
/* GUI generated Fri Jun 23 16:24:24 2023 */

/* Y direction */
YAnchor(0)
YDist(0,7,&gt;=2)
YShift(7,8)
YShift(7,5)
YShift(5,4)
YInterpolate(0,6,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 371, char 0x2c7 */
/* VTT 6.35 compiler Fri Jun 23 16:24:24 2023 */
SVTCA[Y]
MDAP[R], 0
SMD[], 128
MDRP[m&gt;RBl], 7
SHP[2], 8
SHP[2], 5
SRP1[], 5
SHP[1], 4
SRP1[], 0
IP[], 6
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="372">
      <instructions>
        <talk>/* VTTTalk glyph 372, char 0x2d8 */
/* GUI generated Fri Jun 23 16:24:41 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,7)
YDist(0,3,&gt;=2)
YShift(3,10)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 372, char 0x2d8 */
/* VTT 6.35 compiler Fri Jun 23 16:24:41 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 7, 106
SMD[], 128
SRP0[], 0
MDRP[m&gt;RBl], 3
SHP[2], 10
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="373">
      <instructions>
        <talk>/* VTTTalk glyph 373, char 0x2da */
/* GUI generated Fri Jun 23 16:24:46 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,12)
YDist(0,6,&gt;=3)
ResYDist(6,18)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 373, char 0x2da */
/* VTT 6.35 compiler Fri Jun 23 16:24:49 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 12, 106
SMD[], 192
SRP0[], 0
MDRP[m&gt;RGr], 6
CALL[], 6, 18, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="374">
      <instructions>
        <talk>/* VTTTalk glyph 374, char 0x2dc */
/* GUI generated Fri Jun 23 16:25:08 2023 */

/* Y direction */
YAnchor(0)
YDist(0,8)
ResYDist(0,17)
YDist(0,11,&gt;=2)
ResYDist(11,6)
YDist(11,19)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 374, char 0x2dc */
/* VTT 6.35 compiler Fri Jun 23 16:25:08 2023 */
SVTCA[Y]
MDAP[R], 0
MDRP[m&lt;RGr], 8
CALL[], 0, 17, 106
SMD[], 128
SRP0[], 0
MDRP[m&gt;RBl], 11
CALL[], 11, 6, 106
SRP0[], 11
MDRP[m&lt;RGr], 19
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="375">
      <instructions>
        <talk>/* VTTTalk glyph 375, char 0xaf */
/* GUI generated Fri Jun 23 16:25:14 2023 */

/* Y direction */
YAnchor(0)
ResYDist(0,7)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 375, char 0xaf */
/* VTT 6.35 compiler Fri Jun 23 16:25:16 2023 */
SVTCA[Y]
MDAP[R], 0
CALL[], 0, 7, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="376">
      <instructions>
        <talk>/* VTTTalk glyph 376, char 0xb8 */
/* GUI generated Fri Jun 23 16:25:48 2023 */

/* Y direction */
YAnchor(14)
YDist(14,0,&gt;=3)
ResYDist(0,6)
YInterpolate(6,16,14)
YInterpolate(0,13,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 376, char 0xb8 */
/* VTT 6.35 compiler Fri Jun 23 16:25:48 2023 */
SVTCA[Y]
MDAP[R], 14
SMD[], 192
MDRP[m&gt;RGr], 0
CALL[], 0, 6, 106
SRP1[], 14
IP[], 16
SRP2[], 0
IP[], 13
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="377">
      <instructions>
        <talk>/* VTTTalk glyph 377, char 0x2db */
/* GUI generated Fri Jun 23 16:26:00 2023 */

/* Y direction */
YAnchor(8)
YDist(8,0,&gt;=3)
ResYDist(0,16)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 377, char 0x2db */
/* VTT 6.35 compiler Fri Jun 23 16:26:03 2023 */
SVTCA[Y]
MDAP[R], 8
SMD[], 192
MDRP[m&gt;RGr], 0
CALL[], 0, 16, 106
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="378">
      <instructions>
        <talk></talk>
        <assembly>
/* VTTTalk Unicode 0x2bc */
/* ACT generated Fri Jun 23 01:02:17 2023 */

USEMYMETRICS[]
OFFSET[R], 270, 0, 0</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="379">
      <instructions>
        <talk>/* VTTTalk glyph 379, char 0xffff */
/* GUI generated Fri Jun 23 16:28:22 2023 */

/* Y direction */
YAnchor(31)
YShift(31,28)
YDist(31,4)
ResYDist(4,11)
YShift(11,37)
YShift(31,13)
YShift(13,14)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 379, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:28:22 2023 */
SVTCA[Y]
MDAP[R], 31
SHP[1], 28
MDRP[m&lt;RGr], 4
CALL[], 4, 11, 106
SHP[2], 37
SRP1[], 31
SHP[1], 13
SRP1[], 13
SHP[1], 14
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="380">
      <instructions>
        <talk>/* VTTTalk glyph 380, char 0xffff */
/* GUI generated Fri Jun 23 16:28:53 2023 */

/* Y direction */
YAnchor(25)
ResYDist(25,10)
YDist(25,47)
YInterpolate(47,31,5,25)
ResYDist(47,33)
YShift(33,4)
YShift(33,32)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 380, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:28:53 2023 */
SVTCA[Y]
MDAP[R], 25
CALL[], 25, 10, 106
SRP0[], 25
MDRP[m&lt;RGr], 47
IP[], 31
IP[], 5
CALL[], 47, 33, 106
SHP[2], 4
SHP[2], 32
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="381">
      <instructions>
        <talk>/* VTTTalk glyph 381, char 0xffff */
/* GUI generated Fri Jun 23 16:29:24 2023 */

/* Y direction */
YAnchor(54)
YDist(54,0)
ResYDist(0,15)
YIPAnchor(54,20,0)
YInterpolate(15,10,20)
ResYDist(20,34)
YInterpolate(34,61,62,20)
ResYDist(54,39)
YInterpolate(34,44,39)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 381, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:29:24 2023 */
SVTCA[Y]
MDAP[R], 54
MDRP[m&lt;RGr], 0
CALL[], 0, 15, 106
SRP2[], 54
IP[], 20
MDAP[R], 20
SRP2[], 15
IP[], 10
CALL[], 20, 34, 106
IP[], 61
IP[], 62
CALL[], 54, 39, 106
SRP1[], 34
IP[], 44
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
    <TTGlyph ID="382">
      <instructions>
        <talk>/* VTTTalk glyph 382, char 0xffff */
/* GUI generated Fri Jun 23 16:29:44 2023 */

/* Y direction */
YAnchor(19)
YDist(19,3)
YIPAnchor(19,9,3)
YInterpolate(19,42,9)
YShift(9,39)
ResYDist(9,40)
YShift(40,15)
YShift(40,24)

/* X direction */

Smooth()
</talk>
        <assembly>/* TT glyph 382, char 0xffff */
/* VTT 6.35 compiler Fri Jun 23 16:29:44 2023 */
SVTCA[Y]
MDAP[R], 19
MDRP[m&gt;RBl], 3
IP[], 9
MDAP[R], 9
SRP2[], 19
IP[], 42
SHP[1], 39
CALL[], 9, 40, 106
SHP[2], 15
SHP[2], 24
IUP[Y]
IUP[X]
</assembly>
      </instructions>
    </TTGlyph>
  </glyf>
</ttFont>